'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@formkit/core');
var autoAnimate = require('@formkit/auto-animate');
var utils = require('@formkit/utils');
var inputs = require('@formkit/inputs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var autoAnimate__default = /*#__PURE__*/_interopDefaultLegacy(autoAnimate);

const pendingIds = new Map();
let observer = null;
/**
 * Create a new mutation observer that checks for the document for ids. We do
 * this instead of iterating over the mutations because getElementById is by far
 * the fastest way check for an element in the DOM, much faster that iterating
 * over the mutations themselves.
 */
function createObserver() {
    observeIds();
    observer = new MutationObserver(() => {
        observeIds();
        if (!pendingIds.size && observer) {
            observer.disconnect();
            observer = null;
        }
    });
    observer.observe(document, { childList: true, subtree: true });
}
function observeIds() {
    pendingIds.forEach((options, id) => {
        const outer = document.getElementById(id);
        if (outer) {
            pendingIds.delete(id);
            autoAnimate__default["default"](outer, options || {});
        }
    });
}
/**
 * Adds auto-animate to each input automatically:
 *
 * @example
 *
 * ```javascript
 * import { createApp } from 'vue'
 * import App from 'App.vue'
 * import { createAutoAnimatePlugin } from '@formkit/addons'
 * import { plugin, defaultConfig } from '@formkit/vue'
 *
 * createApp(app).use(plugin, defaultPlugin({
 *   plugins: [
 *     createAutoAnimatePlugin({
 *       // optional config
 *     })
 *   ]
 * }))
 * ```
 *
 * @param options - {@link https://github.com/formkit/auto-animate/blob/master/src/index.ts#L596 | AutoAnimateOptions }
 *
 * @returns
 * {@link @formkit/core#FormKitPlugin | FormKitPlugin}
 *
 * @public
 */
function createAutoAnimatePlugin(options) {
    return (node) => {
        node.on('created', () => {
            var _a;
            if (typeof ((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.schema) === 'function') {
                if (typeof window === undefined)
                    return;
                // add an outer wrapper id or get the current one
                const original = node.props.definition.schema;
                node.props.definition.schema = (extensions) => {
                    extensions.outer = utils.extend({ attrs: { id: `outer-${node.props.id}` } }, extensions.outer || {});
                    const finalSchema = original(extensions);
                    const outermostSchema = core.isConditional(finalSchema[0])
                        ? Array.isArray(finalSchema[0].else)
                            ? finalSchema[0].else[0]
                            : finalSchema[0].else
                        : finalSchema[0];
                    if (outermostSchema &&
                        core.isDOM(outermostSchema) &&
                        outermostSchema.attrs &&
                        'id' in outermostSchema.attrs) {
                        pendingIds.set(String(outermostSchema.attrs.id === '$id'
                            ? node.props.id
                            : outermostSchema.attrs.id), options || undefined);
                    }
                    return finalSchema;
                };
            }
            if (!observer && typeof window !== 'undefined')
                createObserver();
        });
    };
}

/**
 * Contains the "next" action element for a multi-step step.
 *
 * @public
 */
const badge = inputs.createSection('badge', () => ({
    $el: 'span',
    attrs: {
        role: 'presentation',
    },
}));

/**
 * Contains the action buttons for a multi-step step.
 *
 * @public
 */
const stepActions = inputs.createSection('stepActions', () => ({
    $el: 'div',
}));

/**
 * Inner section of a multi-step step.
 *
 * @public
 */
const stepInner = inputs.createSection('stepInner', 'div');

/**
 * Contains the "next" action element for a multi-step step.
 *
 * @public
 */
const stepNext = inputs.createSection('stepNext', () => ({
    $el: 'div',
    if: '$isLastStep === false',
    children: [
        {
            $cmp: 'FormKit',
            bind: '$nextAttrs',
            props: {
                type: 'button',
                label: {
                    if: '$nextLabel',
                    then: '$nextLabel',
                    else: '$ui.next.value',
                },
                'data-next': '$isLastStep === false',
                onClick: '$handlers.next',
            },
        },
    ],
}));

/**
 * Outer section of a multi-step step. Has conditinal styling
 * depending on if it's the $activeStep.
 *
 * @public
 */
const stepOuter = inputs.createSection('stepOuter', () => ({
    $el: 'div',
    attrs: {
        key: '$id',
        'data-type': 'step',
        'data-disabled': '$disabled || undefined',
        'data-complete': '$state.complete || undefined',
        'data-invalid': '$state.valid === false && $state.validationVisible || undefined',
        'data-errors': '$state.errors || undefined',
        'data-submitted': '$state.submitted || undefined',
        id: '$id',
        role: 'tabpanel',
        'aria-labelledby': '$node.parent.props.id + "_tab_" + $stepIndex',
        class: '$classes.step',
        hidden: '$isActiveStep === false || undefined',
    },
}), true);

/**
 * Contains the "previous" action element for a multi-step step.
 *
 * @public
 */
const stepPrevious = inputs.createSection('stepPrevious', () => ({
    $el: 'div',
    if: '$isFirstStep === false',
    children: [
        {
            $cmp: 'FormKit',
            bind: '$previousAttrs',
            props: {
                type: 'button',
                label: {
                    if: '$previousLabel',
                    then: '$previousLabel',
                    else: '$ui.prev.value',
                },
                'data-prev': '$isFirstStep === false',
                onClick: '$handlers.previous',
            },
        },
    ],
}));

/**
 * Steps section, wraps all the steps of a multi-step form
 *
 * @public
 */
const steps = inputs.createSection('steps', () => ({
    $el: 'div',
}));

/**
 * Icon section used by multi-step steps
 *
 * @public
 */
const stepIcon = (sectionKey, el) => {
    return inputs.createSection(`${sectionKey}Icon`, () => {
        const rawIconProp = `_raw${sectionKey
            .charAt(0)
            .toUpperCase()}${sectionKey.slice(1)}Icon`;
        return {
            if: `$step.${sectionKey}Icon && $step.${rawIconProp}`,
            then: {
                $el: `${el ? el : 'span'}`,
                attrs: {
                    class: `$classes.${sectionKey}Icon + " formkit-icon"`,
                    innerHTML: `$step.${rawIconProp}`,
                    role: 'presentation',
                    onClick: `$handlers.iconClick(${sectionKey})`,
                },
            },
            else: {
                if: `$${sectionKey}Icon && $${rawIconProp}`,
                then: {
                    $el: `${el ? el : 'span'}`,
                    attrs: {
                        class: `$classes.${sectionKey}Icon + " formkit-icon"`,
                        innerHTML: `$${rawIconProp}`,
                        role: 'presentation',
                        onClick: `$handlers.iconClick(${sectionKey})`,
                    },
                },
            },
        };
    })();
};

/**
 * Tab section, holds a group of tabs
 *
 * @public
 */
const tab = inputs.createSection('tab', () => ({
    $el: 'button',
    for: ['step', 'index', '$steps'],
    attrs: {
        type: 'button',
        onClick: '$step.makeActive',
        'data-active': '$step.isActiveStep',
        'data-valid': '$step.isValid',
        'data-visited': '$step.hasBeenVisited',
        role: 'tab',
        id: '$id + "_tab_" + $index',
        'aria-selected': '$step.isActiveStep || false',
        'aria-controls': '$step.id',
        tabindex: {
            if: '$step.isActiveStep',
            then: '0',
            else: '-1',
        },
        style: {
            if: '$step.ordered',
            then: '',
            else: 'display: none',
        },
    },
}));

/**
 * the label for a tab in a multi-step input
 *
 * @public
 */
const tabLabel = inputs.createSection('tabLabel', () => ({
    $el: 'span',
}));

/**
 * Tab section, holds a group of tabs
 *
 * @public
 */
const tabs = inputs.createSection('tabs', () => ({
    $el: 'div',
    attrs: {
        role: 'tablist',
    },
}));

/**
 * Outer section of the multi-step where most data attributes are assigned.
 *
 * @public
 */
const multiStepOuter = inputs.createSection('multiStepOuter', () => ({
    $el: 'div',
    attrs: {
        key: '$id',
        id: '$id',
        class: '$classes.outer',
        'data-family': '$family || undefined',
        'data-type': '$type',
        'data-multiple': '$attrs.multiple || ($type != "select" && $options != undefined) || undefined',
        'data-disabled': '$disabled || undefined',
        'data-complete': '$state.complete || undefined',
        'data-invalid': '$state.valid === false && $state.validationVisible || undefined',
        'data-errors': '$state.errors || undefined',
        'data-submitted': '$state.submitted || undefined',
    },
}), true);

const multiStep = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: multiStepOuter(inputs.$extend(inputs.wrapper(tabs(tab(inputs.$if('$tabStyle === "tab" || ($tabStyle === "progress" && $hideProgressLabels === false)', tabLabel('$step.stepName')), inputs.$if('($step.totalErrorCount > 0) && $step.showStepErrors', badge('$step.totalErrorCount')), inputs.$if('$step.isValid && $step.hasBeenVisited', badge(stepIcon('validStep'))))), steps('$slots.default')), {
        attrs: {
            'data-tab-style': '$tabStyle',
            'data-hide-labels': '$hideProgressLabels',
        },
    })),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'group',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: 'multi-step',
    /**
     * An array of extra props to accept for this input.
     */
    props: [
        'allowIncomplete',
        'hideProgressLabels',
        'tabStyle',
        'beforeStepChange',
        'validStepIcon',
    ],
    /**
     * Additional features that should be added to your input
     */
    features: [inputs.defaultIcon('validStep', 'check')],
};
const step = {
    /**
     * The actual schema of the input, or a function that returns the schema.
     */
    schema: stepOuter(stepInner('$slots.default'), stepActions(stepPrevious(), stepNext())),
    /**
     * The type of node, can be a list, group, or input.
     */
    type: 'group',
    /**
     * The family of inputs this one belongs too. For example "text" and "email"
     * are both part of the "text" family. This is primary used for styling.
     */
    family: '',
    /**
     * An array of extra props to accept for this input.
     */
    props: [
        'previousLabel',
        'nextLabel',
        'beforeStepChange',
        'previousAttrs',
        'nextAttrs',
        'validStepIcon',
    ],
    /**
     * Additional features that should be added to your input
     */
    features: [inputs.localize('next'), inputs.localize('prev')],
};

const isBrowser = typeof window !== 'undefined';
/**
 * Coverts a camelCase string to a title case string
 *
 * @param str - The string to convert
 * @returns string
 */
const camel2title = (str) => str
    .replace(/([A-Z])/g, (match) => ` ${match}`)
    .replace(/^./, (match) => match.toUpperCase())
    .trim();
/**
 * Compares steps to DOM order and reorders steps if needed
 */
function orderSteps(steps) {
    const orderedSteps = steps.sort((a, b) => {
        const aEl = document.getElementById(a.id);
        const bEl = document.getElementById(b.id);
        if (!aEl || !bEl)
            return 0;
        return aEl.compareDocumentPosition(bEl) === 2 ? 1 : -1;
    });
    steps.map((step) => (step.ordered = true));
    return orderedSteps;
}
/**
 * Iterates through each step and sets props to help
 * determine step positioning within the multi-step.
 *
 * @param steps - The steps to iterate through
 */
function setNodePositionProps(steps) {
    steps.forEach((step, index) => {
        step.isFirstStep = index === 0;
        step.isLastStep = index === steps.length - 1;
        step.stepIndex = index;
        step.steps = steps;
    });
}
function showStepErrors(step) {
    if (!step.showStepErrors)
        return;
    return (parseInt(step.blockingCount) +
        parseInt(step.errorCount) >
        0);
}
/**
 * Determines if the target step can be navigated to based on current
 * configuration options and the state of the current step.
 *
 * @param currentStep - The current step
 * @param targetStep - The target step
 */
function isTargetStepAllowed(currentStep, targetStep) {
    var _a, _b, _c;
    const { allowIncomplete } = ((_a = currentStep.node.parent) === null || _a === void 0 ? void 0 : _a.props) || {};
    const parentNode = currentStep.node.parent;
    const currentStepIndex = parentNode === null || parentNode === void 0 ? void 0 : parentNode.props.steps.indexOf(currentStep);
    const targetStepIndex = parentNode === null || parentNode === void 0 ? void 0 : parentNode.props.steps.indexOf(targetStep);
    // check if there is a function for the stepChange guard
    const beforeStepChange = currentStep.node.props.beforeStepChange ||
        ((_b = currentStep.node.parent) === null || _b === void 0 ? void 0 : _b.props.beforeStepChange);
    if (beforeStepChange && typeof beforeStepChange === 'function') {
        const result = beforeStepChange({
            currentStep,
            targetStep,
            delta: targetStepIndex - currentStepIndex,
        });
        if (typeof result === 'boolean' && !result)
            return false;
    }
    // show the current step errors because this step has
    // been visited.
    triggerStepValidations(currentStep);
    currentStep.showStepErrors = true;
    if (targetStepIndex < currentStepIndex) {
        // we can always step backwards
        return true;
    }
    // check how many steps we need to step forward
    // and then check that each intermediate step is valid
    const delta = targetStepIndex - currentStepIndex;
    for (let i = 0; i < delta; i++) {
        const intermediateStep = parentNode === null || parentNode === void 0 ? void 0 : parentNode.props.steps[currentStepIndex + i];
        const stepIsAllowed = allowIncomplete || ((_c = intermediateStep.state) === null || _c === void 0 ? void 0 : _c.valid);
        if (!stepIsAllowed) {
            return false;
        }
    }
    return true;
}
/**
 * Changes the active step to the target step if the target step is allowed.
 *
 * @param targetStep - The target step
 */
function setActiveStep(targetStep, e) {
    if (e) {
        e.preventDefault();
    }
    if (targetStep && targetStep.node.name && targetStep.node.parent) {
        const currentStep = targetStep.node.parent.props.steps.find((step) => { var _a; return step.node.name === ((_a = targetStep.node.parent) === null || _a === void 0 ? void 0 : _a.props.activeStep); });
        const stepIsAllowed = isTargetStepAllowed(currentStep, targetStep);
        if (stepIsAllowed && targetStep.node.parent.context) {
            targetStep.node.parent.props.activeStep = targetStep.node.name;
        }
    }
}
/**
 * Changes the current step by the delta value if the target step is allowed.
 *
 * @param delta - The number of steps to increment or decrement
 * @param step - The current step
 */
function incrementStep(delta, currentStep) {
    if (currentStep && currentStep.node.name && currentStep.node.parent) {
        const { steps, stepIndex, } = currentStep;
        const targetStep = steps[stepIndex + delta];
        const stepIsAllowed = isTargetStepAllowed(currentStep, targetStep);
        if (targetStep && stepIsAllowed) {
            currentStep.node.parent.props.activeStep = targetStep.node.name;
        }
    }
}
/**
 * Causes the display of any validation errors on the target step.
 *
 * @param step - The current step
 * @returns Boolean
 */
function triggerStepValidations(step) {
    var _a, _b;
    step.node.walk((n) => {
        n.store.set(core.createMessage({
            key: 'submitted',
            value: true,
            visible: false,
        }));
    });
    return (((_a = step.node.context) === null || _a === void 0 ? void 0 : _a.state.valid) || ((_b = step.node.parent) === null || _b === void 0 ? void 0 : _b.props.allowIncomplete));
}
function initEvents(node, el) {
    if (!(el instanceof HTMLElement))
        return;
    el.addEventListener('keydown', (event) => {
        var _a;
        if (event.target instanceof HTMLButtonElement) {
            if (event.key === 'Tab' &&
                'data-next' in ((_a = event.target) === null || _a === void 0 ? void 0 : _a.attributes) &&
                !event.shiftKey) {
                event.preventDefault();
                const activeStepContext = node.children.find((step) => step.name === node.props.activeStep);
                if (activeStepContext && activeStepContext.context) {
                    incrementStep(1, activeStepContext.context);
                }
            }
        }
    });
}
/**
 * Creates a new multi-step plugin.
 *
 * @param options - The options of {@link MultiStepOptions | MultiStepOptions} to pass to the plugin
 *
 * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}
 *
 * @public
 */
function createMultiStepPlugin(options) {
    const multiStepPlugin = (node) => {
        var _a, _b;
        if (node.props.type === 'multi-step') {
            node.addProps(['steps', 'activeStep']);
            node.props.allowIncomplete =
                typeof node.props.allowIncomplete === 'boolean'
                    ? node.props.allowIncomplete
                    : typeof (options === null || options === void 0 ? void 0 : options.allowIncomplete) === 'boolean'
                        ? options === null || options === void 0 ? void 0 : options.allowIncomplete
                        : true;
            node.props.hideProgressLabels =
                typeof node.props.hideProgressLabels === 'boolean'
                    ? node.props.hideProgressLabels
                    : (options === null || options === void 0 ? void 0 : options.hideProgressLabels) || false;
            node.props.tabStyle = node.props.tabStyle || (options === null || options === void 0 ? void 0 : options.tabStyle) || 'tab';
            node.on('created', () => {
                if (!node.context)
                    return;
                node.context.handlers.triggerStepValidations = triggerStepValidations;
                node.context.handlers.showStepErrors = showStepErrors;
                utils.whenAvailable(`${node.props.id}`, (el) => {
                    initEvents(node, el);
                });
            });
            node.on('prop:activeStep', ({ payload }) => {
                node.children.forEach((child) => {
                    child.props.isActiveStep = child.name === payload;
                    if (isBrowser && child.name === payload) {
                        const el = document.querySelector(`[aria-controls="${child.props.id}"]`);
                        if (el instanceof HTMLButtonElement) {
                            el.focus();
                        }
                    }
                });
            });
            node.on('childRemoved', ({ payload: childNode }) => {
                let removedStepIndex = -1;
                node.props.steps = node.props.steps.filter((step, index) => {
                    if (step.node.name !== childNode.name) {
                        return true;
                    }
                    removedStepIndex = index;
                    return false;
                });
                // if the child that was removed was the active step
                // then fallback to the next available step
                if (node.props.activeStep === childNode.name) {
                    const targetIndex = removedStepIndex > 0 ? removedStepIndex - 1 : 0;
                    node.props.activeStep = node.props.steps[targetIndex]
                        ? node.props.steps[targetIndex].node.name
                        : '';
                }
                // recompute step positions
                orderSteps(node.props.steps);
                setNodePositionProps(node.props.steps);
            });
        }
        if (node.props.type === 'step' &&
            ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.props.type) === 'multi-step') {
            node.addProps([
                'isActiveStep',
                'isFirstStep',
                'isLastStep',
                'stepName',
                'errorCount',
                'blockingCount',
                'totalErrorCount',
                'showStepErrors',
                'isValid',
                'hasBeenVisited',
                'ordered',
            ]);
            node.on('created', () => {
                if (!node.context)
                    return;
                if (node.parent && node.parent.context) {
                    node.props.stepName = node.props.label || camel2title(node.name);
                    node.props.errorCount = 0;
                    node.props.blockingCount = 0;
                    node.props.isActiveStep = false;
                    const parentNode = node.parent;
                    parentNode.props.steps = Array.isArray(parentNode.props.steps)
                        ? [...parentNode.props.steps, node.context]
                        : [node.context];
                    utils.whenAvailable(`${node.props.id}`, () => {
                        parentNode.props.steps = orderSteps(parentNode.props.steps);
                        setNodePositionProps(parentNode.props.steps);
                        parentNode.props.activeStep = parentNode.props.activeStep
                            ? parentNode.props.activeStep
                            : parentNode.props.steps[0]
                                ? parentNode.props.steps[0].node.name
                                : '';
                    });
                    if (node.context && parentNode.context) {
                        parentNode.context.handlers.setActiveStep = (stepNode) => setActiveStep.bind(null, stepNode);
                        node.context.handlers.incrementStep = (delta, stepNode) => incrementStep.bind(null, delta, stepNode);
                        node.context.makeActive = () => {
                            setActiveStep(node.context);
                        };
                        node.context.handlers.next = () => incrementStep(1, node.context);
                        node.context.handlers.previous = () => incrementStep(-1, node.context);
                    }
                }
            });
            node.on('count:errors', ({ payload: count }) => {
                node.props.errorCount = count;
            });
            node.on('count:blocking', ({ payload: count }) => {
                node.props.blockingCount = count;
            });
            function updateTotalErrorCount(node) {
                node.props.totalErrorCount =
                    node.props.errorCount + node.props.blockingCount;
            }
            node.on('prop:errorCount', () => updateTotalErrorCount(node));
            node.on('prop:blockingCount', () => updateTotalErrorCount(node));
            node.on('prop:totalErrorCount', () => {
                node.props.isValid = node.props.totalErrorCount <= 0;
            });
            node.on('message-added', ({ payload }) => {
                if (payload.key === 'submitted') {
                    updateTotalErrorCount(node);
                    if (node.context) {
                        triggerStepValidations(node.context);
                        node.props.showStepErrors = true;
                    }
                }
            });
            node.on('prop:isActiveStep', () => {
                if (!node.props.hasBeenVisited && node.props.isActiveStep) {
                    node.props.hasBeenVisited = true;
                }
            });
        }
        else if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.props.type) === 'multi-step') {
            console.warn('Invalid FormKit input location. <FormKit type="multi-step"> should only have <FormKit type="step"> inputs as immediate children. Failure to wrap child inputs in <FormKit type="step"> can lead to undesired behaviors.');
        }
    };
    multiStepPlugin.library = (node) => {
        switch (node.props.type) {
            case 'multi-step':
                return node.define(multiStep);
            case 'step':
                const isInvalid = !node.parent || node.parent.props.type !== 'multi-step';
                if (isInvalid) {
                    console.warn('Invalid use of <FormKit type="step">. <FormKit type="step"> must be an immediate child of a <FormKit type="multi-step"> component.');
                }
                return node.define(step);
        }
    };
    return multiStepPlugin;
}

/**
 * Creates a new floating label plugin.
 *
 * @param FloatingLabelsOptions - The options of {@link FloatingLabelsOptions | FloatingLabelsOptions} to pass to the plugin
 *
 * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}
 *
 * @public
 */
function createFloatingLabelsPlugin(FloatingLabelsOptions) {
    const floatingLabelsPlugin = (node) => {
        node.addProps(['floatingLabel']);
        const useFloatingLabels = typeof node.props.floatingLabel === 'boolean'
            ? node.props.floatingLabel
            : typeof (FloatingLabelsOptions === null || FloatingLabelsOptions === void 0 ? void 0 : FloatingLabelsOptions.useAsDefault) === 'boolean'
                ? FloatingLabelsOptions === null || FloatingLabelsOptions === void 0 ? void 0 : FloatingLabelsOptions.useAsDefault
                : false;
        if (useFloatingLabels) {
            node.on('created', () => {
                if (!node.props || !node.props.definition)
                    return;
                const inputDefinition = utils.clone(node.props.definition);
                if (['text', 'dropdown'].includes(node.props.family) ||
                    ['datepicker', 'textarea'].includes(node.props.type)) {
                    const originalSchema = inputDefinition.schema;
                    if (typeof originalSchema !== 'function')
                        return;
                    const higherOrderSchema = (extensions) => {
                        extensions.outer = {
                            attrs: {
                                'data-floating-label': 'true',
                            },
                        };
                        extensions.label = {
                            attrs: {
                                'data-has-value': '$_value !== "" && $_value !== undefined',
                            },
                        };
                        const inputSchema = originalSchema(extensions);
                        const [labelParentChildren, labelSection] = inputs.findSection(inputSchema, 'label');
                        const [inputParentChildren] = inputs.findSection(inputSchema, 'input');
                        if (labelParentChildren && labelSection && inputParentChildren) {
                            labelParentChildren.splice(labelParentChildren.indexOf(labelSection), 1);
                            inputParentChildren.push(labelSection);
                        }
                        return inputSchema;
                    };
                    inputDefinition.schema = higherOrderSchema;
                    node.props.definition = inputDefinition;
                }
            });
        }
    };
    return floatingLabelsPlugin;
}

exports.createAutoAnimatePlugin = createAutoAnimatePlugin;
exports.createFloatingLabelsPlugin = createFloatingLabelsPlugin;
exports.createMultiStepPlugin = createMultiStepPlugin;
