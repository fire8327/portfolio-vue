import {
  $extend,
  $if,
  createMessage,
  createSection,
  defaultIcon,
  findSection,
  isConditional,
  isDOM,
  localize,
  wrapper
} from "./chunk-IDBGPFDQ.js";
import {
  clone,
  extend,
  whenAvailable
} from "./chunk-MLJC6KSR.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@formkit/auto-animate/index.mjs
var parents = /* @__PURE__ */ new Set();
var coords = /* @__PURE__ */ new WeakMap();
var siblings = /* @__PURE__ */ new WeakMap();
var animations = /* @__PURE__ */ new WeakMap();
var intersections = /* @__PURE__ */ new WeakMap();
var intervals = /* @__PURE__ */ new WeakMap();
var options = /* @__PURE__ */ new WeakMap();
var debounces = /* @__PURE__ */ new WeakMap();
var enabled = /* @__PURE__ */ new WeakSet();
var root;
var TGT = "__aa_tgt";
var DEL = "__aa_del";
var handleMutations = (mutations2) => {
  const elements = getElements(mutations2);
  if (elements) {
    elements.forEach((el) => animate(el));
  }
};
var handleResizes = (entries) => {
  entries.forEach((entry) => {
    if (entry.target === root)
      updateAllPos();
    if (coords.has(entry.target))
      updatePos(entry.target);
  });
};
function observePosition(el) {
  const oldObserver = intersections.get(el);
  oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();
  let rect = coords.get(el);
  let invocations = 0;
  const buffer = 5;
  if (!rect) {
    rect = getCoords(el);
    coords.set(el, rect);
  }
  const { offsetWidth, offsetHeight } = root;
  const rootMargins = [
    rect.top - buffer,
    offsetWidth - (rect.left + buffer + rect.width),
    offsetHeight - (rect.top + buffer + rect.height),
    rect.left - buffer
  ];
  const rootMargin = rootMargins.map((px) => `${-1 * Math.floor(px)}px`).join(" ");
  const observer2 = new IntersectionObserver(() => {
    ++invocations > 1 && updatePos(el);
  }, {
    root,
    threshold: 1,
    rootMargin
  });
  observer2.observe(el);
  intersections.set(el, observer2);
}
function updatePos(el) {
  clearTimeout(debounces.get(el));
  const optionsOrPlugin = getOptions(el);
  const delay = typeof optionsOrPlugin === "function" ? 500 : optionsOrPlugin.duration;
  debounces.set(el, setTimeout(async () => {
    const currentAnimation = animations.get(el);
    try {
      await (currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.finished);
      coords.set(el, getCoords(el));
      observePosition(el);
    } catch {
    }
  }, delay));
}
function updateAllPos() {
  clearTimeout(debounces.get(root));
  debounces.set(root, setTimeout(() => {
    parents.forEach((parent) => forEach(parent, (el) => lowPriority(() => updatePos(el))));
  }, 100));
}
function poll(el) {
  setTimeout(() => {
    intervals.set(el, setInterval(() => lowPriority(updatePos.bind(null, el)), 2e3));
  }, Math.round(2e3 * Math.random()));
}
function lowPriority(callback) {
  if (typeof requestIdleCallback === "function") {
    requestIdleCallback(() => callback());
  } else {
    requestAnimationFrame(() => callback());
  }
}
var mutations;
var resize;
if (typeof window !== "undefined") {
  root = document.documentElement;
  mutations = new MutationObserver(handleMutations);
  resize = new ResizeObserver(handleResizes);
  resize.observe(root);
}
function getElements(mutations2) {
  const observedNodes = mutations2.reduce((nodes, mutation) => {
    return [
      ...nodes,
      ...Array.from(mutation.addedNodes),
      ...Array.from(mutation.removedNodes)
    ];
  }, []);
  const onlyCommentNodesObserved = observedNodes.every((node) => node.nodeName === "#comment");
  if (onlyCommentNodesObserved)
    return false;
  return mutations2.reduce((elements, mutation) => {
    if (elements === false)
      return false;
    if (mutation.target instanceof Element) {
      target(mutation.target);
      if (!elements.has(mutation.target)) {
        elements.add(mutation.target);
        for (let i = 0; i < mutation.target.children.length; i++) {
          const child = mutation.target.children.item(i);
          if (!child)
            continue;
          if (DEL in child)
            return false;
          target(mutation.target, child);
          elements.add(child);
        }
      }
      if (mutation.removedNodes.length) {
        for (let i = 0; i < mutation.removedNodes.length; i++) {
          const child = mutation.removedNodes[i];
          if (DEL in child)
            return false;
          if (child instanceof Element) {
            elements.add(child);
            target(mutation.target, child);
            siblings.set(child, [
              mutation.previousSibling,
              mutation.nextSibling
            ]);
          }
        }
      }
    }
    return elements;
  }, /* @__PURE__ */ new Set());
}
function target(el, child) {
  if (!child && !(TGT in el))
    Object.defineProperty(el, TGT, { value: el });
  else if (child && !(TGT in child))
    Object.defineProperty(child, TGT, { value: el });
}
function animate(el) {
  var _a;
  const isMounted = el.isConnected;
  const preExisting = coords.has(el);
  if (isMounted && siblings.has(el))
    siblings.delete(el);
  if (animations.has(el)) {
    (_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.cancel();
  }
  if (preExisting && isMounted) {
    remain(el);
  } else if (preExisting && !isMounted) {
    remove(el);
  } else {
    add(el);
  }
}
function raw(str) {
  return Number(str.replace(/[^0-9.\-]/g, ""));
}
function getCoords(el) {
  const rect = el.getBoundingClientRect();
  return {
    top: rect.top + window.scrollY,
    left: rect.left + window.scrollX,
    width: rect.width,
    height: rect.height
  };
}
function getTransitionSizes(el, oldCoords, newCoords) {
  let widthFrom = oldCoords.width;
  let heightFrom = oldCoords.height;
  let widthTo = newCoords.width;
  let heightTo = newCoords.height;
  const styles = getComputedStyle(el);
  const sizing = styles.getPropertyValue("box-sizing");
  if (sizing === "content-box") {
    const paddingY = raw(styles.paddingTop) + raw(styles.paddingBottom) + raw(styles.borderTopWidth) + raw(styles.borderBottomWidth);
    const paddingX = raw(styles.paddingLeft) + raw(styles.paddingRight) + raw(styles.borderRightWidth) + raw(styles.borderLeftWidth);
    widthFrom -= paddingX;
    widthTo -= paddingX;
    heightFrom -= paddingY;
    heightTo -= paddingY;
  }
  return [widthFrom, widthTo, heightFrom, heightTo].map(Math.round);
}
function getOptions(el) {
  return TGT in el && options.has(el[TGT]) ? options.get(el[TGT]) : { duration: 250, easing: "ease-in-out" };
}
function getTarget(el) {
  if (TGT in el)
    return el[TGT];
  return void 0;
}
function isEnabled(el) {
  const target2 = getTarget(el);
  return target2 ? enabled.has(target2) : false;
}
function forEach(parent, ...callbacks) {
  callbacks.forEach((callback) => callback(parent, options.has(parent)));
  for (let i = 0; i < parent.children.length; i++) {
    const child = parent.children.item(i);
    if (child) {
      callbacks.forEach((callback) => callback(child, options.has(child)));
    }
  }
}
function remain(el) {
  const oldCoords = coords.get(el);
  const newCoords = getCoords(el);
  if (!isEnabled(el))
    return coords.set(el, newCoords);
  let animation;
  if (!oldCoords)
    return;
  const pluginOrOptions = getOptions(el);
  if (typeof pluginOrOptions !== "function") {
    const deltaX = oldCoords.left - newCoords.left;
    const deltaY = oldCoords.top - newCoords.top;
    const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);
    const start = {
      transform: `translate(${deltaX}px, ${deltaY}px)`
    };
    const end = {
      transform: `translate(0, 0)`
    };
    if (widthFrom !== widthTo) {
      start.width = `${widthFrom}px`;
      end.width = `${widthTo}px`;
    }
    if (heightFrom !== heightTo) {
      start.height = `${heightFrom}px`;
      end.height = `${heightTo}px`;
    }
    animation = el.animate([start, end], {
      duration: pluginOrOptions.duration,
      easing: pluginOrOptions.easing
    });
  } else {
    animation = new Animation(pluginOrOptions(el, "remain", oldCoords, newCoords));
    animation.play();
  }
  animations.set(el, animation);
  coords.set(el, newCoords);
  animation.addEventListener("finish", updatePos.bind(null, el));
}
function add(el) {
  const newCoords = getCoords(el);
  coords.set(el, newCoords);
  const pluginOrOptions = getOptions(el);
  if (!isEnabled(el))
    return;
  let animation;
  if (typeof pluginOrOptions !== "function") {
    animation = el.animate([
      { transform: "scale(.98)", opacity: 0 },
      { transform: "scale(0.98)", opacity: 0, offset: 0.5 },
      { transform: "scale(1)", opacity: 1 }
    ], {
      duration: pluginOrOptions.duration * 1.5,
      easing: "ease-in"
    });
  } else {
    animation = new Animation(pluginOrOptions(el, "add", newCoords));
    animation.play();
  }
  animations.set(el, animation);
  animation.addEventListener("finish", updatePos.bind(null, el));
}
function remove(el) {
  var _a;
  if (!siblings.has(el) || !coords.has(el))
    return;
  const [prev, next] = siblings.get(el);
  Object.defineProperty(el, DEL, { value: true });
  if (next && next.parentNode && next.parentNode instanceof Element) {
    next.parentNode.insertBefore(el, next);
  } else if (prev && prev.parentNode) {
    prev.parentNode.appendChild(el);
  } else {
    (_a = getTarget(el)) === null || _a === void 0 ? void 0 : _a.appendChild(el);
  }
  function cleanUp() {
    var _a2;
    el.remove();
    coords.delete(el);
    siblings.delete(el);
    animations.delete(el);
    (_a2 = intersections.get(el)) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
  }
  if (!isEnabled(el))
    return cleanUp();
  const [top, left, width, height] = deletePosition(el);
  const optionsOrPlugin = getOptions(el);
  const oldCoords = coords.get(el);
  let animation;
  Object.assign(el.style, {
    position: "absolute",
    top: `${top}px`,
    left: `${left}px`,
    width: `${width}px`,
    height: `${height}px`,
    margin: 0,
    pointerEvents: "none",
    transformOrigin: "center",
    zIndex: 100
  });
  if (typeof optionsOrPlugin !== "function") {
    animation = el.animate([
      {
        transform: "scale(1)",
        opacity: 1
      },
      {
        transform: "scale(.98)",
        opacity: 0
      }
    ], { duration: optionsOrPlugin.duration, easing: "ease-out" });
  } else {
    animation = new Animation(optionsOrPlugin(el, "remove", oldCoords));
    animation.play();
  }
  animations.set(el, animation);
  animation.addEventListener("finish", cleanUp);
}
function deletePosition(el) {
  const oldCoords = coords.get(el);
  const [width, , height] = getTransitionSizes(el, oldCoords, getCoords(el));
  let offsetParent = el.parentElement;
  while (offsetParent && (getComputedStyle(offsetParent).position === "static" || offsetParent instanceof HTMLBodyElement)) {
    offsetParent = offsetParent.parentElement;
  }
  if (!offsetParent)
    offsetParent = document.body;
  const parentStyles = getComputedStyle(offsetParent);
  const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);
  const top = Math.round(oldCoords.top - parentCoords.top) - raw(parentStyles.borderTopWidth);
  const left = Math.round(oldCoords.left - parentCoords.left) - raw(parentStyles.borderLeftWidth);
  return [top, left, width, height];
}
function autoAnimate(el, config = {}) {
  if (mutations && resize) {
    const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
    const isDisabledDueToReduceMotion = mediaQuery.matches && typeof config !== "function" && !config.disrespectUserMotionPreference;
    if (!isDisabledDueToReduceMotion) {
      enabled.add(el);
      if (getComputedStyle(el).position === "static") {
        Object.assign(el.style, { position: "relative" });
      }
      forEach(el, updatePos, poll, (element) => resize === null || resize === void 0 ? void 0 : resize.observe(element));
      if (typeof config === "function") {
        options.set(el, config);
      } else {
        options.set(el, { duration: 250, easing: "ease-in-out", ...config });
      }
      mutations.observe(el, { childList: true });
      parents.add(el);
    }
  }
  return Object.freeze({
    parent: el,
    enable: () => {
      enabled.add(el);
    },
    disable: () => {
      enabled.delete(el);
    },
    isEnabled: () => enabled.has(el)
  });
}

// node_modules/@formkit/addons/dist/index.mjs
var pendingIds = /* @__PURE__ */ new Map();
var observer = null;
function createObserver() {
  observeIds();
  observer = new MutationObserver(() => {
    observeIds();
    if (!pendingIds.size && observer) {
      observer.disconnect();
      observer = null;
    }
  });
  observer.observe(document, { childList: true, subtree: true });
}
function observeIds() {
  pendingIds.forEach((options2, id) => {
    const outer = document.getElementById(id);
    if (outer) {
      pendingIds.delete(id);
      autoAnimate(outer, options2 || {});
    }
  });
}
function createAutoAnimatePlugin(options2) {
  return (node) => {
    node.on("created", () => {
      var _a;
      if (typeof ((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.schema) === "function") {
        if (typeof window === void 0)
          return;
        const original = node.props.definition.schema;
        node.props.definition.schema = (extensions) => {
          extensions.outer = extend({ attrs: { id: `outer-${node.props.id}` } }, extensions.outer || {});
          const finalSchema = original(extensions);
          const outermostSchema = isConditional(finalSchema[0]) ? Array.isArray(finalSchema[0].else) ? finalSchema[0].else[0] : finalSchema[0].else : finalSchema[0];
          if (outermostSchema && isDOM(outermostSchema) && outermostSchema.attrs && "id" in outermostSchema.attrs) {
            pendingIds.set(String(outermostSchema.attrs.id === "$id" ? node.props.id : outermostSchema.attrs.id), options2 || void 0);
          }
          return finalSchema;
        };
      }
      if (!observer && typeof window !== "undefined")
        createObserver();
    });
  };
}
var badge = createSection("badge", () => ({
  $el: "span",
  attrs: {
    role: "presentation"
  }
}));
var stepActions = createSection("stepActions", () => ({
  $el: "div"
}));
var stepInner = createSection("stepInner", "div");
var stepNext = createSection("stepNext", () => ({
  $el: "div",
  if: "$isLastStep === false",
  children: [
    {
      $cmp: "FormKit",
      bind: "$nextAttrs",
      props: {
        type: "button",
        label: {
          if: "$nextLabel",
          then: "$nextLabel",
          else: "$ui.next.value"
        },
        "data-next": "$isLastStep === false",
        onClick: "$handlers.next"
      }
    }
  ]
}));
var stepOuter = createSection("stepOuter", () => ({
  $el: "div",
  attrs: {
    key: "$id",
    "data-type": "step",
    "data-disabled": "$disabled || undefined",
    "data-complete": "$state.complete || undefined",
    "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
    "data-errors": "$state.errors || undefined",
    "data-submitted": "$state.submitted || undefined",
    id: "$id",
    role: "tabpanel",
    "aria-labelledby": '$node.parent.props.id + "_tab_" + $stepIndex',
    class: "$classes.step",
    hidden: "$isActiveStep === false || undefined"
  }
}), true);
var stepPrevious = createSection("stepPrevious", () => ({
  $el: "div",
  if: "$isFirstStep === false",
  children: [
    {
      $cmp: "FormKit",
      bind: "$previousAttrs",
      props: {
        type: "button",
        label: {
          if: "$previousLabel",
          then: "$previousLabel",
          else: "$ui.prev.value"
        },
        "data-prev": "$isFirstStep === false",
        onClick: "$handlers.previous"
      }
    }
  ]
}));
var steps = createSection("steps", () => ({
  $el: "div"
}));
var stepIcon = (sectionKey, el) => {
  return createSection(`${sectionKey}Icon`, () => {
    const rawIconProp = `_raw${sectionKey.charAt(0).toUpperCase()}${sectionKey.slice(1)}Icon`;
    return {
      if: `$step.${sectionKey}Icon && $step.${rawIconProp}`,
      then: {
        $el: `${el ? el : "span"}`,
        attrs: {
          class: `$classes.${sectionKey}Icon + " formkit-icon"`,
          innerHTML: `$step.${rawIconProp}`,
          role: "presentation",
          onClick: `$handlers.iconClick(${sectionKey})`
        }
      },
      else: {
        if: `$${sectionKey}Icon && $${rawIconProp}`,
        then: {
          $el: `${el ? el : "span"}`,
          attrs: {
            class: `$classes.${sectionKey}Icon + " formkit-icon"`,
            innerHTML: `$${rawIconProp}`,
            role: "presentation",
            onClick: `$handlers.iconClick(${sectionKey})`
          }
        }
      }
    };
  })();
};
var tab = createSection("tab", () => ({
  $el: "button",
  for: ["step", "index", "$steps"],
  attrs: {
    type: "button",
    onClick: "$step.makeActive",
    "data-active": "$step.isActiveStep",
    "data-valid": "$step.isValid",
    "data-visited": "$step.hasBeenVisited",
    role: "tab",
    id: '$id + "_tab_" + $index',
    "aria-selected": "$step.isActiveStep || false",
    "aria-controls": "$step.id",
    tabindex: {
      if: "$step.isActiveStep",
      then: "0",
      else: "-1"
    },
    style: {
      if: "$step.ordered",
      then: "",
      else: "display: none"
    }
  }
}));
var tabLabel = createSection("tabLabel", () => ({
  $el: "span"
}));
var tabs = createSection("tabs", () => ({
  $el: "div",
  attrs: {
    role: "tablist"
  }
}));
var multiStepOuter = createSection("multiStepOuter", () => ({
  $el: "div",
  attrs: {
    key: "$id",
    id: "$id",
    class: "$classes.outer",
    "data-family": "$family || undefined",
    "data-type": "$type",
    "data-multiple": '$attrs.multiple || ($type != "select" && $options != undefined) || undefined',
    "data-disabled": "$disabled || undefined",
    "data-complete": "$state.complete || undefined",
    "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
    "data-errors": "$state.errors || undefined",
    "data-submitted": "$state.submitted || undefined"
  }
}), true);
var multiStep = {
  /**
   * The actual schema of the input, or a function that returns the schema.
   */
  schema: multiStepOuter($extend(wrapper(tabs(tab($if('$tabStyle === "tab" || ($tabStyle === "progress" && $hideProgressLabels === false)', tabLabel("$step.stepName")), $if("($step.totalErrorCount > 0) && $step.showStepErrors", badge("$step.totalErrorCount")), $if("$step.isValid && $step.hasBeenVisited", badge(stepIcon("validStep"))))), steps("$slots.default")), {
    attrs: {
      "data-tab-style": "$tabStyle",
      "data-hide-labels": "$hideProgressLabels"
    }
  })),
  /**
   * The type of node, can be a list, group, or input.
   */
  type: "group",
  /**
   * The family of inputs this one belongs too. For example "text" and "email"
   * are both part of the "text" family. This is primary used for styling.
   */
  family: "multi-step",
  /**
   * An array of extra props to accept for this input.
   */
  props: [
    "allowIncomplete",
    "hideProgressLabels",
    "tabStyle",
    "beforeStepChange",
    "validStepIcon"
  ],
  /**
   * Additional features that should be added to your input
   */
  features: [defaultIcon("validStep", "check")]
};
var step = {
  /**
   * The actual schema of the input, or a function that returns the schema.
   */
  schema: stepOuter(stepInner("$slots.default"), stepActions(stepPrevious(), stepNext())),
  /**
   * The type of node, can be a list, group, or input.
   */
  type: "group",
  /**
   * The family of inputs this one belongs too. For example "text" and "email"
   * are both part of the "text" family. This is primary used for styling.
   */
  family: "",
  /**
   * An array of extra props to accept for this input.
   */
  props: [
    "previousLabel",
    "nextLabel",
    "beforeStepChange",
    "previousAttrs",
    "nextAttrs",
    "validStepIcon"
  ],
  /**
   * Additional features that should be added to your input
   */
  features: [localize("next"), localize("prev")]
};
var isBrowser = typeof window !== "undefined";
var camel2title = (str) => str.replace(/([A-Z])/g, (match) => ` ${match}`).replace(/^./, (match) => match.toUpperCase()).trim();
function orderSteps(steps2) {
  const orderedSteps = steps2.sort((a, b) => {
    const aEl = document.getElementById(a.id);
    const bEl = document.getElementById(b.id);
    if (!aEl || !bEl)
      return 0;
    return aEl.compareDocumentPosition(bEl) === 2 ? 1 : -1;
  });
  steps2.map((step2) => step2.ordered = true);
  return orderedSteps;
}
function setNodePositionProps(steps2) {
  steps2.forEach((step2, index) => {
    step2.isFirstStep = index === 0;
    step2.isLastStep = index === steps2.length - 1;
    step2.stepIndex = index;
    step2.steps = steps2;
  });
}
function showStepErrors(step2) {
  if (!step2.showStepErrors)
    return;
  return parseInt(step2.blockingCount) + parseInt(step2.errorCount) > 0;
}
function isTargetStepAllowed(currentStep, targetStep) {
  var _a, _b, _c;
  const { allowIncomplete } = ((_a = currentStep.node.parent) === null || _a === void 0 ? void 0 : _a.props) || {};
  const parentNode = currentStep.node.parent;
  const currentStepIndex = parentNode === null || parentNode === void 0 ? void 0 : parentNode.props.steps.indexOf(currentStep);
  const targetStepIndex = parentNode === null || parentNode === void 0 ? void 0 : parentNode.props.steps.indexOf(targetStep);
  const beforeStepChange = currentStep.node.props.beforeStepChange || ((_b = currentStep.node.parent) === null || _b === void 0 ? void 0 : _b.props.beforeStepChange);
  if (beforeStepChange && typeof beforeStepChange === "function") {
    const result = beforeStepChange({
      currentStep,
      targetStep,
      delta: targetStepIndex - currentStepIndex
    });
    if (typeof result === "boolean" && !result)
      return false;
  }
  triggerStepValidations(currentStep);
  currentStep.showStepErrors = true;
  if (targetStepIndex < currentStepIndex) {
    return true;
  }
  const delta = targetStepIndex - currentStepIndex;
  for (let i = 0; i < delta; i++) {
    const intermediateStep = parentNode === null || parentNode === void 0 ? void 0 : parentNode.props.steps[currentStepIndex + i];
    const stepIsAllowed = allowIncomplete || ((_c = intermediateStep.state) === null || _c === void 0 ? void 0 : _c.valid);
    if (!stepIsAllowed) {
      return false;
    }
  }
  return true;
}
function setActiveStep(targetStep, e) {
  if (e) {
    e.preventDefault();
  }
  if (targetStep && targetStep.node.name && targetStep.node.parent) {
    const currentStep = targetStep.node.parent.props.steps.find((step2) => {
      var _a;
      return step2.node.name === ((_a = targetStep.node.parent) === null || _a === void 0 ? void 0 : _a.props.activeStep);
    });
    const stepIsAllowed = isTargetStepAllowed(currentStep, targetStep);
    if (stepIsAllowed && targetStep.node.parent.context) {
      targetStep.node.parent.props.activeStep = targetStep.node.name;
    }
  }
}
function incrementStep(delta, currentStep) {
  if (currentStep && currentStep.node.name && currentStep.node.parent) {
    const { steps: steps2, stepIndex } = currentStep;
    const targetStep = steps2[stepIndex + delta];
    const stepIsAllowed = isTargetStepAllowed(currentStep, targetStep);
    if (targetStep && stepIsAllowed) {
      currentStep.node.parent.props.activeStep = targetStep.node.name;
    }
  }
}
function triggerStepValidations(step2) {
  var _a, _b;
  step2.node.walk((n) => {
    n.store.set(createMessage({
      key: "submitted",
      value: true,
      visible: false
    }));
  });
  return ((_a = step2.node.context) === null || _a === void 0 ? void 0 : _a.state.valid) || ((_b = step2.node.parent) === null || _b === void 0 ? void 0 : _b.props.allowIncomplete);
}
function initEvents(node, el) {
  if (!(el instanceof HTMLElement))
    return;
  el.addEventListener("keydown", (event) => {
    var _a;
    if (event.target instanceof HTMLButtonElement) {
      if (event.key === "Tab" && "data-next" in ((_a = event.target) === null || _a === void 0 ? void 0 : _a.attributes) && !event.shiftKey) {
        event.preventDefault();
        const activeStepContext = node.children.find((step2) => step2.name === node.props.activeStep);
        if (activeStepContext && activeStepContext.context) {
          incrementStep(1, activeStepContext.context);
        }
      }
    }
  });
}
function createMultiStepPlugin(options2) {
  const multiStepPlugin = (node) => {
    var _a, _b;
    if (node.props.type === "multi-step") {
      node.addProps(["steps", "activeStep"]);
      node.props.allowIncomplete = typeof node.props.allowIncomplete === "boolean" ? node.props.allowIncomplete : typeof (options2 === null || options2 === void 0 ? void 0 : options2.allowIncomplete) === "boolean" ? options2 === null || options2 === void 0 ? void 0 : options2.allowIncomplete : true;
      node.props.hideProgressLabels = typeof node.props.hideProgressLabels === "boolean" ? node.props.hideProgressLabels : (options2 === null || options2 === void 0 ? void 0 : options2.hideProgressLabels) || false;
      node.props.tabStyle = node.props.tabStyle || (options2 === null || options2 === void 0 ? void 0 : options2.tabStyle) || "tab";
      node.on("created", () => {
        if (!node.context)
          return;
        node.context.handlers.triggerStepValidations = triggerStepValidations;
        node.context.handlers.showStepErrors = showStepErrors;
        whenAvailable(`${node.props.id}`, (el) => {
          initEvents(node, el);
        });
      });
      node.on("prop:activeStep", ({ payload }) => {
        node.children.forEach((child) => {
          child.props.isActiveStep = child.name === payload;
          if (isBrowser && child.name === payload) {
            const el = document.querySelector(`[aria-controls="${child.props.id}"]`);
            if (el instanceof HTMLButtonElement) {
              el.focus();
            }
          }
        });
      });
      node.on("childRemoved", ({ payload: childNode }) => {
        let removedStepIndex = -1;
        node.props.steps = node.props.steps.filter((step2, index) => {
          if (step2.node.name !== childNode.name) {
            return true;
          }
          removedStepIndex = index;
          return false;
        });
        if (node.props.activeStep === childNode.name) {
          const targetIndex = removedStepIndex > 0 ? removedStepIndex - 1 : 0;
          node.props.activeStep = node.props.steps[targetIndex] ? node.props.steps[targetIndex].node.name : "";
        }
        orderSteps(node.props.steps);
        setNodePositionProps(node.props.steps);
      });
    }
    if (node.props.type === "step" && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.props.type) === "multi-step") {
      let updateTotalErrorCount = function(node2) {
        node2.props.totalErrorCount = node2.props.errorCount + node2.props.blockingCount;
      };
      node.addProps([
        "isActiveStep",
        "isFirstStep",
        "isLastStep",
        "stepName",
        "errorCount",
        "blockingCount",
        "totalErrorCount",
        "showStepErrors",
        "isValid",
        "hasBeenVisited",
        "ordered"
      ]);
      node.on("created", () => {
        if (!node.context)
          return;
        if (node.parent && node.parent.context) {
          node.props.stepName = node.props.label || camel2title(node.name);
          node.props.errorCount = 0;
          node.props.blockingCount = 0;
          node.props.isActiveStep = false;
          const parentNode = node.parent;
          parentNode.props.steps = Array.isArray(parentNode.props.steps) ? [...parentNode.props.steps, node.context] : [node.context];
          whenAvailable(`${node.props.id}`, () => {
            parentNode.props.steps = orderSteps(parentNode.props.steps);
            setNodePositionProps(parentNode.props.steps);
            parentNode.props.activeStep = parentNode.props.activeStep ? parentNode.props.activeStep : parentNode.props.steps[0] ? parentNode.props.steps[0].node.name : "";
          });
          if (node.context && parentNode.context) {
            parentNode.context.handlers.setActiveStep = (stepNode) => setActiveStep.bind(null, stepNode);
            node.context.handlers.incrementStep = (delta, stepNode) => incrementStep.bind(null, delta, stepNode);
            node.context.makeActive = () => {
              setActiveStep(node.context);
            };
            node.context.handlers.next = () => incrementStep(1, node.context);
            node.context.handlers.previous = () => incrementStep(-1, node.context);
          }
        }
      });
      node.on("count:errors", ({ payload: count }) => {
        node.props.errorCount = count;
      });
      node.on("count:blocking", ({ payload: count }) => {
        node.props.blockingCount = count;
      });
      node.on("prop:errorCount", () => updateTotalErrorCount(node));
      node.on("prop:blockingCount", () => updateTotalErrorCount(node));
      node.on("prop:totalErrorCount", () => {
        node.props.isValid = node.props.totalErrorCount <= 0;
      });
      node.on("message-added", ({ payload }) => {
        if (payload.key === "submitted") {
          updateTotalErrorCount(node);
          if (node.context) {
            triggerStepValidations(node.context);
            node.props.showStepErrors = true;
          }
        }
      });
      node.on("prop:isActiveStep", () => {
        if (!node.props.hasBeenVisited && node.props.isActiveStep) {
          node.props.hasBeenVisited = true;
        }
      });
    } else if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.props.type) === "multi-step") {
      console.warn('Invalid FormKit input location. <FormKit type="multi-step"> should only have <FormKit type="step"> inputs as immediate children. Failure to wrap child inputs in <FormKit type="step"> can lead to undesired behaviors.');
    }
  };
  multiStepPlugin.library = (node) => {
    switch (node.props.type) {
      case "multi-step":
        return node.define(multiStep);
      case "step":
        const isInvalid = !node.parent || node.parent.props.type !== "multi-step";
        if (isInvalid) {
          console.warn('Invalid use of <FormKit type="step">. <FormKit type="step"> must be an immediate child of a <FormKit type="multi-step"> component.');
        }
        return node.define(step);
    }
  };
  return multiStepPlugin;
}
function createFloatingLabelsPlugin(FloatingLabelsOptions) {
  const floatingLabelsPlugin = (node) => {
    node.addProps(["floatingLabel"]);
    const useFloatingLabels = typeof node.props.floatingLabel === "boolean" ? node.props.floatingLabel : typeof (FloatingLabelsOptions === null || FloatingLabelsOptions === void 0 ? void 0 : FloatingLabelsOptions.useAsDefault) === "boolean" ? FloatingLabelsOptions === null || FloatingLabelsOptions === void 0 ? void 0 : FloatingLabelsOptions.useAsDefault : false;
    if (useFloatingLabels) {
      node.on("created", () => {
        if (!node.props || !node.props.definition)
          return;
        const inputDefinition = clone(node.props.definition);
        if (["text", "dropdown"].includes(node.props.family) || ["datepicker", "textarea"].includes(node.props.type)) {
          const originalSchema = inputDefinition.schema;
          if (typeof originalSchema !== "function")
            return;
          const higherOrderSchema = (extensions) => {
            extensions.outer = {
              attrs: {
                "data-floating-label": "true"
              }
            };
            extensions.label = {
              attrs: {
                "data-has-value": '$_value !== "" && $_value !== undefined'
              }
            };
            const inputSchema = originalSchema(extensions);
            const [labelParentChildren, labelSection] = findSection(inputSchema, "label");
            const [inputParentChildren] = findSection(inputSchema, "input");
            if (labelParentChildren && labelSection && inputParentChildren) {
              labelParentChildren.splice(labelParentChildren.indexOf(labelSection), 1);
              inputParentChildren.push(labelSection);
            }
            return inputSchema;
          };
          inputDefinition.schema = higherOrderSchema;
          node.props.definition = inputDefinition;
        }
      });
    }
  };
  return floatingLabelsPlugin;
}
export {
  createAutoAnimatePlugin,
  createFloatingLabelsPlugin,
  createMultiStepPlugin
};
//# sourceMappingURL=@formkit_addons.js.map
