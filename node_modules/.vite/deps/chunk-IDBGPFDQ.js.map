{
  "version": 3,
  "sources": ["../../@formkit/core/dist/index.mjs", "../../@formkit/inputs/dist/index.mjs"],
  "sourcesContent": ["import { token, has, slugify, cloneAny, init, clone, camel, undefine, eq, kebab, dedupe, parseArgs, getAt, isQuotedString, rmEscapes } from '@formkit/utils';\r\n\r\n/**\r\n * Creates a new dispatcher that allows the addition/removal of middleware\r\n * functions, and the ability to dispatch a payload to all middleware.\r\n *\r\n * @returns FormKitDispatcher\r\n *\r\n * @internal\r\n */\r\nfunction createDispatcher() {\r\n    const middleware = [];\r\n    let currentIndex = 0;\r\n    const use = (dispatchable) => middleware.push(dispatchable);\r\n    const dispatch = (payload) => {\r\n        const current = middleware[currentIndex];\r\n        if (typeof current === 'function') {\r\n            return current(payload, (explicitPayload) => {\r\n                currentIndex++;\r\n                return dispatch(explicitPayload === undefined ? payload : explicitPayload);\r\n            });\r\n        }\r\n        currentIndex = 0;\r\n        return payload;\r\n    };\r\n    use.dispatch = dispatch;\r\n    use.unshift = (dispatchable) => middleware.unshift(dispatchable);\r\n    use.remove = (dispatchable) => {\r\n        const index = middleware.indexOf(dispatchable);\r\n        if (index > -1)\r\n            middleware.splice(index, 1);\r\n    };\r\n    return use;\r\n}\r\n\r\n/**\r\n * Creates a new event emitter, each node uses one of these to allow it to emit\r\n * events to local listeners and tree listeners.\r\n *\r\n * @returns FormKitEventEmitter\r\n *\r\n * @internal\r\n */\r\nfunction createEmitter() {\r\n    const listeners = new Map();\r\n    const receipts = new Map();\r\n    let buffer = undefined;\r\n    const emitter = (node, event) => {\r\n        if (buffer) {\r\n            buffer.set(event.name, [node, event]);\r\n            return;\r\n        }\r\n        if (listeners.has(event.name)) {\r\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n            listeners.get(event.name).forEach((wrapper) => {\r\n                if (event.origin === node || wrapper.modifiers.includes('deep')) {\r\n                    wrapper.listener(event);\r\n                }\r\n            });\r\n        }\r\n        if (event.bubble) {\r\n            node.bubble(event);\r\n        }\r\n    };\r\n    /**\r\n     * Add an event listener\r\n     *\r\n     * @param eventName - The name of the event to listen to\r\n     * @param listener - The callback\r\n     *\r\n     * @returns string\r\n     *\r\n     * @internal\r\n     */\r\n    emitter.on = (eventName, listener) => {\r\n        const [event, ...modifiers] = eventName.split('.');\r\n        const receipt = listener.receipt || token();\r\n        const wrapper = {\r\n            modifiers,\r\n            event,\r\n            listener,\r\n            receipt,\r\n        };\r\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\r\n        listeners.has(event)\r\n            ? listeners.get(event).push(wrapper)\r\n            : listeners.set(event, [wrapper]);\r\n        receipts.has(receipt)\r\n            ? receipts.get(receipt).push(event)\r\n            : receipts.set(receipt, [event]);\r\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\r\n        return receipt;\r\n    };\r\n    /**\r\n     * Remove an event listener\r\n     *\r\n     * @param listenerOrReceipt - Either a receipt or the callback function.\r\n     *\r\n     * @internal\r\n     */\r\n    emitter.off = (receipt) => {\r\n        var _a;\r\n        if (receipts.has(receipt)) {\r\n            (_a = receipts.get(receipt)) === null || _a === void 0 ? void 0 : _a.forEach((event) => {\r\n                const eventListeners = listeners.get(event);\r\n                if (Array.isArray(eventListeners)) {\r\n                    listeners.set(event, eventListeners.filter((wrapper) => wrapper.receipt !== receipt));\r\n                }\r\n            });\r\n            receipts.delete(receipt);\r\n        }\r\n    };\r\n    /**\r\n     * Pause emitting values. Any events emitted while paused will not be emitted\r\n     * but rather \"stored\" — and whichever events are emitted last will be output.\r\n     * For example:\r\n     * pause()\r\n     * emit('foo', 1)\r\n     * emit('foo', 2)\r\n     * emit('bar', 3)\r\n     * emit('bar', 4)\r\n     * play()\r\n     * // would result in\r\n     * emit('foo', 2)\r\n     * emit('bar', 4)\r\n     * Optionally pauses all children as well.\r\n     *\r\n     * @param node - A node to pause all children on.\r\n     *\r\n     * @internal\r\n     */\r\n    emitter.pause = (node) => {\r\n        if (!buffer)\r\n            buffer = new Map();\r\n        if (node) {\r\n            node.walk((child) => child._e.pause());\r\n        }\r\n    };\r\n    /**\r\n     * Release the current event buffer.\r\n     *\r\n     * @param node - A node to unpause all children on.\r\n     *\r\n     * @internal\r\n     */\r\n    emitter.play = (node) => {\r\n        if (!buffer)\r\n            return;\r\n        const events = buffer;\r\n        buffer = undefined;\r\n        events.forEach(([node, event]) => emitter(node, event));\r\n        if (node) {\r\n            node.walk((child) => child._e.play());\r\n        }\r\n    };\r\n    return emitter;\r\n}\r\n/**\r\n * Emit an event from this node.\r\n *\r\n * @param node - The node that is emitting\r\n * @param context - The context of that node\r\n * @param name - The name of the event\r\n * @param payload - The payload to emit\r\n *\r\n * @returns FormKitNode\r\n *\r\n * @internal\r\n */\r\nfunction emit$1(node, context, name, payload, // eslint-disable-line @typescript-eslint/explicit-module-boundary-types,\r\nbubble = true) {\r\n    context._e(node, {\r\n        payload,\r\n        name,\r\n        bubble,\r\n        origin: node,\r\n    });\r\n    return node;\r\n}\r\n/**\r\n * Send an event from the given node up it's ancestor tree.\r\n *\r\n * @param node -\r\n * @param _context -\r\n * @param event -\r\n *\r\n * @internal\r\n */\r\nfunction bubble(node, _context, event) {\r\n    if (isNode(node.parent)) {\r\n        node.parent._e(node.parent, event);\r\n    }\r\n    return node;\r\n}\r\n/**\r\n * Adds an event listener to the node for a specific event. The event name is a\r\n * simple string matching the name of the event to listen to. It can optionally\r\n * include modifiers like eventName.deep\r\n *\r\n * @param node -\r\n * @param context -\r\n * @param name -\r\n * @param listener -\r\n *\r\n * @returns FormKitNode\r\n *\r\n * @internal\r\n */\r\nfunction on(_node, context, name, listener) {\r\n    return context._e.on(name, listener);\r\n}\r\n/**\r\n * Removes an event listener from a node by the returned receipt from .on().\r\n *\r\n * @param node - The node to remote the listener from\r\n * @param context - The context to remove\r\n * @param receipt - The receipt returned by .on()\r\n *\r\n * @returns FormKitNode\r\n *\r\n * @internal\r\n */\r\nfunction off(node, context, receipt) {\r\n    context._e.off(receipt);\r\n    return node;\r\n}\r\n\r\n/**\r\n * FormKit's global error handler.\r\n *\r\n * @public\r\n */\r\nconst errorHandler = createDispatcher();\r\nerrorHandler((error, next) => {\r\n    if (!error.message)\r\n        error.message = String(`E${error.code}`);\r\n    return next(error);\r\n});\r\n/**\r\n * FormKit's global warning handler.\r\n *\r\n * @public\r\n */\r\nconst warningHandler = createDispatcher();\r\nwarningHandler((warning, next) => {\r\n    if (!warning.message)\r\n        warning.message = String(`W${warning.code}`);\r\n    const result = next(warning);\r\n    if (console && typeof console.warn === 'function')\r\n        console.warn(result.message);\r\n    return result;\r\n});\r\n/**\r\n * Globally emits a warning.\r\n *\r\n * @param code - The integer warning code.\r\n * @param data - Usually an object of information to include.\r\n *\r\n * @public\r\n */\r\nfunction warn(code, data = {}) {\r\n    warningHandler.dispatch({ code, data });\r\n}\r\n/**\r\n * Emits an error. Generally should result in an exception.\r\n *\r\n * @param code - The integer error code.\r\n * @param data - Usually an object of information to include.\r\n *\r\n * @public\r\n */\r\nfunction error(code, data = {}) {\r\n    throw Error(errorHandler.dispatch({ code, data }).message);\r\n}\r\n\r\n/**\r\n * Creates a new FormKitMessage object.\r\n *\r\n * @param conf - An object of optional properties of {@link FormKitMessage | FormKitMessage}.\r\n * @param node - A {@link @formkit/node#FormKitNode | FormKitNode}.\r\n *\r\n * @returns A {@link FormKitMessageProps | FormKitMessageProps}.\r\n *\r\n * @public\r\n */\r\nfunction createMessage(conf, node) {\r\n    const m = {\r\n        blocking: false,\r\n        key: token(),\r\n        meta: {},\r\n        type: 'state',\r\n        visible: true,\r\n        ...conf,\r\n    };\r\n    if (node && m.value && m.meta.localize !== false) {\r\n        m.value = node.t(m);\r\n        m.meta.locale = node.config.locale;\r\n    }\r\n    return m;\r\n}\r\n/**\r\n * The available traps on the node's store.\r\n *\r\n * @internal\r\n */\r\nconst storeTraps = {\r\n    apply: applyMessages,\r\n    set: setMessage,\r\n    remove: removeMessage,\r\n    filter: filterMessages,\r\n    reduce: reduceMessages,\r\n    release: releaseBuffer,\r\n    touch: touchMessages,\r\n};\r\n/**\r\n * Creates a new FormKit message store.\r\n *\r\n * @internal\r\n */\r\nfunction createStore(_buffer = false) {\r\n    const messages = {};\r\n    let node;\r\n    let buffer = _buffer;\r\n    let _b = [];\r\n    const _m = new Map();\r\n    let _r = undefined;\r\n    const store = new Proxy(messages, {\r\n        get(...args) {\r\n            const [_target, property] = args;\r\n            if (property === 'buffer')\r\n                return buffer;\r\n            if (property === '_b')\r\n                return _b;\r\n            if (property === '_m')\r\n                return _m;\r\n            if (property === '_r')\r\n                return _r;\r\n            if (has(storeTraps, property)) {\r\n                return storeTraps[property].bind(null, messages, store, node);\r\n            }\r\n            return Reflect.get(...args);\r\n        },\r\n        set(_t, prop, value) {\r\n            if (prop === '_n') {\r\n                node = value;\r\n                if (_r === '__n')\r\n                    releaseMissed(node, store);\r\n                return true;\r\n            }\r\n            else if (prop === '_b') {\r\n                _b = value;\r\n                return true;\r\n            }\r\n            else if (prop === 'buffer') {\r\n                buffer = value;\r\n                return true;\r\n            }\r\n            else if (prop === '_r') {\r\n                _r = value;\r\n                return true;\r\n            }\r\n            error(101, node);\r\n            return false;\r\n        },\r\n    });\r\n    return store;\r\n}\r\n/**\r\n * Adds a new value to a FormKit message bag.\r\n *\r\n * @param messageStore - The message store itself\r\n * @param store - The store interface\r\n * @param node - The node this store belongs to\r\n * @param message - The message object\r\n *\r\n * @internal\r\n */\r\nfunction setMessage(messageStore, store, node, message) {\r\n    if (store.buffer) {\r\n        store._b.push([[message]]);\r\n        return store;\r\n    }\r\n    if (messageStore[message.key] !== message) {\r\n        if (typeof message.value === 'string' && message.meta.localize !== false) {\r\n            // Expose the value to translation\r\n            const previous = message.value;\r\n            message.value = node.t(message);\r\n            if (message.value !== previous) {\r\n                message.meta.locale = node.props.locale;\r\n            }\r\n        }\r\n        const e = `message-${has(messageStore, message.key) ? 'updated' : 'added'}`;\r\n        messageStore[message.key] = Object.freeze(node.hook.message.dispatch(message));\r\n        node.emit(e, message);\r\n    }\r\n    return store;\r\n}\r\n/**\r\n * Run through each message in the store, and ensure it has been translated\r\n * to the proper language. This most frequently happens after a locale change.\r\n *\r\n * @internal\r\n */\r\nfunction touchMessages(messageStore, store) {\r\n    for (const key in messageStore) {\r\n        const message = { ...messageStore[key] };\r\n        store.set(message);\r\n    }\r\n}\r\n/**\r\n * Remove a message from the store.\r\n *\r\n * @param messageStore - The message store\r\n * @param store - The store interface\r\n * @param node - The node this store belongs to\r\n * @param key - The message key\r\n *\r\n * @returns FormKitStore\r\n *\r\n * @internal\r\n */\r\nfunction removeMessage(messageStore, store, node, key) {\r\n    if (has(messageStore, key)) {\r\n        const message = messageStore[key];\r\n        delete messageStore[key];\r\n        node.emit('message-removed', message);\r\n    }\r\n    if (store.buffer === true) {\r\n        store._b = store._b.filter((buffered) => {\r\n            buffered[0] = buffered[0].filter((m) => m.key !== key);\r\n            return buffered[1] || buffered[0].length;\r\n        });\r\n    }\r\n    return store;\r\n}\r\n/**\r\n * Iterates over all messages removing those that are no longer wanted.\r\n *\r\n * @param messageStore - The store itself\r\n * @param store - The store interface\r\n * @param node - The node to filter for\r\n * @param callback - A callback accepting a message and returning a boolean\r\n * @param type - Pre filtered by a given message type\r\n *\r\n * @internal\r\n */\r\nfunction filterMessages(messageStore, store, node, callback, type) {\r\n    for (const key in messageStore) {\r\n        const message = messageStore[key];\r\n        if ((!type || message.type === type) && !callback(message)) {\r\n            removeMessage(messageStore, store, node, key);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Reduce the message store to some other generic value.\r\n *\r\n * @param messageStore - The store itself\r\n * @param _store - Unused but curried — the store interface itself\r\n * @param _node - The node owner of this store\r\n * @param reducer - The callback that performs the reduction\r\n * @param accumulator - The initial value\r\n *\r\n * @returns\r\n *\r\n * @internal\r\n */\r\nfunction reduceMessages(messageStore, _store, _node, reducer, accumulator) {\r\n    for (const key in messageStore) {\r\n        const message = messageStore[key];\r\n        accumulator = reducer(accumulator, message);\r\n    }\r\n    return accumulator;\r\n}\r\n/**\r\n * @param messageStore - The store itself\r\n * @param _store - Unused but curried — the store interface itself\r\n * @param node - The node owner of this store\r\n * @param messages - An array of FormKitMessages to apply to this input, or an object of messages to apply to children.\r\n *\r\n * @internal\r\n */\r\nfunction applyMessages(_messageStore, store, node, messages, clear) {\r\n    if (Array.isArray(messages)) {\r\n        if (store.buffer) {\r\n            store._b.push([messages, clear]);\r\n            return;\r\n        }\r\n        // In this case we are applying messages to this node’s store.\r\n        const applied = new Set(messages.map((message) => {\r\n            store.set(message);\r\n            return message.key;\r\n        }));\r\n        // Remove any messages that were not part of the initial apply:\r\n        if (typeof clear === 'string') {\r\n            store.filter((message) => message.type !== clear || applied.has(message.key));\r\n        }\r\n        else if (typeof clear === 'function') {\r\n            store.filter((message) => !clear(message) || applied.has(message.key));\r\n        }\r\n    }\r\n    else {\r\n        for (const address in messages) {\r\n            const child = node.at(address);\r\n            if (child) {\r\n                child.store.apply(messages[address], clear);\r\n            }\r\n            else {\r\n                missed(node, store, address, messages[address], clear);\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Creates an array of message arrays from strings.\r\n *\r\n * @param node - FormKitNode\r\n * @param errors - Arrays or objects of form errors or input errors\r\n *\r\n * @internal\r\n */\r\nfunction createMessages(node, ...errors) {\r\n    const sourceKey = `${node.name}-set`;\r\n    const make = (error) => createMessage({\r\n        key: slugify(error),\r\n        type: 'error',\r\n        value: error,\r\n        meta: { source: sourceKey, autoClear: true },\r\n    });\r\n    return errors\r\n        .filter((m) => !!m)\r\n        .map((errorSet) => {\r\n        if (typeof errorSet === 'string')\r\n            errorSet = [errorSet];\r\n        if (Array.isArray(errorSet)) {\r\n            return errorSet.map((error) => make(error));\r\n        }\r\n        else {\r\n            const errors = {};\r\n            for (const key in errorSet) {\r\n                if (Array.isArray(errorSet[key])) {\r\n                    errors[key] = errorSet[key].map((error) => make(error));\r\n                }\r\n                else {\r\n                    errors[key] = [make(errorSet[key])];\r\n                }\r\n            }\r\n            return errors;\r\n        }\r\n    });\r\n}\r\n/**\r\n * @param store - The store to apply this missed applications.\r\n * @param address - The address that was missed (a node path that didn't yet exist)\r\n * @param messages - The messages that should have been applied.\r\n * @param clear - The clearing function (if any)\r\n *\r\n * @internal\r\n */\r\nfunction missed(node, store, address, messages, clear) {\r\n    var _a;\r\n    const misses = store._m;\r\n    if (!misses.has(address))\r\n        misses.set(address, []);\r\n    // The created receipt\r\n    if (!store._r)\r\n        store._r = releaseMissed(node, store);\r\n    (_a = misses.get(address)) === null || _a === void 0 ? void 0 : _a.push([messages, clear]);\r\n}\r\n/**\r\n * Releases messages that were applied to a child via parent, but the child did\r\n * not exist. Once the child does exist, the created event for that child will\r\n * bubble to this point, and any stored applications will be applied serially.\r\n *\r\n * @param store - The store object.\r\n *\r\n * @internal\r\n */\r\nfunction releaseMissed(node, store) {\r\n    return node.on('child.deep', ({ payload: child }) => {\r\n        store._m.forEach((misses, address) => {\r\n            if (node.at(address) === child) {\r\n                misses.forEach(([messages, clear]) => {\r\n                    child.store.apply(messages, clear);\r\n                });\r\n                store._m.delete(address);\r\n            }\r\n        });\r\n        // If all the stored misses were applied, remove the listener.\r\n        if (store._m.size === 0 && store._r) {\r\n            node.off(store._r);\r\n            store._r = undefined;\r\n        }\r\n    });\r\n}\r\n/**\r\n * Iterates over all buffered messages and applies them in sequence.\r\n *\r\n * @param messageStore - The store itself\r\n * @param store - The store interface\r\n * @param node - The node to filter for\r\n *\r\n * @internal\r\n */\r\nfunction releaseBuffer(_messageStore, store) {\r\n    store.buffer = false;\r\n    store._b.forEach(([messages, clear]) => store.apply(messages, clear));\r\n    store._b = [];\r\n}\r\n\r\n/**\r\n * Creates a new ledger for use on a single node's context.\r\n *\r\n * @internal\r\n */\r\nfunction createLedger() {\r\n    const ledger = {};\r\n    let n;\r\n    return {\r\n        count: (...args) => createCounter(n, ledger, ...args),\r\n        init(node) {\r\n            n = node;\r\n            node.on('message-added.deep', add(ledger, 1));\r\n            node.on('message-removed.deep', add(ledger, -1));\r\n        },\r\n        merge: (child) => merge(n, ledger, child),\r\n        settled(counterName) {\r\n            return has(ledger, counterName)\r\n                ? ledger[counterName].promise\r\n                : Promise.resolve();\r\n        },\r\n        unmerge: (child) => merge(n, ledger, child, true),\r\n        value(counterName) {\r\n            return has(ledger, counterName) ? ledger[counterName].count : 0;\r\n        },\r\n    };\r\n}\r\n/**\r\n * Creates a new counter object in the counting ledger.\r\n *\r\n * @param node - FormKitNode\r\n * @param ledger - The actual ledger storage object\r\n * @param counterName - The name of the counter, can be arbitrary\r\n * @param condition - The condition function (or string) that filters messages\r\n * @param increment - The increment value\r\n *\r\n * @internal\r\n */\r\nfunction createCounter(node, ledger, counterName, condition, increment = 0) {\r\n    condition = parseCondition(condition || counterName);\r\n    if (!has(ledger, counterName)) {\r\n        const counter = {\r\n            condition,\r\n            count: 0,\r\n            name: counterName,\r\n            node,\r\n            promise: Promise.resolve(),\r\n            resolve: () => { }, // eslint-disable-line @typescript-eslint/no-empty-function\r\n        };\r\n        ledger[counterName] = counter;\r\n        increment = node.store.reduce((sum, m) => sum + counter.condition(m) * 1, increment);\r\n        node.each((child) => {\r\n            child.ledger.count(counter.name, counter.condition);\r\n            increment += child.ledger.value(counter.name);\r\n        });\r\n    }\r\n    return count(ledger[counterName], increment).promise;\r\n}\r\n/**\r\n * We parse the condition to allow flexibility in how counters are specified.\r\n *\r\n * @param condition - The condition that, if true, allows a message to change a counter's value\r\n *\r\n * @internal\r\n */\r\nfunction parseCondition(condition) {\r\n    if (typeof condition === 'function') {\r\n        return condition;\r\n    }\r\n    return (m) => m.type === condition;\r\n}\r\n/**\r\n * Perform a counting action on the a given counter object of the ledger.\r\n *\r\n * @param counter - A counter object\r\n * @param increment - The amount by which we are changing the count value\r\n *\r\n * @internal\r\n */\r\nfunction count(counter, increment) {\r\n    const initial = counter.count;\r\n    const post = counter.count + increment;\r\n    counter.count = post;\r\n    if (initial === 0 && post !== 0) {\r\n        counter.node.emit(`unsettled:${counter.name}`, counter.count, false);\r\n        counter.promise = new Promise((r) => (counter.resolve = r));\r\n    }\r\n    else if (initial !== 0 && post === 0) {\r\n        counter.node.emit(`settled:${counter.name}`, counter.count, false);\r\n        counter.resolve();\r\n    }\r\n    counter.node.emit(`count:${counter.name}`, counter.count, false);\r\n    return counter;\r\n}\r\n/**\r\n * Returns a function to be used as an event listener for message events.\r\n *\r\n * @param ledger - A ledger to operate on\r\n * @param delta - The amount to add or subtract\r\n *\r\n * @internal\r\n */\r\nfunction add(ledger, delta) {\r\n    return (e) => {\r\n        for (const name in ledger) {\r\n            const counter = ledger[name];\r\n            if (counter.condition(e.payload)) {\r\n                count(counter, delta);\r\n            }\r\n        }\r\n    };\r\n}\r\n/**\r\n * Given a child node, add the parent node's counters to the child and then\r\n * rectify the upstream ledger counts. Generally used when attaching a child\r\n * to an already counted tree.\r\n *\r\n * @param parent - The parent that is \"receiving\" the child\r\n * @param ledger - The ledger object\r\n * @param child - The child (can be a subtree) that is being attached\r\n * @param remove - If the merge is removing instead of adding\r\n *\r\n * @internal\r\n */\r\nfunction merge(parent, ledger, child, remove = false) {\r\n    for (const key in ledger) {\r\n        const condition = ledger[key].condition;\r\n        if (!remove)\r\n            child.ledger.count(key, condition);\r\n        const increment = child.ledger.value(key) * (remove ? -1 : 1);\r\n        if (!parent)\r\n            continue;\r\n        do {\r\n            parent.ledger.count(key, condition, increment);\r\n            parent = parent.parent;\r\n        } while (parent);\r\n    }\r\n}\r\n\r\n/**\r\n * A global registry of nodes by their alias or name (if root).\r\n */\r\nconst registry = new Map();\r\nconst reflected = new Map();\r\n/**\r\n * An event emitter for registered/set/unset nodes\r\n */\r\nconst emit = createEmitter();\r\n/**\r\n * Receipts of listeners.\r\n */\r\nconst receipts = [];\r\n/**\r\n * Registers a node to the registry _if_ the node is a root node, _or_ if the\r\n * node has an explicit node.props.alias. If these two things are not true,\r\n * then no node is registered (idempotent).\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction register(node) {\r\n    if (node.props.id) {\r\n        registry.set(node.props.id, node);\r\n        reflected.set(node, node.props.id);\r\n        emit(node, {\r\n            payload: node,\r\n            name: node.props.id,\r\n            bubble: false,\r\n            origin: node,\r\n        });\r\n    }\r\n}\r\n/**\r\n * Deregister a node from the registry.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction deregister(node) {\r\n    if (reflected.has(node)) {\r\n        const id = reflected.get(node); // eslint-disable-line @typescript-eslint/no-non-null-assertion\r\n        reflected.delete(node);\r\n        registry.delete(id);\r\n        emit(node, {\r\n            payload: null,\r\n            name: id,\r\n            bubble: false,\r\n            origin: node,\r\n        });\r\n    }\r\n}\r\n/**\r\n * Get a node by a particular id.\r\n *\r\n * @param id - Get a node by a given id.\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`.\r\n *\r\n * @public\r\n */\r\nfunction getNode$1(id) {\r\n    return registry.get(id);\r\n}\r\n/**\r\n * Resets the entire registry. Deregisters all nodes and removes all listeners.\r\n *\r\n * @public\r\n */\r\nfunction resetRegistry() {\r\n    registry.forEach((node) => {\r\n        deregister(node);\r\n    });\r\n    receipts.forEach((receipt) => emit.off(receipt));\r\n}\r\n/**\r\n * A way of watching changes in the global registry.\r\n *\r\n * @param id - A dot-syntax id where the node is located.\r\n * @param callback - A callback in the format of {@link FormKitEventListener | FormKitEventListener} to notify when the node is set or removed.\r\n *\r\n * @public\r\n */\r\nfunction watchRegistry(id, callback) {\r\n    // register a listener\r\n    receipts.push(emit.on(id, callback));\r\n}\r\n\r\n/**\r\n * Applies a given config change to the node.\r\n *\r\n * @param node - The node to check for config change\r\n * @param prop - Checks if this property exists in the local config or props\r\n * @param value - The value to set\r\n *\r\n * @internal\r\n */\r\nfunction configChange(node, prop, value) {\r\n    // When we return false, node.walk will not continue into that child.\r\n    let usingFallback = true;\r\n    !(prop in node.config._t)\r\n        ? node.emit(`config:${prop}`, value, false)\r\n        : (usingFallback = false);\r\n    if (!(prop in node.props)) {\r\n        node.emit('prop', { prop, value });\r\n        node.emit(`prop:${prop}`, value);\r\n    }\r\n    return usingFallback;\r\n}\r\n/**\r\n * Creates a new instance of a global configuration option. This object is\r\n * essentially just a FormKitOption object, but it can be used as the root for\r\n * FormKitConfig's proxy and retain event \"emitting\".\r\n *\r\n * @param options - An object of optional properties of {@link FormKitConfig | FormKitConfig}.\r\n *\r\n * @returns A {@link FormKitRootConfig | FormKitRootConfig}.\r\n *\r\n * @public\r\n */\r\nfunction createConfig$1(options = {}) {\r\n    const nodes = new Set();\r\n    const target = {\r\n        ...options,\r\n        ...{\r\n            _add: (node) => nodes.add(node),\r\n            _rm: (node) => nodes.delete(node),\r\n        },\r\n    };\r\n    const rootConfig = new Proxy(target, {\r\n        set(t, prop, value, r) {\r\n            if (typeof prop === 'string') {\r\n                nodes.forEach((node) => configChange(node, prop, value));\r\n            }\r\n            return Reflect.set(t, prop, value, r);\r\n        },\r\n    });\r\n    return rootConfig;\r\n}\r\n\r\n/**\r\n * Submits a FormKit form programmatically.\r\n *\r\n * @param id - The id of the form.\r\n *\r\n * @public\r\n */\r\nfunction submitForm(id) {\r\n    const formElement = document.getElementById(id);\r\n    if (formElement instanceof HTMLFormElement) {\r\n        const event = new Event('submit', { cancelable: true, bubbles: true });\r\n        formElement.dispatchEvent(event);\r\n        return;\r\n    }\r\n    warn(151, id);\r\n}\r\n\r\n/**\r\n * Clear all state and error messages.\r\n *\r\n * @internal\r\n */\r\nfunction clearState(node) {\r\n    const clear = (n) => {\r\n        for (const key in n.store) {\r\n            const message = n.store[key];\r\n            if (message.type === 'error' ||\r\n                (message.type === 'ui' && key === 'incomplete')) {\r\n                n.store.remove(key);\r\n            }\r\n            else if (message.type === 'state') {\r\n                n.store.set({ ...message, value: false });\r\n            }\r\n        }\r\n    };\r\n    clear(node);\r\n    node.walk(clear);\r\n}\r\n/**\r\n * Resets an input to its \"initial\" value. If the input is a group or list it\r\n * resets all the children as well.\r\n *\r\n * @param id - The id of an input to reset.\r\n * @param resetTo - A value to reset the node to.\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`.\r\n *\r\n * @public\r\n */\r\nfunction reset(id, resetTo) {\r\n    const node = typeof id === 'string' ? getNode$1(id) : id;\r\n    if (node) {\r\n        const initial = (n) => cloneAny(n.props.initial) ||\r\n            (n.type === 'group' ? {} : n.type === 'list' ? [] : undefined);\r\n        // pause all events in this tree.\r\n        node._e.pause(node);\r\n        // Set it back to basics\r\n        node.input(cloneAny(resetTo) || initial(node), false);\r\n        // Set children back to basics in case they were additive (had their own value for example)\r\n        node.walk((child) => child.input(initial(child), false));\r\n        // Finally we need to lay any values back on top (if it is a group/list) since group values\r\n        // take precedence over child values.\r\n        const finalInit = initial(node);\r\n        node.input(typeof finalInit === 'object'\r\n            ? cloneAny(resetTo) || init(finalInit)\r\n            : finalInit, false);\r\n        // release the events.\r\n        node._e.play(node);\r\n        clearState(node);\r\n        node.emit('reset', node);\r\n        return node;\r\n    }\r\n    warn(152, id);\r\n    return;\r\n}\r\n\r\n/**\r\n * Default configuration options.\r\n */\r\nconst defaultConfig = {\r\n    delimiter: '.',\r\n    delay: 0,\r\n    locale: 'en',\r\n    rootClasses: (key) => ({ [`formkit-${kebab(key)}`]: true }),\r\n};\r\n/**\r\n * If a node’s name is set to useIndex, it replaces the node’s name with the\r\n * index of the node relative to its parent’s children.\r\n *\r\n * @internal\r\n */\r\nconst useIndex = Symbol('index');\r\n/**\r\n * When propagating values up a tree, this value indicates the child should be\r\n * removed.\r\n *\r\n * @internal\r\n */\r\nconst valueRemoved = Symbol('removed');\r\n/**\r\n * When propagating values up a tree, this value indicates the child should be\r\n * moved.\r\n *\r\n * @internal\r\n */\r\nconst valueMoved = Symbol('moved');\r\n/**\r\n * When creating a new node and having its value injected directly at a specific\r\n * location.\r\n *\r\n * @internal\r\n */\r\nconst valueInserted = Symbol('inserted');\r\n/**\r\n * A simple type guard to determine if the context being evaluated is a list\r\n * type.\r\n *\r\n * @param arg - A {@link FormKitContextShape | FormKitContextShape}.\r\n *\r\n * @returns Returns a `boolean`.\r\n *\r\n * @public\r\n */\r\nfunction isList(arg) {\r\n    return arg.type === 'list' && Array.isArray(arg._value);\r\n}\r\n/**\r\n * Determine if a given object is a node.\r\n *\r\n * @example\r\n *\r\n * ```javascript\r\n * import { isNode, createNode } from '@formkit/core'\r\n *\r\n * const input = createNode({\r\n *   type: 'input', // defaults to 'input' if not specified\r\n *   value: 'hello node world',\r\n * })\r\n *\r\n * const obj = {};\r\n *\r\n * isNode(obj)\r\n * // false\r\n *\r\n * isNode(input)\r\n * // true\r\n * ```\r\n *\r\n * @param node - Any value.\r\n *\r\n * @returns Returns a `boolean`.\r\n *\r\n * @public\r\n */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nfunction isNode(node) {\r\n    return node && typeof node === 'object' && node.__FKNode__ === true;\r\n}\r\n/**\r\n * The setter you are trying to access is invalid.\r\n */\r\nconst invalidSetter = (node, _context, property) => {\r\n    error(102, [node, property]);\r\n};\r\nconst traps = {\r\n    _c: trap(getContext, invalidSetter, false),\r\n    add: trap(addChild),\r\n    addProps: trap(addProps),\r\n    address: trap(getAddress, invalidSetter, false),\r\n    at: trap(getNode),\r\n    bubble: trap(bubble),\r\n    clearErrors: trap(clearErrors$1),\r\n    calm: trap(calm),\r\n    config: trap(false),\r\n    define: trap(define),\r\n    disturb: trap(disturb),\r\n    destroy: trap(destroy),\r\n    hydrate: trap(hydrate),\r\n    index: trap(getIndex, setIndex, false),\r\n    input: trap(input),\r\n    each: trap(eachChild),\r\n    emit: trap(emit$1),\r\n    find: trap(find),\r\n    on: trap(on),\r\n    off: trap(off),\r\n    parent: trap(false, setParent),\r\n    plugins: trap(false),\r\n    remove: trap(removeChild),\r\n    root: trap(getRoot, invalidSetter, false),\r\n    reset: trap(resetValue),\r\n    resetConfig: trap(resetConfig),\r\n    setErrors: trap(setErrors$1),\r\n    submit: trap(submit),\r\n    t: trap(text),\r\n    use: trap(use),\r\n    name: trap(getName, false, false),\r\n    walk: trap(walkTree),\r\n};\r\n/**\r\n * These are all the available \"traps\" for a given node. You can think of these\r\n * a little bit like methods, but they are really Proxy interceptors.\r\n */\r\nfunction createTraps() {\r\n    return new Map(Object.entries(traps));\r\n}\r\n/**\r\n * Creates a getter/setter trap and curries the context/node pair\r\n *\r\n * @param getter - The getter function\r\n * @param setter - The setter function\r\n * @param curryGetter - Indicates if the getter should be curried or not\r\n *\r\n * @returns A {@link FormKitTrap | FormKitTrap}\r\n */\r\nfunction trap(getter, setter, curryGetter = true) {\r\n    return {\r\n        get: getter\r\n            ? (node, context) => curryGetter\r\n                ? (...args) => getter(node, context, ...args)\r\n                : getter(node, context)\r\n            : false,\r\n        set: setter !== undefined ? setter : invalidSetter.bind(null),\r\n    };\r\n}\r\n/**\r\n * Create all of the node's hook dispatchers.\r\n */\r\nfunction createHooks() {\r\n    const hooks = new Map();\r\n    return new Proxy(hooks, {\r\n        get(_, property) {\r\n            if (!hooks.has(property)) {\r\n                hooks.set(property, createDispatcher());\r\n            }\r\n            return hooks.get(property);\r\n        },\r\n    });\r\n}\r\n/**\r\n * This is a simple integer counter of every createName() where the name needs\r\n * to be generated.\r\n */\r\nlet nameCount = 0;\r\n/**\r\n * This is a simple integer counter of every default id created.\r\n */\r\nlet idCount = 0;\r\n/**\r\n * Resets the global number of node registrations, useful for deterministic\r\n * node naming.\r\n *\r\n * @public\r\n */\r\nfunction resetCount() {\r\n    nameCount = 0;\r\n    idCount = 0;\r\n}\r\n/**\r\n * Create a name-based dictionary of all children in an array.\r\n *\r\n * @param children - An array of {@link FormKitNode | FormKitNode}.\r\n *\r\n * @returns A dictionary of named {@link FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction names(children) {\r\n    return children.reduce((named, child) => Object.assign(named, { [child.name]: child }), {});\r\n}\r\n/**\r\n * This node is responsible for deterministically generating an id for this\r\n * node. This cannot just be a random id, it _must_ be deterministic to ensure\r\n * re-hydration of the form (like post-SSR) produces the same names/ids.\r\n *\r\n * @param options - A {@link FormKitOptions | FormKitOptions}\r\n *\r\n * @returns `string | symbol`\r\n *\r\n * @internal\r\n */\r\nfunction createName(options) {\r\n    var _a, _b;\r\n    if (((_a = options.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\r\n        return useIndex;\r\n    return options.name || `${((_b = options.props) === null || _b === void 0 ? void 0 : _b.type) || 'input'}_${++nameCount}`;\r\n}\r\n/**\r\n * Creates the initial value for a node based on the options passed in and the\r\n * type of the input.\r\n *\r\n * @param options - A {@link FormKitOptions | FormKitOptions}.\r\n *\r\n * @returns `unknown`\r\n *\r\n * @public\r\n */\r\nfunction createValue(options) {\r\n    if (options.type === 'group') {\r\n        return init(options.value &&\r\n            typeof options.value === 'object' &&\r\n            !Array.isArray(options.value)\r\n            ? options.value\r\n            : {});\r\n    }\r\n    else if (options.type === 'list') {\r\n        return init(Array.isArray(options.value) ? options.value : []);\r\n    }\r\n    return options.value;\r\n}\r\n/**\r\n * Sets the internal value of the node.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n * @param value - A input value to the node\r\n * @param async - If its an async call\r\n *\r\n * @returns `Promise<unknown>`\r\n *\r\n * @internal\r\n */\r\nfunction input(node, context, value, async = true) {\r\n    context._value = validateInput(node, node.hook.input.dispatch(value));\r\n    node.emit('input', context._value);\r\n    if (context.isSettled)\r\n        node.disturb();\r\n    if (async) {\r\n        if (context._tmo)\r\n            clearTimeout(context._tmo);\r\n        context._tmo = setTimeout(commit, node.props.delay, node, context);\r\n    }\r\n    else {\r\n        commit(node, context);\r\n    }\r\n    return context.settled;\r\n}\r\n/**\r\n * Validate that the current input is allowed.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param value - The value that is being validated\r\n *\r\n * @returns `T`\r\n *\r\n * @internal\r\n */\r\nfunction validateInput(node, value) {\r\n    switch (node.type) {\r\n        // Inputs are allowed to have any type\r\n        case 'input':\r\n            break;\r\n        case 'group':\r\n            if (!value || typeof value !== 'object')\r\n                error(107, [node, value]);\r\n            break;\r\n        case 'list':\r\n            if (!Array.isArray(value))\r\n                error(108, [node, value]);\r\n            break;\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Commits the working value to the node graph as the value of this node.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n * @param calm - If it calms the node\r\n * @param hydrate - If it hydrates the node\r\n *\r\n * @internal\r\n */\r\nfunction commit(node, context, calm = true, hydrate = true) {\r\n    context._value = context.value = node.hook.commit.dispatch(context._value);\r\n    if (node.type !== 'input' && hydrate)\r\n        node.hydrate();\r\n    node.emit('commit', context.value);\r\n    if (calm)\r\n        node.calm();\r\n}\r\n/**\r\n * Perform a modification to a single element of a parent aggregate value. This\r\n * is only performed on the pre-committed value (_value), although typically\r\n * the value and _value are both linked in memory.\r\n *\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n *\r\n * @internal\r\n */\r\nfunction partial(context, { name, value, from }) {\r\n    if (Object.isFrozen(context._value))\r\n        return;\r\n    if (isList(context)) {\r\n        const insert = value === valueRemoved\r\n            ? []\r\n            : value === valueMoved && typeof from === 'number'\r\n                ? context._value.splice(from, 1)\r\n                : [value];\r\n        context._value.splice(name, value === valueMoved || from === valueInserted ? 0 : 1, ...insert);\r\n        return;\r\n    }\r\n    // In this case we know for sure we're dealing with a group, TS doesn't\r\n    // know that however, so we use some unpleasant casting here\r\n    if (value !== valueRemoved) {\r\n        context._value[name] = value;\r\n    }\r\n    else {\r\n        delete context._value[name];\r\n    }\r\n}\r\n/**\r\n * Hydrate node and its children\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction hydrate(node, context) {\r\n    const _value = context._value;\r\n    context.children.forEach((child) => {\r\n        if (typeof _value !== 'object')\r\n            return;\r\n        // if (has(context._value as FormKitGroupValue, child.name)) {\r\n        if (child.name in _value) {\r\n            // In this case, the parent has a value to give to the child, so we\r\n            // perform a down-tree synchronous input which will cascade values down\r\n            // and then ultimately back up.\r\n            const childValue = child.type !== 'input' ||\r\n                (_value[child.name] && typeof _value[child.name] === 'object')\r\n                ? init(_value[child.name])\r\n                : _value[child.name];\r\n            child.input(childValue, false);\r\n        }\r\n        else {\r\n            if (node.type !== 'list' || typeof child.name === 'number') {\r\n                // In this case, the parent’s values have no knowledge of the child\r\n                // value — this typically occurs on the commit at the end of addChild()\r\n                // we need to create a value reservation for this node’s name. This is\r\n                // especially important when dealing with lists where index matters.\r\n                partial(context, { name: child.name, value: child.value });\r\n            }\r\n            if (!_value.__init) {\r\n                // In this case, someone has explicitly set the value to an empty object\r\n                // with node.input({}) so we do not define the __init property:\r\n                if (child.type === 'group')\r\n                    child.input({}, false);\r\n                else if (child.type === 'list')\r\n                    child.input([], false);\r\n                else\r\n                    child.input(undefined, false);\r\n            }\r\n        }\r\n    });\r\n    return node;\r\n}\r\n/**\r\n * Disturbs the state of a node from settled to unsettled — creating appropriate\r\n * promises and resolutions.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction disturb(node, context) {\r\n    var _a;\r\n    if (context._d <= 0) {\r\n        context.isSettled = false;\r\n        node.emit('settled', false, false);\r\n        context.settled = new Promise((resolve) => {\r\n            context._resolve = resolve;\r\n        });\r\n        if (node.parent)\r\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.disturb();\r\n    }\r\n    context._d++;\r\n    return node;\r\n}\r\n/**\r\n * Calms the given node's disturbed state by one.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n * @param value - A {@link FormKitChildValue | FormKitChildValue}\r\n *\r\n * @internal\r\n */\r\nfunction calm(node, context, value) {\r\n    var _a;\r\n    if (value !== undefined && node.type !== 'input') {\r\n        partial(context, value);\r\n        // Commit the value up, but do not hydrate back down\r\n        return commit(node, context, true, false);\r\n    }\r\n    if (context._d > 0)\r\n        context._d--;\r\n    if (context._d === 0) {\r\n        context.isSettled = true;\r\n        node.emit('settled', true, false);\r\n        if (node.parent)\r\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.calm({ name: node.name, value: context.value });\r\n        if (context._resolve)\r\n            context._resolve(context.value);\r\n    }\r\n}\r\n/**\r\n * This node is being removed and needs to be cleaned up.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n *\r\n * @internal\r\n */\r\nfunction destroy(node, context) {\r\n    node.emit('destroying', node);\r\n    // flush all messages out\r\n    node.store.filter(() => false);\r\n    if (node.parent) {\r\n        node.parent.emit('childRemoved', node);\r\n        node.parent.remove(node);\r\n    }\r\n    deregister(node);\r\n    context._value = context.value = undefined;\r\n    node.emit('destroyed', node);\r\n}\r\n/**\r\n * Defines the current input type concretely.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n * @param definition - A {@link FormKitTypeDefinition | FormKitTypeDefinition}\r\n *\r\n * @internal\r\n */\r\nfunction define(node, context, definition) {\r\n    // Assign the type\r\n    context.type = definition.type;\r\n    // Assign the definition\r\n    context.props.definition = clone(definition);\r\n    // Ensure the type is seeded with the `__init` value.\r\n    context.value = context._value = createValue({\r\n        type: node.type,\r\n        value: context.value,\r\n    });\r\n    /**\r\n     * If the user has a typename defined, use it here.\r\n     */\r\n    if (definition.forceTypeProp) {\r\n        if (node.props.type)\r\n            node.props.originalType = node.props.type;\r\n        context.props.type = definition.forceTypeProp;\r\n    }\r\n    /**\r\n     * If the input is part of a family of inputs, add that prop.\r\n     */\r\n    if (definition.family) {\r\n        context.props.family = definition.family;\r\n    }\r\n    // Apply any input features before resetting the props.\r\n    if (definition.features) {\r\n        definition.features.forEach((feature) => feature(node));\r\n    }\r\n    // Its possible that input-defined \"props\" have ended up in the context attrs\r\n    // these should be moved back out of the attrs object.\r\n    if (definition.props) {\r\n        node.addProps(definition.props);\r\n    }\r\n    node.emit('defined', definition);\r\n}\r\n/**\r\n * Adds props to a given node by stripping them out of the node.props.attrs and\r\n * then adding them to the nodes.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n * @param props - An array of prop strings (in camelCase!)\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction addProps(node, context, props) {\r\n    var _a;\r\n    if (node.props.attrs) {\r\n        const attrs = { ...node.props.attrs };\r\n        // Temporarily disable prop emits\r\n        node.props._emit = false;\r\n        for (const attr in attrs) {\r\n            const camelName = camel(attr);\r\n            if (props.includes(camelName)) {\r\n                node.props[camelName] = attrs[attr];\r\n                delete attrs[attr];\r\n            }\r\n        }\r\n        const initial = cloneAny(context._value);\r\n        node.props.initial =\r\n            node.type !== 'input' ? init(initial) : initial;\r\n        // Re-enable prop emits\r\n        node.props._emit = true;\r\n        node.props.attrs = attrs;\r\n        if (node.props.definition) {\r\n            node.props.definition.props = [\r\n                ...(((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.props) || []),\r\n                ...props,\r\n            ];\r\n        }\r\n    }\r\n    node.emit('added-props', props);\r\n    return node;\r\n}\r\n/**\r\n * Adds a child to the node.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A parent {@link FormKitContext | FormKitContext}\r\n * @param child - A {@link FormKitNode | FormKitNode}\r\n * @param listIndex - A index number to be added at\r\n *\r\n * @internal\r\n */\r\nfunction addChild(parent, parentContext, child, listIndex) {\r\n    if (parent.type === 'input')\r\n        error(100, parent);\r\n    if (child.parent && child.parent !== parent) {\r\n        child.parent.remove(child);\r\n    }\r\n    // Synchronously set the initial value on the parent\r\n    if (!parentContext.children.includes(child)) {\r\n        if (listIndex !== undefined && parent.type === 'list') {\r\n            // Inject the child:\r\n            parentContext.children.splice(listIndex, 0, child);\r\n            if (Array.isArray(parent.value) &&\r\n                parent.value.length < parentContext.children.length) {\r\n                // When adding an node or value to a list it is absolutely critical to\r\n                // know if, at the moment of injection, the parent’s value or the node\r\n                // children are the source of truth. For example, if a user pushes or\r\n                // splices a new value onto the lists’s array then we want to use that\r\n                // value as the value of the new node, but if a user adds a node to the\r\n                // list then we want the node’s value. In this specific case, we\r\n                // assume (due to length) that a new node was injected into the list, so\r\n                // we want that new node’s value injected into the parent list value.\r\n                parent.disturb().calm({\r\n                    name: listIndex,\r\n                    value: child.value,\r\n                    from: valueInserted,\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            parentContext.children.push(child);\r\n        }\r\n        if (!child.isSettled)\r\n            parent.disturb();\r\n    }\r\n    if (child.parent !== parent) {\r\n        child.parent = parent;\r\n        // In this edge case middleware changed the parent assignment so we need to\r\n        // re-add the child\r\n        if (child.parent !== parent) {\r\n            parent.remove(child);\r\n            child.parent.add(child);\r\n            return parent;\r\n        }\r\n    }\r\n    else {\r\n        // When a parent is properly assigned, we inject the parent's plugins on the\r\n        // child.\r\n        child.use(parent.plugins);\r\n    }\r\n    // Finally we call commit here, which sub-calls hydrate(), hydrate() will\r\n    // resolve any conflict between the parent and child values, and also ensure\r\n    // proper \"placeholders\" are made on the parent.\r\n    commit(parent, parentContext, false);\r\n    parent.ledger.merge(child);\r\n    parent.emit('child', child);\r\n    return parent;\r\n}\r\n/**\r\n * The setter for node.parent = FormKitNode\r\n * @param child - A child {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n * @param _property - A property to be setted\r\n * @param parent - A parent {@link FormKitNode | FormKitNode}\r\n *\r\n * @returns `boolean`\r\n *\r\n * @internal\r\n */\r\nfunction setParent(child, context, _property, parent) {\r\n    if (isNode(parent)) {\r\n        if (child.parent && child.parent !== parent) {\r\n            child.parent.remove(child);\r\n        }\r\n        context.parent = parent;\r\n        child.resetConfig();\r\n        !parent.children.includes(child)\r\n            ? parent.add(child)\r\n            : child.use(parent.plugins);\r\n        return true;\r\n    }\r\n    if (parent === null) {\r\n        context.parent = null;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Removes a child from the node.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n * @param child - A child {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction removeChild(node, context, child) {\r\n    const childIndex = context.children.indexOf(child);\r\n    if (childIndex !== -1) {\r\n        if (child.isSettled)\r\n            node.disturb();\r\n        context.children.splice(childIndex, 1);\r\n        // If an ancestor uses the preserve prop, then we are expected to not remove\r\n        // our values on this node either, see #53\r\n        let preserve = undefine(child.props.preserve);\r\n        let parent = child.parent;\r\n        while (preserve === undefined && parent) {\r\n            preserve = undefine(parent.props.preserve);\r\n            parent = parent.parent;\r\n        }\r\n        if (!preserve) {\r\n            node.calm({\r\n                name: node.type === 'list' ? childIndex : child.name,\r\n                value: valueRemoved,\r\n            });\r\n        }\r\n        else {\r\n            node.calm();\r\n        }\r\n        child.parent = null;\r\n        // Remove the child from the config. Is this weird? Yes. Is it ok? Yes.\r\n        child.config._rmn = child;\r\n    }\r\n    node.ledger.unmerge(child);\r\n    return node;\r\n}\r\n/**\r\n * Iterate over each immediate child and perform a callback.\r\n *\r\n * @param _node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n * @param callback - A {@link FormKitChildCallback | FormKitChildCallback}\r\n *\r\n * @internal\r\n */\r\nfunction eachChild(_node, context, callback) {\r\n    context.children.forEach((child) => callback(child));\r\n}\r\n/**\r\n * Walk all nodes below this one and execute a callback.\r\n *\r\n * @param _node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n * @param callback - A {@link FormKitChildCallback | FormKitChildCallback}\r\n * @param stopIfFalse - Boolean to stop running on children\r\n *\r\n * @internal\r\n */\r\nfunction walkTree(_node, context, callback, stopIfFalse = false) {\r\n    context.children.forEach((child) => {\r\n        if (callback(child) !== false || !stopIfFalse) {\r\n            child.walk(callback, stopIfFalse);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Set the configuration options of the node and it's subtree.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n *\r\n * @internal\r\n */\r\nfunction resetConfig(node, context) {\r\n    const parent = node.parent || undefined;\r\n    context.config = createConfig(node.config._t, parent);\r\n    node.walk((n) => n.resetConfig());\r\n}\r\n/**\r\n * Adds a plugin to the node, its children, and executes it.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n * @param plugin -\r\n * {@link FormKitPlugin | FormKitPlugin}\r\n * {@link FormKitPlugin | FormKitPlugin[]}\r\n * {@link FormKitPlugin | Set<FormKitPlugin>}\r\n * @param run - If it will run on creation\r\n * @param library - If it will run on library creation\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction use(node, context, plugin, run = true, library = true) {\r\n    if (Array.isArray(plugin) || plugin instanceof Set) {\r\n        plugin.forEach((p) => use(node, context, p));\r\n        return node;\r\n    }\r\n    if (!context.plugins.has(plugin)) {\r\n        if (library && typeof plugin.library === 'function')\r\n            plugin.library(node);\r\n        // When plugins return false, they are never added as to the plugins Set\r\n        // meaning they only ever have access to the single node they were added on.\r\n        if (run && plugin(node) !== false) {\r\n            context.plugins.add(plugin);\r\n            node.children.forEach((child) => child.use(plugin));\r\n        }\r\n    }\r\n    return node;\r\n}\r\n/**\r\n * Moves a node in the parent’s children to the given index.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param _context - A {@link FormKitContext | FormKitContext}\r\n * @param _property - A property to add\r\n * @param setIndex - The index to move the node\r\n *\r\n * @internal\r\n */\r\nfunction setIndex(node, _context, _property, setIndex) {\r\n    if (isNode(node.parent)) {\r\n        const children = node.parent.children;\r\n        const index = setIndex >= children.length\r\n            ? children.length - 1\r\n            : setIndex < 0\r\n                ? 0\r\n                : setIndex;\r\n        const oldIndex = children.indexOf(node);\r\n        if (oldIndex === -1)\r\n            return false;\r\n        children.splice(oldIndex, 1);\r\n        children.splice(index, 0, node);\r\n        node.parent.children = children;\r\n        if (node.parent.type === 'list')\r\n            node.parent\r\n                .disturb()\r\n                .calm({ name: index, value: valueMoved, from: oldIndex });\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Retrieves the index of a node from the parent’s children.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction getIndex(node) {\r\n    if (node.parent) {\r\n        const index = [...node.parent.children].indexOf(node);\r\n        // If the index is currently -1 then the node isnt finished booting, so it\r\n        // must be the next node.\r\n        return index === -1 ? node.parent.children.length : index;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Retrieves the context object of a given node. This is intended to be a\r\n * private trap and should absolutely not be used in plugins or user-land code.\r\n *\r\n * @param _node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n *\r\n * @internal\r\n */\r\nfunction getContext(_node, context) {\r\n    return context;\r\n}\r\n/**\r\n * Get the name of the current node, allowing for slight mutations.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n *\r\n * @internal\r\n */\r\nfunction getName(node, context) {\r\n    var _a;\r\n    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\r\n        return node.index;\r\n    return context.name !== useIndex ? context.name : node.index;\r\n}\r\n/**\r\n * Returns the address of the current node.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param context - A {@link FormKitContext | FormKitContext}\r\n *\r\n * @internal\r\n */\r\nfunction getAddress(node, context) {\r\n    return context.parent\r\n        ? context.parent.address.concat([node.name])\r\n        : [node.name];\r\n}\r\n/**\r\n * Fetches a node from the tree by its address.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param _context - A {@link FormKitContext | FormKitContext}\r\n * @param locator - A string or {@link FormKitAddress | FormKitAddress} to find in the tree.\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction getNode(node, _context, locator) {\r\n    const address = typeof locator === 'string' ? locator.split(node.config.delimiter) : locator;\r\n    if (!address.length)\r\n        return undefined;\r\n    const first = address[0];\r\n    let pointer = node.parent;\r\n    if (!pointer) {\r\n        // This address names the root node, remove it to get child name:\r\n        if (String(address[0]) === String(node.name))\r\n            address.shift();\r\n        // All root nodes start at themselves ultimately:\r\n        pointer = node;\r\n    }\r\n    // Any addresses starting with $parent should discard it\r\n    if (first === '$parent')\r\n        address.shift();\r\n    while (pointer && address.length) {\r\n        const name = address.shift();\r\n        switch (name) {\r\n            case '$root':\r\n                pointer = node.root;\r\n                break;\r\n            case '$parent':\r\n                pointer = pointer.parent;\r\n                break;\r\n            case '$self':\r\n                pointer = node;\r\n                break;\r\n            default:\r\n                pointer =\r\n                    pointer.children.find((c) => String(c.name) === String(name)) ||\r\n                        select(pointer, name);\r\n        }\r\n    }\r\n    return pointer || undefined;\r\n}\r\n/**\r\n * Perform selections on a subtree using the address \"selector\" methods.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param selector - A `string | number` to find in the node\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`\r\n *\r\n * @internal\r\n */\r\nfunction select(node, selector) {\r\n    const matches = String(selector).match(/^(find)\\((.*)\\)$/);\r\n    if (matches) {\r\n        const [, action, argStr] = matches;\r\n        const args = argStr.split(',').map((arg) => arg.trim());\r\n        switch (action) {\r\n            case 'find':\r\n                return node.find(args[0], args[1]);\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n/**\r\n * Perform a breadth first search and return the first instance of a node that\r\n * is found in the subtree or undefined.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param _context - A {@link FormKitContext | FormKitContext}\r\n * @param searchTerm - The term we are searching for\r\n * @param searcher - Either a key of {@link FormKitNode | FormKitNode}, or a {@link FormKitSearchFunction | FormKitSearchFunction}\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`\r\n *\r\n * @internal\r\n */\r\nfunction find(node, _context, searchTerm, searcher) {\r\n    return bfs(node, searchTerm, searcher);\r\n}\r\n/**\r\n * Perform a breadth-first search on a node subtree and locate the first\r\n * instance of a match.\r\n *\r\n * @param tree - A {@link FormKitNode | FormKitNode} to start from.\r\n * @param searchValue - A value to be searched.\r\n * @param searchGoal - A goal value.\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode } or `undefined`.\r\n *\r\n * @public\r\n */\r\nfunction bfs(tree, searchValue, searchGoal = 'name') {\r\n    const search = typeof searchGoal === 'string'\r\n        ? (n) => n[searchGoal] == searchValue // non-strict comparison is intentional\r\n        : searchGoal;\r\n    const stack = [tree];\r\n    while (stack.length) {\r\n        const node = stack.shift(); // eslint-disable-line @typescript-eslint/no-non-null-assertion\r\n        if (search(node, searchValue))\r\n            return node;\r\n        stack.push(...node.children);\r\n    }\r\n    return undefined;\r\n}\r\n/**\r\n * Get the root node of the tree.\r\n *\r\n * @param n - A {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction getRoot(n) {\r\n    let node = n;\r\n    while (node.parent) {\r\n        node = node.parent;\r\n    }\r\n    return node;\r\n}\r\n/**\r\n * Creates a new configuration option.\r\n *\r\n * @param target - An object of optional properties of {@link FormKitConfig | FormKitConfig}\r\n * @param parent - A parent {@link FormKitNode | FormKitNode}\r\n *\r\n * @returns {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction createConfig(target = {}, parent) {\r\n    let node = undefined;\r\n    return new Proxy(target, {\r\n        get(...args) {\r\n            const prop = args[1];\r\n            if (prop === '_t')\r\n                return target;\r\n            const localValue = Reflect.get(...args);\r\n            // Check our local values first\r\n            if (localValue !== undefined)\r\n                return localValue;\r\n            // Then check our parent values next\r\n            if (parent) {\r\n                const parentVal = parent.config[prop];\r\n                if (parentVal !== undefined)\r\n                    return parentVal;\r\n            }\r\n            if (target.rootConfig && typeof prop === 'string') {\r\n                const rootValue = target.rootConfig[prop];\r\n                if (rootValue !== undefined)\r\n                    return rootValue;\r\n            }\r\n            // The default delay value should be 20\r\n            if (prop === 'delay' && (node === null || node === void 0 ? void 0 : node.type) === 'input')\r\n                return 20;\r\n            // Finally check the default values\r\n            return defaultConfig[prop];\r\n        },\r\n        set(...args) {\r\n            const prop = args[1];\r\n            const value = args[2];\r\n            if (prop === '_n') {\r\n                node = value;\r\n                if (target.rootConfig)\r\n                    target.rootConfig._add(node);\r\n                return true;\r\n            }\r\n            if (prop === '_rmn') {\r\n                if (target.rootConfig)\r\n                    target.rootConfig._rm(node);\r\n                node = undefined;\r\n                return true;\r\n            }\r\n            if (!eq(target[prop], value, false)) {\r\n                const didSet = Reflect.set(...args);\r\n                if (node) {\r\n                    node.emit(`config:${prop}`, value, false);\r\n                    configChange(node, prop, value);\r\n                    // Walk the node tree and notify of config/prop changes where relevant\r\n                    node.walk((n) => configChange(n, prop, value), true);\r\n                }\r\n                return didSet;\r\n            }\r\n            return true;\r\n        },\r\n    });\r\n}\r\n/**\r\n * Given a string of text, expose it for modification, translation, or full\r\n * replacement.\r\n\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param _context - A {@link FormKitContext | FormKitContext}\r\n * @param key - A {@link FormKitTextFragment | FormKitTextFragment}, or generic string of text\r\n * @param type - A string to represent the text type\r\n *\r\n * @returns `string`\r\n *\r\n * @internal\r\n */\r\nfunction text(node, _context, key, type = 'ui') {\r\n    const fragment = typeof key === 'string' ? { key, value: key, type } : key;\r\n    const value = node.hook.text.dispatch(fragment);\r\n    node.emit('text', value, false);\r\n    return value.value;\r\n}\r\n/**\r\n * Submits the nearest ancestor that is a FormKit \"form\". It determines which\r\n * node is a form by locating an ancestor where node.props.isForm = true.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction submit(node) {\r\n    const name = node.name;\r\n    do {\r\n        if (node.props.isForm === true)\r\n            break;\r\n        if (!node.parent)\r\n            error(106, name);\r\n        node = node.parent;\r\n    } while (node);\r\n    if (node.props.id) {\r\n        submitForm(node.props.id);\r\n    }\r\n}\r\n/**\r\n * Reset to the original value.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param _context - A {@link FormKitContext | FormKitContext}\r\n * @param value - The value to reset to\r\n *\r\n * @internal\r\n */\r\nfunction resetValue(node, _context, value) {\r\n    return reset(node, value);\r\n}\r\n/**\r\n * Sets errors on the node and optionally its children.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param _context - A {@link FormKitContext | FormKitContext}\r\n * @param localErrors - An array of {@link ErrorMessages | ErrorMessages} to set on this node\r\n * @param childErrors - An object of name of {@link ErrorMessages | ErrorMessages} to set on children.\r\n *\r\n * @internal\r\n */\r\nfunction setErrors$1(node, _context, localErrors, childErrors) {\r\n    const sourceKey = `${node.name}-set`;\r\n    const errors = node.hook.setErrors.dispatch({ localErrors, childErrors });\r\n    createMessages(node, errors.localErrors, errors.childErrors).forEach((errors) => {\r\n        node.store.apply(errors, (message) => message.meta.source === sourceKey);\r\n    });\r\n    return node;\r\n}\r\n/**\r\n * Clears errors on the node and optionally its children.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param _context - A {@link FormKitContext | FormKitContext}\r\n * @param clearChildErrors - A boolean to clear children error or not.\r\n * @param sourceKey - The source key string to reset.\r\n *\r\n * @internal\r\n */\r\nfunction clearErrors$1(node, context, clearChildErrors = true, sourceKey) {\r\n    setErrors$1(node, context, []);\r\n    if (clearChildErrors) {\r\n        sourceKey = sourceKey || `${node.name}-set`;\r\n        node.walk((child) => {\r\n            child.store.filter((message) => {\r\n                return !(message.type === 'error' &&\r\n                    message.meta &&\r\n                    message.meta.source === sourceKey);\r\n            });\r\n        });\r\n    }\r\n    return node;\r\n}\r\n/**\r\n * Middleware to assign default prop values as issued by core.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction defaultProps(node) {\r\n    if (!has(node.props, 'id'))\r\n        node.props.id = `input_${idCount++}`;\r\n    return node;\r\n}\r\n/**\r\n * Create props based on initial values\r\n *\r\n * @param initial - An initial value to be transformed\r\n *\r\n * @internal\r\n */\r\nfunction createProps(initial) {\r\n    const props = {\r\n        initial: typeof initial === 'object' ? cloneAny(initial) : initial,\r\n    };\r\n    let node;\r\n    let isEmitting = true;\r\n    return new Proxy(props, {\r\n        get(...args) {\r\n            const [_t, prop] = args;\r\n            if (has(props, prop))\r\n                return Reflect.get(...args);\r\n            if (node && typeof prop === 'string' && node.config[prop] !== undefined)\r\n                return node.config[prop];\r\n            return undefined;\r\n        },\r\n        set(target, property, originalValue, receiver) {\r\n            if (property === '_n') {\r\n                node = originalValue;\r\n                return true;\r\n            }\r\n            if (property === '_emit') {\r\n                isEmitting = originalValue;\r\n                return true;\r\n            }\r\n            const { prop, value } = node.hook.prop.dispatch({\r\n                prop: property,\r\n                value: originalValue,\r\n            });\r\n            // Typescript compiler cannot handle a symbol index, even though js can:\r\n            if (!eq(props[prop], value, false) ||\r\n                typeof value === 'object') {\r\n                const didSet = Reflect.set(target, prop, value, receiver);\r\n                if (isEmitting) {\r\n                    node.emit('prop', { prop, value });\r\n                    if (typeof prop === 'string')\r\n                        node.emit(`prop:${prop}`, value);\r\n                }\r\n                return didSet;\r\n            }\r\n            return true;\r\n        },\r\n    });\r\n}\r\n/**\r\n * A cheap function that iterates over all plugins and stops once node.define\r\n * is called.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param plugins - An array of {@link FormKitPlugin | FormKitPlugin}\r\n *\r\n * @internal\r\n */\r\nfunction findDefinition(node, plugins) {\r\n    // If the definition is already there, force call to define.\r\n    if (node.props.definition)\r\n        return node.define(node.props.definition);\r\n    for (const plugin of plugins) {\r\n        if (node.props.definition)\r\n            return;\r\n        if (typeof plugin.library === 'function') {\r\n            plugin.library(node);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Create a new context object for our a FormKit node, given default information\r\n *\r\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\r\n *\r\n * @returns A {@link FormKitContext | FormKitContext}\r\n *\r\n * @internal\r\n */\r\nfunction createContext(options) {\r\n    const value = createValue(options);\r\n    const config = createConfig(options.config || {}, options.parent);\r\n    return {\r\n        _d: 0,\r\n        _e: createEmitter(),\r\n        _resolve: false,\r\n        _tmo: false,\r\n        _value: value,\r\n        children: dedupe(options.children || []),\r\n        config,\r\n        hook: createHooks(),\r\n        isCreated: false,\r\n        isSettled: true,\r\n        ledger: createLedger(),\r\n        name: createName(options),\r\n        parent: options.parent || null,\r\n        plugins: new Set(),\r\n        props: createProps(value),\r\n        settled: Promise.resolve(value),\r\n        store: createStore(true),\r\n        traps: createTraps(),\r\n        type: options.type || 'input',\r\n        value,\r\n    };\r\n}\r\n/**\r\n * Initialize a node object's internal properties.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}\r\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\r\n *\r\n * @returns A {@link FormKitNode | FormKitNode}\r\n *\r\n * @internal\r\n */\r\nfunction nodeInit(node, options) {\r\n    var _a;\r\n    // Set the internal node on the props, config, ledger and store\r\n    node.ledger.init((node.store._n = node.props._n = node.config._n = node));\r\n    // Apply given in options to the node.\r\n    node.props._emit = false;\r\n    if (options.props)\r\n        Object.assign(node.props, options.props);\r\n    node.props._emit = true;\r\n    // Attempt to find a definition from the pre-existing plugins.\r\n    findDefinition(node, new Set([\r\n        ...(options.plugins || []),\r\n        ...(node.parent ? node.parent.plugins : []),\r\n    ]));\r\n    // Then we apply each plugin's root code, we do this with an explicit loop\r\n    // for that ity-bitty performance bump.\r\n    if (options.plugins) {\r\n        for (const plugin of options.plugins) {\r\n            use(node, node._c, plugin, true, false);\r\n        }\r\n    }\r\n    // Initialize the default props\r\n    defaultProps(node);\r\n    // Apply the parent to each child.\r\n    node.each((child) => node.add(child));\r\n    // If the node has a parent, ensure it's properly nested bi-directionally.\r\n    if (node.parent)\r\n        node.parent.add(node, options.index);\r\n    // Inputs are leafs, and cannot have children\r\n    if (node.type === 'input' && node.children.length)\r\n        error(100, node);\r\n    // Apply the input hook to the initial value.\r\n    input(node, node._c, node._value, false);\r\n    // Release the store buffer\r\n    node.store.release();\r\n    // Register the node globally if someone explicitly gave it an id\r\n    if ((_a = options.props) === null || _a === void 0 ? void 0 : _a.id)\r\n        register(node);\r\n    // Our node is finally ready, emit it to the world\r\n    node.emit('created', node);\r\n    node.isCreated = true;\r\n    return node;\r\n}\r\n/**\r\n * Creates a new instance of a FormKit Node. Nodes are the atomic unit of a FormKit graph.\r\n *\r\n * @example\r\n *\r\n * ```javascript\r\n * import { createNode } from '@formkit/core'\r\n *\r\n * const input = createNode({\r\n *   type: 'input', // defaults to 'input' if not specified\r\n *   value: 'hello node world',\r\n * })\r\n *\r\n * console.log(input.value)\r\n * // 'hello node world'\r\n * ```\r\n *\r\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\r\n *\r\n * @returns A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction createNode(options) {\r\n    const ops = options || {};\r\n    const context = createContext(ops);\r\n    // Note: The typing for the proxy object cannot be fully modeled, thus we are\r\n    // force-typing to a FormKitNode. See:\r\n    // https://github.com/microsoft/TypeScript/issues/28067\r\n    const node = new Proxy(context, {\r\n        get(...args) {\r\n            const [, property] = args;\r\n            if (property === '__FKNode__')\r\n                return true;\r\n            const trap = context.traps.get(property);\r\n            if (trap && trap.get)\r\n                return trap.get(node, context);\r\n            return Reflect.get(...args);\r\n        },\r\n        set(...args) {\r\n            const [, property, value] = args;\r\n            const trap = context.traps.get(property);\r\n            if (trap && trap.set)\r\n                return trap.set(node, context, property, value);\r\n            return Reflect.set(...args);\r\n        },\r\n    });\r\n    return nodeInit(node, ops);\r\n}\r\n\r\n/**\r\n * Type narrow that a node is a DOM node.\r\n *\r\n * @param node - A schema node to check\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction isDOM(node) {\r\n    return typeof node !== 'string' && has(node, '$el');\r\n}\r\n/**\r\n * Type narrow that a node is a DOM node.\r\n *\r\n * @param node - A schema node to check.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction isComponent(node) {\r\n    return typeof node !== 'string' && has(node, '$cmp');\r\n}\r\n/**\r\n * Root declaration.\r\n *\r\n * @param node - An object to check.\r\n */\r\nfunction isConditional(node) {\r\n    if (!node || typeof node === 'string')\r\n        return false;\r\n    return has(node, 'if') && has(node, 'then');\r\n}\r\n/**\r\n * Determines if the node is syntactic sugar or not.\r\n *\r\n * @param node - A schema node to check.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction isSugar(node) {\r\n    return typeof node !== 'string' && '$formkit' in node;\r\n}\r\n/**\r\n * Converts syntactic sugar nodes to standard nodes.\r\n *\r\n * @param node - A node to covert.\r\n *\r\n * @returns A {@link FormKitSchemaNode | FormKitSchemaNode} without the properties of {@link FormKitSchemaFormKit | FormKitSchemaFormKit}.\r\n *\r\n * @public\r\n */\r\nfunction sugar(node) {\r\n    if (typeof node === 'string') {\r\n        return {\r\n            $el: 'text',\r\n            children: node,\r\n        };\r\n    }\r\n    if (isSugar(node)) {\r\n        const { $formkit: type, for: iterator, if: condition, children, bind, ...props } = node;\r\n        return Object.assign({\r\n            $cmp: 'FormKit',\r\n            props: { ...props, type },\r\n        }, condition ? { if: condition } : {}, iterator ? { for: iterator } : {}, children ? { children } : {}, bind ? { bind } : {});\r\n    }\r\n    return node;\r\n}\r\n\r\n/**\r\n * Compiles a logical string like `\"a != z || b == c\"` into a single function.\r\n * The return value is an object with a \"provide\" method that iterates over all\r\n * requirement tokens to use as replacements.\r\n *\r\n * @example\r\n *\r\n * ```typescript\r\n * let name = {\r\n *   value: 'jon'\r\n * }\r\n * const condition = compile(\"$name == 'bob'\").provide((token) => {\r\n *  return () => name.value // must return a function!\r\n * })\r\n *\r\n * condition() // false\r\n * ```\r\n *\r\n * @param expr - A string to compile.\r\n *\r\n * @returns A {@link FormKitCompilerOutput | FormKitCompilerOutput}.\r\n *\r\n * @public\r\n */\r\nfunction compile(expr) {\r\n    /**\r\n     * These tokens are replacements used in evaluating a given condition.\r\n     */\r\n    // const tokens: FormKitTokens = {}\r\n    /**\r\n     * The value of the provide() callback. Used for late binding.\r\n     */\r\n    let provideTokens;\r\n    /**\r\n     * These are token requirements like \"$name.value\" that are need to fulfill\r\n     * a given condition call.\r\n     */\r\n    const requirements = new Set();\r\n    /**\r\n     * Expands the current value if it is a function.\r\n     * @param operand - A left or right hand operand\r\n     * @returns\r\n     */\r\n    const x = function expand(operand, tokens) {\r\n        return typeof operand === 'function' ? operand(tokens) : operand;\r\n    };\r\n    /**\r\n     * Comprehensive list of operators. This list MUST be\r\n     * ordered by the length of the operator characters in descending order.\r\n     */\r\n    const operatorRegistry = [\r\n        {\r\n            '&&': (l, r, t) => x(l, t) && x(r, t),\r\n            '||': (l, r, t) => x(l, t) || x(r, t),\r\n        },\r\n        {\r\n            '===': (l, r, t) => !!(x(l, t) === x(r, t)),\r\n            '!==': (l, r, t) => !!(x(l, t) !== x(r, t)),\r\n            '==': (l, r, t) => !!(x(l, t) == x(r, t)),\r\n            '!=': (l, r, t) => !!(x(l, t) != x(r, t)),\r\n            '>=': (l, r, t) => !!(x(l, t) >= x(r, t)),\r\n            '<=': (l, r, t) => !!(x(l, t) <= x(r, t)),\r\n            '>': (l, r, t) => !!(x(l, t) > x(r, t)),\r\n            '<': (l, r, t) => !!(x(l, t) < x(r, t)),\r\n        },\r\n        {\r\n            '+': (l, r, t) => x(l, t) + x(r, t),\r\n            '-': (l, r, t) => x(l, t) - x(r, t),\r\n        },\r\n        {\r\n            '*': (l, r, t) => x(l, t) * x(r, t),\r\n            '/': (l, r, t) => x(l, t) / x(r, t),\r\n            '%': (l, r, t) => x(l, t) % x(r, t),\r\n        },\r\n    ];\r\n    /**\r\n     * A full list of all operator symbols.\r\n     */\r\n    const operatorSymbols = operatorRegistry.reduce((s, g) => {\r\n        return s.concat(Object.keys(g));\r\n    }, []);\r\n    /**\r\n     * An array of the first character of each operator.\r\n     */\r\n    const operatorChars = new Set(operatorSymbols.map((key) => key.charAt(0)));\r\n    /**\r\n     * Determines if the current character is the start of an operator symbol, if it\r\n     * is, it returns that symbol.\r\n     * @param symbols - An array of symbols that are considered operators\r\n     * @param char - The current character being operated on\r\n     * @param p - The position of the pointer\r\n     * @param expression - The full string expression\r\n     * @returns\r\n     */\r\n    function getOp(symbols, char, p, expression) {\r\n        const candidates = symbols.filter((s) => s.startsWith(char));\r\n        if (!candidates.length)\r\n            return false;\r\n        return candidates.find((symbol) => {\r\n            if (expression.length >= p + symbol.length) {\r\n                const nextChars = expression.substring(p, p + symbol.length);\r\n                if (nextChars === symbol)\r\n                    return symbol;\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n    /**\r\n     * Determines the step number of the right or left hand operator.\r\n     * @param p - The position of the pointer\r\n     * @param expression - The full string expression\r\n     * @param direction - 1 = right, 0 = left\r\n     */\r\n    function getStep(p, expression, direction = 1) {\r\n        let next = direction\r\n            ? expression.substring(p + 1).trim()\r\n            : expression.substring(0, p).trim();\r\n        if (!next.length)\r\n            return -1;\r\n        if (!direction) {\r\n            // left hand direction could include a function name we need to remove\r\n            const reversed = next.split('').reverse();\r\n            const start = reversed.findIndex((char) => operatorChars.has(char));\r\n            next = reversed.slice(start).join('');\r\n        }\r\n        const char = next[0];\r\n        return operatorRegistry.findIndex((operators) => {\r\n            const symbols = Object.keys(operators);\r\n            return !!getOp(symbols, char, 0, next);\r\n        });\r\n    }\r\n    /**\r\n     * Extracts a tail call. For example:\r\n     * ```\r\n     * $foo().bar(baz) + 7\r\n     * ```\r\n     * Would extract \"bar(baz)\" and return p of 15 (after the (baz)).\r\n     *\r\n     * @param p - The position of a closing parenthetical.\r\n     * @param expression - The full expression being parsed.\r\n     */\r\n    function getTail(pos, expression) {\r\n        let tail = '';\r\n        const length = expression.length;\r\n        let depth = 0;\r\n        for (let p = pos; p < length; p++) {\r\n            const char = expression.charAt(p);\r\n            if (char === '(') {\r\n                depth++;\r\n            }\r\n            else if (char === ')') {\r\n                depth--;\r\n            }\r\n            else if (depth === 0 && char === ' ') {\r\n                continue;\r\n            }\r\n            if (depth === 0 && getOp(operatorSymbols, char, p, expression)) {\r\n                return [tail, p - 1];\r\n            }\r\n            else {\r\n                tail += char;\r\n            }\r\n        }\r\n        return [tail, expression.length - 1];\r\n    }\r\n    /**\r\n     * Parse a string expression into a function that returns a boolean. This is\r\n     * the magic behind schema logic like $if.\r\n     * @param expression - A string expression to parse\r\n     * @returns\r\n     */\r\n    function parseLogicals(expression, step = 0) {\r\n        const operators = operatorRegistry[step];\r\n        const length = expression.length;\r\n        const symbols = Object.keys(operators);\r\n        let depth = 0;\r\n        let quote = false;\r\n        let op = null;\r\n        let operand = '';\r\n        let left = null;\r\n        let operation;\r\n        let lastChar = '';\r\n        let char = '';\r\n        let parenthetical = '';\r\n        let parenQuote = '';\r\n        let startP = 0;\r\n        const addTo = (depth, char) => {\r\n            depth ? (parenthetical += char) : (operand += char);\r\n        };\r\n        for (let p = 0; p < length; p++) {\r\n            lastChar = char;\r\n            char = expression.charAt(p);\r\n            if ((char === \"'\" || char === '\"') &&\r\n                lastChar !== '\\\\' &&\r\n                ((depth === 0 && !quote) || (depth && !parenQuote))) {\r\n                if (depth) {\r\n                    parenQuote = char;\r\n                }\r\n                else {\r\n                    quote = char;\r\n                }\r\n                addTo(depth, char);\r\n                continue;\r\n            }\r\n            else if ((quote && (char !== quote || lastChar === '\\\\')) ||\r\n                (parenQuote && (char !== parenQuote || lastChar === '\\\\'))) {\r\n                addTo(depth, char);\r\n                continue;\r\n            }\r\n            else if (quote === char) {\r\n                quote = false;\r\n                addTo(depth, char);\r\n                continue;\r\n            }\r\n            else if (parenQuote === char) {\r\n                parenQuote = false;\r\n                addTo(depth, char);\r\n                continue;\r\n            }\r\n            else if (char === ' ') {\r\n                continue;\r\n            }\r\n            else if (char === '(') {\r\n                if (depth === 0) {\r\n                    startP = p;\r\n                }\r\n                else {\r\n                    parenthetical += char;\r\n                }\r\n                depth++;\r\n            }\r\n            else if (char === ')') {\r\n                depth--;\r\n                if (depth === 0) {\r\n                    // Parenthetical statements cannot be grouped up in the implicit order\r\n                    // of left/right statements based on which step they are on because\r\n                    // they are parsed on every step and then must be applied to the\r\n                    // operator. Example:\r\n                    //\r\n                    // 5 + (3) * 2\r\n                    //\r\n                    // This should yield 11 not 16. This order is normally implicit in the\r\n                    // sequence of operators being parsed, but with parenthesis the parse\r\n                    // happens each time. Instead we need to know if the resulting value\r\n                    // should be applied to the left or the right hand operator. The\r\n                    // general algorithm is:\r\n                    //\r\n                    // 1. Does this paren have an operator on the left or right side\r\n                    // 2. If not, it's unnecessarily wrapped (3 + 2)\r\n                    // 3. If it does, then which order of operation is highest?\r\n                    // 4. Wait for the highest order of operation to bind to an operator.\r\n                    // If the parenthetical has a preceding token like $fn(1 + 2) then we\r\n                    // need to subtract the existing operand length from the start\r\n                    // to determine if this is a left or right operation\r\n                    const fn = typeof operand === 'string' && operand.startsWith('$')\r\n                        ? operand\r\n                        : undefined;\r\n                    const hasTail = fn && expression.charAt(p + 1) === '.';\r\n                    // It's possible the function has a chained tail call:\r\n                    let tail = '';\r\n                    if (hasTail) {\r\n                        [tail, p] = getTail(p + 2, expression);\r\n                    }\r\n                    const lStep = op ? step : getStep(startP, expression, 0);\r\n                    const rStep = getStep(p, expression);\r\n                    if (lStep === -1 && rStep === -1) {\r\n                        // This parenthetical was unnecessarily wrapped at the root, or\r\n                        // these are args of a function call.\r\n                        operand = evaluate(parenthetical, -1, fn, tail);\r\n                    }\r\n                    else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {\r\n                        // has a left hand operator with a higher order of operation\r\n                        left = op.bind(null, evaluate(parenthetical, -1, fn, tail));\r\n                        op = null;\r\n                        operand = '';\r\n                    }\r\n                    else if (rStep > lStep && step === rStep) {\r\n                        // should be applied to the right hand operator when it gets one\r\n                        operand = evaluate(parenthetical, -1, fn, tail);\r\n                    }\r\n                    else {\r\n                        operand += `(${parenthetical})${hasTail ? `.${tail}` : ''}`;\r\n                    }\r\n                    parenthetical = '';\r\n                }\r\n                else {\r\n                    parenthetical += char;\r\n                }\r\n            }\r\n            else if (depth === 0 &&\r\n                (operation = getOp(symbols, char, p, expression))) {\r\n                if (p === 0) {\r\n                    error(103, [operation, expression]);\r\n                }\r\n                // We identified the operator by looking ahead in the string, so we need\r\n                // our position to move past the operator\r\n                p += operation.length - 1;\r\n                if (p === expression.length - 1) {\r\n                    error(104, [operation, expression]);\r\n                }\r\n                if (!op) {\r\n                    // Bind the left hand operand\r\n                    if (left) {\r\n                        // In this case we've already parsed the left hand operator\r\n                        op = operators[operation].bind(null, evaluate(left, step));\r\n                        left = null;\r\n                    }\r\n                    else {\r\n                        op = operators[operation].bind(null, evaluate(operand, step));\r\n                        operand = '';\r\n                    }\r\n                }\r\n                else if (operand) {\r\n                    // Bind the right hand operand, and return the resulting expression as a new left hand operator\r\n                    left = op.bind(null, evaluate(operand, step));\r\n                    op = operators[operation].bind(null, left);\r\n                    operand = '';\r\n                }\r\n                continue;\r\n            }\r\n            else {\r\n                addTo(depth, char);\r\n            }\r\n        }\r\n        if (operand && op) {\r\n            // If we were left with an operand after the loop, and an op, it should\r\n            // be the right hand assignment.\r\n            op = op.bind(null, evaluate(operand, step));\r\n        }\r\n        // If we don't have an op, but we do have a left hand assignment, then that\r\n        // is actually our operator, so just re-assign it to op\r\n        op = !op && left ? left : op;\r\n        if (!op && operand) {\r\n            // If we don't have any op but we do have an operand so there is no boolean\r\n            // logic to perform, but that operand still means something so we need to\r\n            // evaluate it and return it as a function\r\n            op = (v, t) => {\r\n                return typeof v === 'function' ? v(t) : v;\r\n            };\r\n            op = op.bind(null, evaluate(operand, step));\r\n        }\r\n        if (!op && !operand) {\r\n            error(105, expression);\r\n        }\r\n        return op;\r\n    }\r\n    /**\r\n     * Given a string like '$name==bobby' evaluate it to true or false\r\n     * @param operand - A left or right boolean operand — usually conditions\r\n     * @param step - The current order of operation\r\n     * @param fnToken - The token (string) representation of a function being called\r\n     * @returns\r\n     */\r\n    function evaluate(operand, step, fnToken, tail //eslint-disable-line\r\n    ) {\r\n        if (fnToken) {\r\n            const fn = evaluate(fnToken, operatorRegistry.length);\r\n            let userFuncReturn;\r\n            // \"Tail calls\" are dot accessors after a function $foo().value. We need\r\n            // to compile tail calls, and then provide the function result to the\r\n            // exposed tokens.\r\n            let tailCall = tail\r\n                ? compile(`$${tail}`)\r\n                : false;\r\n            if (typeof fn === 'function') {\r\n                const args = parseArgs(String(operand)).map((arg) => evaluate(arg, -1));\r\n                return (tokens) => {\r\n                    const userFunc = fn(tokens);\r\n                    if (typeof userFunc !== 'function') {\r\n                        warn(150, fnToken);\r\n                        return userFunc;\r\n                    }\r\n                    userFuncReturn = userFunc(...args.map((arg) => typeof arg === 'function' ? arg(tokens) : arg));\r\n                    if (tailCall) {\r\n                        tailCall = tailCall.provide((subTokens) => {\r\n                            const rootTokens = provideTokens(subTokens);\r\n                            const t = subTokens.reduce((tokenSet, token) => {\r\n                                const isTail = token === tail || (tail === null || tail === void 0 ? void 0 : tail.startsWith(`${token}(`));\r\n                                if (isTail) {\r\n                                    const value = getAt(userFuncReturn, token);\r\n                                    tokenSet[token] = () => value;\r\n                                }\r\n                                else {\r\n                                    tokenSet[token] = rootTokens[token];\r\n                                }\r\n                                return tokenSet;\r\n                            }, {});\r\n                            return t;\r\n                        });\r\n                    }\r\n                    return tailCall ? tailCall() : userFuncReturn;\r\n                };\r\n            }\r\n        }\r\n        else if (typeof operand === 'string') {\r\n            // the word true or false will never contain further operations\r\n            if (operand === 'true')\r\n                return true;\r\n            if (operand === 'false')\r\n                return false;\r\n            if (operand === 'undefined')\r\n                return undefined;\r\n            // Truly quotes strings cannot contain an operation, return the string\r\n            if (isQuotedString(operand))\r\n                return rmEscapes(operand.substring(1, operand.length - 1));\r\n            // Actual numbers cannot be contain an operation\r\n            if (!isNaN(+operand))\r\n                return Number(operand);\r\n            if (step < operatorRegistry.length - 1) {\r\n                return parseLogicals(operand, step + 1);\r\n            }\r\n            else {\r\n                if (operand.startsWith('$')) {\r\n                    const cleaned = operand.substring(1);\r\n                    requirements.add(cleaned);\r\n                    return function getToken(tokens) {\r\n                        return cleaned in tokens ? tokens[cleaned]() : undefined;\r\n                    };\r\n                }\r\n                // In this case we are dealing with an unquoted string, just treat it\r\n                // as a plain string.\r\n                return operand;\r\n            }\r\n        }\r\n        return operand;\r\n    }\r\n    /**\r\n     * Compile the string.\r\n     */\r\n    const compiled = parseLogicals(expr.startsWith('$:') ? expr.substring(2) : expr);\r\n    /**\r\n     * Convert compiled requirements to an array.\r\n     */\r\n    const reqs = Array.from(requirements);\r\n    /**\r\n     * Provides token values via callback to compiled output.\r\n     * @param callback - A callback that needs to provide all token requirements\r\n     * @returns\r\n     */\r\n    function provide(callback) {\r\n        provideTokens = callback;\r\n        return Object.assign(compiled.bind(null, callback(reqs)), {\r\n            provide,\r\n        });\r\n    }\r\n    return Object.assign(compiled, {\r\n        provide,\r\n    });\r\n}\r\n\r\n/**\r\n * Function that produces a standardized object representation of CSS classes.\r\n *\r\n * @param propertyKey - the section key.\r\n * @param node - A {@link FormKitNode | FormKitNode}.\r\n * @param sectionClassList - A `string | Record<string, boolean>` or a {@link FormKitClasses | FormKitClasses}.\r\n *\r\n * @returns `Record<string, boolean>`\r\n *\r\n * @public\r\n */\r\nfunction createClasses(propertyKey, node, sectionClassList) {\r\n    if (!sectionClassList)\r\n        return {};\r\n    if (typeof sectionClassList === 'string') {\r\n        const classKeys = sectionClassList.split(' ');\r\n        return classKeys.reduce((obj, key) => Object.assign(obj, { [key]: true }), {});\r\n    }\r\n    else if (typeof sectionClassList === 'function') {\r\n        return createClasses(propertyKey, node, sectionClassList(node, propertyKey));\r\n    }\r\n    return sectionClassList;\r\n}\r\n/**\r\n * Combines multiple class lists into a single list.\r\n *\r\n * @param node - A {@link FormKitNode | FormKitNode}.\r\n * @param property - The property key to which the class list will be applied.\r\n * @param args - And array of `Record<string, boolean>` of CSS class list(s).\r\n *\r\n * @returns `string | null`\r\n *\r\n * @public\r\n */\r\nfunction generateClassList(node, property, ...args) {\r\n    const combinedClassList = args.reduce((finalClassList, currentClassList) => {\r\n        if (!currentClassList)\r\n            return handleNegativeClasses(finalClassList);\r\n        const { $reset, ...classList } = currentClassList;\r\n        if ($reset) {\r\n            return handleNegativeClasses(classList);\r\n        }\r\n        return handleNegativeClasses(Object.assign(finalClassList, classList));\r\n    }, {});\r\n    return Object.keys(node.hook.classes.dispatch({ property, classes: combinedClassList })\r\n        .classes)\r\n        .filter((key) => combinedClassList[key])\r\n        .join(' ') || null;\r\n}\r\nfunction handleNegativeClasses(classList) {\r\n    const removalToken = '$remove:';\r\n    let hasNegativeClassValue = false;\r\n    const applicableClasses = Object.keys(classList).filter((className) => {\r\n        if (classList[className] && className.startsWith(removalToken)) {\r\n            hasNegativeClassValue = true;\r\n        }\r\n        return classList[className];\r\n    });\r\n    if (applicableClasses.length > 1 && hasNegativeClassValue) {\r\n        const negativeClasses = applicableClasses.filter(className => className.startsWith(removalToken));\r\n        negativeClasses.map((negativeClass) => {\r\n            const targetClass = negativeClass.substring(removalToken.length);\r\n            classList[targetClass] = false;\r\n            classList[negativeClass] = false;\r\n        });\r\n    }\r\n    return classList;\r\n}\r\n\r\n/**\r\n * Sets errors on a form, group, or input.\r\n *\r\n * @param id - The id of a form.\r\n * @param localErrors - The errors to set on the form or the form’s inputs in\r\n * the format of {@link ErrorMessages | ErrorMessages}.\r\n * @param childErrors - (optional) The errors to set on the form or the form’s\r\n * inputs in the format of {@link ErrorMessages | ErrorMessages}.\r\n *\r\n * @public\r\n */\r\nfunction setErrors(id, localErrors, childErrors) {\r\n    const node = getNode$1(id);\r\n    if (node) {\r\n        node.setErrors(localErrors, childErrors);\r\n    }\r\n    else {\r\n        warn(651, id);\r\n    }\r\n}\r\n/**\r\n * Clears errors on the node and optionally its children.\r\n *\r\n * @param id - The id of the node you want to clear errors for.\r\n * @param clearChildren - Determines if the children of this node should have\r\n * their errors cleared.\r\n *\r\n * @public\r\n */\r\nfunction clearErrors(id, clearChildren = true) {\r\n    const node = getNode$1(id);\r\n    if (node) {\r\n        node.clearErrors(clearChildren);\r\n    }\r\n    else {\r\n        warn(652, id);\r\n    }\r\n}\r\n\r\n/**\r\n * The official FormKit core library. This package is responsible for most of FormKit’s internal functionality.\r\n * You can read documentation specifically on how it works at formkit.com.\r\n *\r\n * You can add this package by using `npm install @formkit/core` or `yarn add @formkit/core`.\r\n *\r\n * @packageDocumentation\r\n */\r\n/**\r\n * The current version of FormKit at the time the package is published. Is replaced\r\n * as part of the publishing script.\r\n *\r\n * @internal\r\n */\r\nconst FORMKIT_VERSION = '0.16.5';\r\n\r\nexport { FORMKIT_VERSION, bfs, clearErrors, compile, createClasses, createConfig$1 as createConfig, createMessage, createNode, createValue, deregister, error, errorHandler, generateClassList, getNode$1 as getNode, isComponent, isConditional, isDOM, isList, isNode, isSugar, names, register, reset, resetCount, resetRegistry, setErrors, submitForm, sugar, use, useIndex, valueInserted, valueMoved, valueRemoved, warn, warningHandler, watchRegistry };\r\n", "import { extend, camel, has, isPojo, eq, slugify, undefine, clone, token, isObject } from '@formkit/utils';\r\nimport { createMessage, warn, isConditional, isComponent, isDOM } from '@formkit/core';\r\n\r\n/**\r\n * Creates a plugin based on a list of {@link @formkit/core#FormKitLibrary | FormKitLibrary}.\r\n *\r\n * @param libraries - One or many {@link @formkit/core#FormKitLibrary | FormKitLibrary}.\r\n *\r\n * @returns {@link @formkit/core#FormKitPlugin | FormKitPlugin}\r\n *\r\n * @public\r\n */\r\nfunction createLibraryPlugin(...libraries) {\r\n    /**\r\n     * Merge all provided library items.\r\n     */\r\n    const library = libraries.reduce((merged, lib) => extend(merged, lib), {});\r\n    /* eslint-disable-next-line @typescript-eslint/no-empty-function */\r\n    const plugin = () => { };\r\n    /**\r\n     * Enables the hook that exposes all library inputs.\r\n     * @param node - The primary plugin\r\n     */\r\n    plugin.library = function (node) {\r\n        const type = camel(node.props.type);\r\n        if (has(library, type)) {\r\n            node.define(library[type]);\r\n        }\r\n    };\r\n    return plugin;\r\n}\r\n\r\n/**\r\n * A function to normalize an array of objects, array of strings, or object of\r\n * key-values to use an array of objects with value and label properties.\r\n *\r\n * @param options - An un-normalized {@link FormKitOptionsProp | FormKitOptionsProp}.\r\n *\r\n * @returns A list of {@link FormKitOptionsList | FormKitOptionsList}.\r\n *\r\n * @public\r\n */\r\nfunction normalizeOptions(options) {\r\n    let i = 1;\r\n    if (Array.isArray(options)) {\r\n        return options.map((option) => {\r\n            if (typeof option === 'string' || typeof option === 'number') {\r\n                return {\r\n                    label: String(option),\r\n                    value: String(option),\r\n                };\r\n            }\r\n            if (typeof option == 'object') {\r\n                if ('value' in option && typeof option.value !== 'string') {\r\n                    Object.assign(option, {\r\n                        value: `__mask_${i++}`,\r\n                        __original: option.value,\r\n                    });\r\n                }\r\n            }\r\n            return option;\r\n        });\r\n    }\r\n    return Object.keys(options).map((value) => {\r\n        return {\r\n            label: options[value],\r\n            value,\r\n        };\r\n    });\r\n}\r\n/**\r\n * Given an {@link FormKitOptionsList | FormKitOptionsList}, find the real value in the options.\r\n *\r\n * @param options - The {@link FormKitOptionsList | FormKitOptionsList} to check for a given value\r\n * @param value - The value to return\r\n *\r\n * @returns `unknown`\r\n *\r\n * @public\r\n */\r\nfunction optionValue(options, value) {\r\n    if (Array.isArray(options)) {\r\n        for (const option of options) {\r\n            if (value == option.value) {\r\n                return '__original' in option ? option.__original : option.value;\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Determines if the value should be selected.\r\n *\r\n * @param valueA - Any type of value\r\n * @param valueB - Any type of value\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction shouldSelect(valueA, valueB) {\r\n    if ((valueA === null && valueB === undefined) ||\r\n        (valueA === undefined && valueB === null))\r\n        return false;\r\n    if (valueA == valueB)\r\n        return true;\r\n    if (isPojo(valueA) && isPojo(valueB))\r\n        return eq(valueA, valueB);\r\n    return false;\r\n}\r\n/**\r\n * A feature that converts the options prop to usable values, to be used by a\r\n * feature or a plugin.\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction options(node) {\r\n    node.hook.prop((prop, next) => {\r\n        if (prop.prop === 'options') {\r\n            if (typeof prop.value === 'function') {\r\n                node.props.optionsLoader = prop.value;\r\n                prop.value = [];\r\n            }\r\n            else {\r\n                prop.value = normalizeOptions(prop.value);\r\n            }\r\n        }\r\n        return next(prop);\r\n    });\r\n}\r\n\r\n/**\r\n * Outer section where most data attributes are assigned.\r\n *\r\n * @public\r\n */\r\nconst outer = createSection('outer', () => ({\r\n    $el: 'div',\r\n    attrs: {\r\n        key: '$id',\r\n        'data-family': '$family || undefined',\r\n        'data-type': '$type',\r\n        'data-multiple': '$attrs.multiple || ($type != \"select\" && $options != undefined) || undefined',\r\n        'data-disabled': '$disabled || undefined',\r\n        'data-complete': '$state.complete || undefined',\r\n        'data-invalid': '$state.valid === false && $state.validationVisible || undefined',\r\n        'data-errors': '$state.errors || undefined',\r\n        'data-submitted': '$state.submitted || undefined',\r\n        'data-prefix-icon': '$_rawPrefixIcon !== undefined || undefined',\r\n        'data-suffix-icon': '$_rawSuffixIcon !== undefined || undefined',\r\n        'data-prefix-icon-click': '$onPrefixIconClick !== undefined || undefined',\r\n        'data-suffix-icon-click': '$onSuffixIconClick !== undefined || undefined',\r\n    },\r\n}), true);\r\n\r\n/**\r\n * Inner section\r\n *\r\n * @public\r\n */\r\nconst inner = createSection('inner', 'div');\r\n\r\n/**\r\n * Wrapper input section\r\n *\r\n * @public\r\n */\r\nconst wrapper = createSection('wrapper', 'div');\r\n\r\n/**\r\n * Label section with label element\r\n *\r\n * @public\r\n */\r\nconst label = createSection('label', () => ({\r\n    $el: 'label',\r\n    if: '$label',\r\n    attrs: {\r\n        for: '$id',\r\n    },\r\n}));\r\n\r\n/**\r\n * Messages section where all messages will be displayed.\r\n *\r\n * @public\r\n */\r\nconst messages = createSection('messages', () => ({\r\n    $el: 'ul',\r\n    if: '$defaultMessagePlacement && $fns.length($messages)',\r\n}));\r\n\r\n/**\r\n * Message section, shows a group of messages.\r\n *\r\n * @public\r\n */\r\nconst message = createSection('message', () => ({\r\n    $el: 'li',\r\n    for: ['message', '$messages'],\r\n    attrs: {\r\n        key: '$message.key',\r\n        id: `$id + '-' + $message.key`,\r\n        'data-message-type': '$message.type',\r\n    },\r\n}));\r\n\r\n/**\r\n * Prefix section\r\n *\r\n * @public\r\n */\r\nconst prefix = createSection('prefix', null);\r\n\r\n/**\r\n * Suffix section\r\n *\r\n * @public\r\n */\r\nconst suffix = createSection('suffix', null);\r\n\r\n/**\r\n * Help section that shows help text\r\n *\r\n * @public\r\n */\r\nconst help = createSection('help', () => ({\r\n    $el: 'div',\r\n    if: '$help',\r\n    attrs: {\r\n        id: '$: \"help-\" + $id',\r\n    },\r\n}));\r\n\r\n/**\r\n * Fieldset section, used to describe help\r\n *\r\n * @public\r\n */\r\nconst fieldset = createSection('fieldset', () => ({\r\n    $el: 'fieldset',\r\n    attrs: {\r\n        id: '$id',\r\n        'aria-describedby': {\r\n            if: '$help',\r\n            then: '$: \"help-\" + $id',\r\n            else: undefined,\r\n        },\r\n    },\r\n}));\r\n\r\n/**\r\n * Decorator section\r\n *\r\n * @public\r\n */\r\nconst decorator = createSection('decorator', () => ({\r\n    $el: 'span',\r\n    attrs: {\r\n        'aria-hidden': 'true',\r\n    },\r\n}));\r\n\r\n/**\r\n * Box section used for grouping options\r\n *\r\n * @public\r\n */\r\nconst box = createSection('input', () => ({\r\n    $el: 'input',\r\n    bind: '$attrs',\r\n    attrs: {\r\n        type: '$type',\r\n        name: '$node.props.altName || $node.name',\r\n        disabled: '$option.attrs.disabled || $disabled',\r\n        onInput: '$handlers.toggleChecked',\r\n        checked: '$fns.eq($_value, $onValue)',\r\n        onBlur: '$handlers.blur',\r\n        value: '$: true',\r\n        id: '$id',\r\n        'aria-describedby': {\r\n            if: '$options.length',\r\n            then: {\r\n                if: '$option.help',\r\n                then: '$: \"help-\" + $option.attrs.id',\r\n                else: undefined,\r\n            },\r\n            else: {\r\n                if: '$help',\r\n                then: '$: \"help-\" + $id',\r\n                else: undefined,\r\n            },\r\n        },\r\n    },\r\n}));\r\n\r\n/**\r\n * Legend section, used instead of label when its grouping fields.\r\n *\r\n * @public\r\n */\r\nconst legend = createSection('legend', () => ({\r\n    $el: 'legend',\r\n    if: '$label',\r\n}));\r\n\r\n/**\r\n * Option section used to show an option\r\n *\r\n * @public\r\n */\r\nconst boxOption = createSection('option', () => ({\r\n    $el: 'li',\r\n    for: ['option', '$options'],\r\n    attrs: {\r\n        'data-disabled': '$option.attrs.disabled || $disabled',\r\n    },\r\n}));\r\n\r\n/**\r\n * Options section used to wrap all option sections in a list\r\n *\r\n * @public\r\n */\r\nconst boxOptions = createSection('options', 'ul');\r\n\r\n/**\r\n * Wrapper section for options\r\n *\r\n * @public\r\n */\r\nconst boxWrapper = createSection('wrapper', () => ({\r\n    $el: 'label',\r\n    attrs: {\r\n        'data-disabled': {\r\n            if: '$options.length',\r\n            then: undefined,\r\n            else: '$disabled || undefined',\r\n        },\r\n        'data-checked': {\r\n            if: '$options == undefined',\r\n            then: '$fns.eq($_value, $onValue) || undefined',\r\n            else: '$fns.isChecked($option.value) || undefined',\r\n        },\r\n    },\r\n}));\r\n\r\n/**\r\n * Option help section\r\n *\r\n * @public\r\n */\r\nconst boxHelp = createSection('optionHelp', () => ({\r\n    $el: 'div',\r\n    if: '$option.help',\r\n    attrs: {\r\n        id: '$: \"help-\" + $option.attrs.id',\r\n    },\r\n}));\r\n\r\n/**\r\n * Label section for options\r\n *\r\n * @public\r\n */\r\nconst boxLabel = createSection('label', 'span');\r\n\r\n/**\r\n * Input section for a button\r\n *\r\n * @public\r\n */\r\nconst buttonInput = createSection('input', () => ({\r\n    $el: 'button',\r\n    bind: '$attrs',\r\n    attrs: {\r\n        type: '$type',\r\n        disabled: '$disabled',\r\n        name: '$node.name',\r\n        id: '$id',\r\n    },\r\n}));\r\n\r\n/**\r\n * Default section for a button\r\n *\r\n * @public\r\n */\r\nconst buttonLabel = createSection('default', null);\r\n\r\n/**\r\n * Input section for a file input\r\n *\r\n * @public\r\n */\r\nconst fileInput = createSection('input', () => ({\r\n    $el: 'input',\r\n    bind: '$attrs',\r\n    attrs: {\r\n        type: 'file',\r\n        disabled: '$disabled',\r\n        name: '$node.name',\r\n        onChange: '$handlers.files',\r\n        onBlur: '$handlers.blur',\r\n        id: '$id',\r\n        'aria-describedby': '$describedBy',\r\n    },\r\n}));\r\n\r\n/**\r\n * File item section for showing a file name\r\n *\r\n * @public\r\n */\r\nconst fileItem = createSection('fileItem', () => ({\r\n    $el: 'li',\r\n    for: ['file', '$value'],\r\n}));\r\n\r\n/**\r\n * File list section to show all file names\r\n *\r\n * @public\r\n */\r\nconst fileList = createSection('fileList', () => ({\r\n    $el: 'ul',\r\n    if: '$value.length',\r\n    attrs: {\r\n        'data-has-multiple': {\r\n            if: '$value.length > 1',\r\n            then: 'true',\r\n        },\r\n    },\r\n}));\r\n\r\n/**\r\n * File name section to show the file name\r\n *\r\n * @public\r\n */\r\nconst fileName = createSection('fileName', () => ({\r\n    $el: 'span',\r\n    attrs: {\r\n        class: '$classes.fileName',\r\n    },\r\n}));\r\n\r\n/**\r\n * File remove section to show a remove button for files\r\n *\r\n * @public\r\n */\r\nconst fileRemove = createSection('fileRemove', () => ({\r\n    $el: 'button',\r\n    attrs: {\r\n        onClick: '$handlers.resetFiles',\r\n    },\r\n}));\r\n\r\n/**\r\n * No file section that shows when there is no files\r\n *\r\n * @public\r\n */\r\nconst noFiles = createSection('noFiles', () => ({\r\n    $el: 'span',\r\n    if: '$value.length == 0',\r\n}));\r\n\r\n/**\r\n * Form section\r\n *\r\n * @public\r\n */\r\nconst formInput = createSection('form', () => ({\r\n    $el: 'form',\r\n    bind: '$attrs',\r\n    attrs: {\r\n        id: '$id',\r\n        name: '$node.name',\r\n        onSubmit: '$handlers.submit',\r\n        'data-loading': '$state.loading || undefined',\r\n    },\r\n}), true);\r\n\r\n/**\r\n * Actions section that shows the action buttons\r\n *\r\n * @public\r\n */\r\nconst actions = createSection('actions', () => ({\r\n    $el: 'div',\r\n    if: '$actions',\r\n}));\r\n\r\n/**\r\n * Submit section that displays a submit button from a form\r\n *\r\n * @public\r\n */\r\nconst submitInput = createSection('submit', () => ({\r\n    $cmp: 'FormKit',\r\n    bind: '$submitAttrs',\r\n    props: {\r\n        type: 'submit',\r\n        disabled: '$disabled',\r\n        label: '$submitLabel',\r\n    },\r\n}));\r\n\r\n/**\r\n * Input section\r\n *\r\n * @public\r\n */\r\nconst textInput = createSection('input', () => ({\r\n    $el: 'input',\r\n    bind: '$attrs',\r\n    attrs: {\r\n        type: '$type',\r\n        disabled: '$disabled',\r\n        name: '$node.name',\r\n        onInput: '$handlers.DOMInput',\r\n        onBlur: '$handlers.blur',\r\n        value: '$_value',\r\n        id: '$id',\r\n        'aria-describedby': '$describedBy',\r\n    },\r\n}));\r\n\r\n/**\r\n * A simple fragment section\r\n *\r\n * @public\r\n */\r\nconst fragment = createSection('wrapper', null, true);\r\n\r\n/**\r\n * Input section used by selects\r\n *\r\n * @public\r\n */\r\nconst selectInput$1 = createSection('input', () => ({\r\n    $el: 'select',\r\n    bind: '$attrs',\r\n    attrs: {\r\n        id: '$id',\r\n        'data-placeholder': '$fns.showPlaceholder($_value, $placeholder)',\r\n        disabled: '$disabled',\r\n        class: '$classes.input',\r\n        name: '$node.name',\r\n        onChange: '$handlers.onChange',\r\n        onInput: '$handlers.selectInput',\r\n        onBlur: '$handlers.blur',\r\n        'aria-describedby': '$describedBy',\r\n    },\r\n}));\r\n\r\n/**\r\n * Option section used to show options\r\n *\r\n * @public\r\n */\r\nconst option = createSection('option', () => ({\r\n    $el: 'option',\r\n    for: ['option', '$options'],\r\n    bind: '$option.attrs',\r\n    attrs: {\r\n        class: '$classes.option',\r\n        value: '$option.value',\r\n        selected: '$fns.isSelected($option)',\r\n    },\r\n}));\r\n\r\n/**\r\n * Options slot section that displays options when used with slots\r\n *\r\n * @public\r\n */\r\nconst optionSlot = () => ({\r\n    $el: null,\r\n    if: '$options.length',\r\n    for: ['option', '$options'],\r\n    children: '$slots.option',\r\n});\r\n\r\n/**\r\n * Input section used by textarea inputs\r\n *\r\n * @public\r\n */\r\nconst textareaInput = createSection('input', () => ({\r\n    $el: 'textarea',\r\n    bind: '$attrs',\r\n    attrs: {\r\n        disabled: '$disabled',\r\n        name: '$node.name',\r\n        onInput: '$handlers.DOMInput',\r\n        onBlur: '$handlers.blur',\r\n        value: '$_value',\r\n        id: '$id',\r\n        'aria-describedby': '$describedBy',\r\n    },\r\n    children: '$initialValue',\r\n}));\r\n\r\n/**\r\n * Icon section used by all icons\r\n *\r\n * @public\r\n */\r\nconst icon = (sectionKey, el) => {\r\n    return createSection(`${sectionKey}Icon`, () => {\r\n        const rawIconProp = `_raw${sectionKey\r\n            .charAt(0)\r\n            .toUpperCase()}${sectionKey.slice(1)}Icon`;\r\n        return {\r\n            if: `$${sectionKey}Icon && $${rawIconProp}`,\r\n            $el: `${el ? el : 'span'}`,\r\n            attrs: {\r\n                class: `$classes.${sectionKey}Icon + \" formkit-icon\"`,\r\n                innerHTML: `$${rawIconProp}`,\r\n                onClick: `$handlers.iconClick(${sectionKey})`,\r\n                for: {\r\n                    if: `${el === 'label'}`,\r\n                    then: '$id',\r\n                },\r\n            },\r\n        };\r\n    })();\r\n};\r\n\r\n/**\r\n * A feature that normalizes box types (checkboxes, radios).\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n *\r\n * @returns A {@link @formkit/node#FormKitMiddleware | FormKitMiddleware}.\r\n *\r\n * @public\r\n */\r\nfunction normalizeBoxes(node) {\r\n    return function (prop, next) {\r\n        if (prop.prop === 'options' && Array.isArray(prop.value)) {\r\n            prop.value = prop.value.map((option) => {\r\n                var _a;\r\n                if (!((_a = option.attrs) === null || _a === void 0 ? void 0 : _a.id)) {\r\n                    return extend(option, {\r\n                        attrs: {\r\n                            id: `${node.name}-option-${slugify(String(option.value))}`,\r\n                        },\r\n                    });\r\n                }\r\n                return option;\r\n            });\r\n            if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {\r\n                if (node.isCreated) {\r\n                    node.input([], false);\r\n                }\r\n                else {\r\n                    node.on('created', () => {\r\n                        if (!Array.isArray(node.value)) {\r\n                            node.input([], false);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return next(prop);\r\n    };\r\n}\r\n\r\n/**\r\n * Event handler when an input is toggled.\r\n *\r\n * @param node - The {@link @formkit/node#FormKitNode | FormKitNode} being toggled.\r\n * @param e - The input event related to the toggling.\r\n *\r\n * @public\r\n */\r\nfunction toggleChecked$1(node, e) {\r\n    const el = e.target;\r\n    if (el instanceof HTMLInputElement) {\r\n        const value = Array.isArray(node.props.options)\r\n            ? optionValue(node.props.options, el.value)\r\n            : el.value;\r\n        if (Array.isArray(node.props.options) && node.props.options.length) {\r\n            if (!Array.isArray(node._value)) {\r\n                // There is no array value set\r\n                node.input([value]);\r\n            }\r\n            else if (!node._value.some((existingValue) => shouldSelect(value, existingValue))) {\r\n                // The value is not in the current set\r\n                node.input([...node._value, value]);\r\n            }\r\n            else {\r\n                // Filter out equivalent values\r\n                node.input(node._value.filter((existingValue) => !shouldSelect(value, existingValue)));\r\n            }\r\n        }\r\n        else {\r\n            if (el.checked) {\r\n                node.input(node.props.onValue);\r\n            }\r\n            else {\r\n                node.input(node.props.offValue);\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Checks if a given option is present in the node value.\r\n *\r\n * @param node - The The {@link @formkit/node#FormKitNode | FormKitNode} being checked.\r\n * @param value - The value of any option.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction isChecked$1(node, value) {\r\n    var _a, _b;\r\n    // We need to force vue’s reactivity to respond when the value is run:\r\n    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;\r\n    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;\r\n    if (Array.isArray(node._value)) {\r\n        return node._value.some((existingValue) => shouldSelect(optionValue(node.props.options, value), existingValue));\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * A feature that adds checkbox selection support.\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction checkboxes(node) {\r\n    node.on('created', () => {\r\n        var _a, _b;\r\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\r\n            node.context.handlers.toggleChecked = toggleChecked$1.bind(null, node);\r\n        }\r\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {\r\n            node.context.fns.isChecked = isChecked$1.bind(null, node);\r\n        }\r\n        // Configure our default onValue and offValue\r\n        if (!has(node.props, 'onValue'))\r\n            node.props.onValue = true;\r\n        if (!has(node.props, 'offValue'))\r\n            node.props.offValue = false;\r\n    });\r\n    node.hook.prop(normalizeBoxes(node));\r\n}\r\n\r\n/**\r\n * A feature that allows disabling children of this node.\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction disables(node) {\r\n    node.on('created', () => {\r\n        node.props.disabled = undefine(node.props.disabled);\r\n    });\r\n    node.hook.prop(({ prop, value }, next) => {\r\n        value = prop === 'disabled' ? undefine(value) : value;\r\n        return next({ prop, value });\r\n    });\r\n    node.on('prop:disabled', ({ payload: value }) => {\r\n        node.config.disabled = undefine(value);\r\n    });\r\n    node.on('created', () => {\r\n        node.config.disabled = undefine(node.props.disabled);\r\n    });\r\n}\r\n\r\n/**\r\n * Creates a new feature that generates a localization message of type ui\r\n * for use on a given component.\r\n *\r\n * @param key - The key of the message.\r\n * @param value - The value of the message.\r\n *\r\n * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.\r\n *\r\n * @public\r\n */\r\nfunction localize(key, value) {\r\n    return (node) => {\r\n        node.store.set(createMessage({\r\n            key,\r\n            type: 'ui',\r\n            value: value || key,\r\n            meta: {\r\n                localize: true,\r\n                i18nArgs: [node],\r\n            },\r\n        }));\r\n    };\r\n}\r\n\r\nconst isBrowser = typeof window !== 'undefined';\r\n/**\r\n * Remove the data-file-hover attribute from the target.\r\n *\r\n * @param e - Event\r\n *\r\n * @internal\r\n */\r\nfunction removeHover(e) {\r\n    if (e.target instanceof HTMLElement &&\r\n        e.target.hasAttribute('data-file-hover')) {\r\n        e.target.removeAttribute('data-file-hover');\r\n    }\r\n}\r\n/**\r\n * Prevent stray drag/drop events from navigating the window.\r\n *\r\n * @param e - Event\r\n *\r\n * @internal\r\n */\r\nfunction preventStrayDrop(type, e) {\r\n    if (!(e.target instanceof HTMLInputElement)) {\r\n        e.preventDefault();\r\n    }\r\n    else if (type === 'dragover') {\r\n        e.target.setAttribute('data-file-hover', 'true');\r\n    }\r\n    if (type === 'drop') {\r\n        removeHover(e);\r\n    }\r\n}\r\n/**\r\n * A feature to add file handling support to an input.\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction files(node) {\r\n    // Localize our content:\r\n    localize('noFiles', 'Select file')(node);\r\n    localize('removeAll', 'Remove all')(node);\r\n    localize('remove')(node);\r\n    if (isBrowser) {\r\n        if (!window._FormKit_File_Drop) {\r\n            window.addEventListener('dragover', preventStrayDrop.bind(null, 'dragover'));\r\n            window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'));\r\n            window.addEventListener('dragleave', removeHover);\r\n            window._FormKit_File_Drop = true;\r\n        }\r\n    }\r\n    node.hook.input((value, next) => next(Array.isArray(value) ? value : []));\r\n    node.on('created', () => {\r\n        if (!Array.isArray(node.value))\r\n            node.input([], false);\r\n        if (!node.context)\r\n            return;\r\n        node.context.handlers.resetFiles = (e) => {\r\n            e.preventDefault();\r\n            node.input([]);\r\n            if (node.props.id && isBrowser) {\r\n                const el = document.getElementById(node.props.id);\r\n                if (el)\r\n                    el.value = '';\r\n            }\r\n        };\r\n        node.context.handlers.files = (e) => {\r\n            var _a, _b;\r\n            const files = [];\r\n            if (e.target instanceof HTMLInputElement && e.target.files) {\r\n                for (let i = 0; i < e.target.files.length; i++) {\r\n                    let file;\r\n                    if ((file = e.target.files.item(i))) {\r\n                        files.push({ name: file.name, file });\r\n                    }\r\n                }\r\n                node.input(files);\r\n            }\r\n            if (node.context)\r\n                node.context.files = files;\r\n            // Call the original listener if there is one.\r\n            if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {\r\n                (_b = node.props.attrs) === null || _b === void 0 ? void 0 : _b.onChange(e);\r\n            }\r\n        };\r\n    });\r\n}\r\n\r\n/**\r\n * Handle the submit event.\r\n *\r\n * @param e - The event\r\n *\r\n * @internal\r\n */\r\nasync function handleSubmit(node, submitEvent) {\r\n    submitEvent.preventDefault();\r\n    await node.settled;\r\n    // Set the submitted state on all children\r\n    const setSubmitted = (n) => n.store.set(createMessage({\r\n        key: 'submitted',\r\n        value: true,\r\n        visible: false,\r\n    }));\r\n    node.walk(setSubmitted);\r\n    setSubmitted(node);\r\n    if (typeof node.props.onSubmitRaw === 'function') {\r\n        node.props.onSubmitRaw(submitEvent, node);\r\n    }\r\n    if (node.ledger.value('blocking')) {\r\n        if (typeof node.props.onSubmitInvalid === 'function') {\r\n            node.props.onSubmitInvalid(node);\r\n        }\r\n        // There is still a blocking message in the store.\r\n        if (node.props.incompleteMessage !== false) {\r\n            node.store.set(createMessage({\r\n                blocking: false,\r\n                key: `incomplete`,\r\n                meta: {\r\n                    localize: node.props.incompleteMessage === undefined,\r\n                    i18nArgs: [{ node }],\r\n                    showAsMessage: true,\r\n                },\r\n                type: 'ui',\r\n                value: node.props.incompleteMessage || 'Form incomplete.',\r\n            }));\r\n        }\r\n    }\r\n    else {\r\n        // No blocking messages\r\n        if (typeof node.props.onSubmit === 'function') {\r\n            // call onSubmit\r\n            const retVal = node.props.onSubmit(node.hook.submit.dispatch(clone(node.value)), node);\r\n            if (retVal instanceof Promise) {\r\n                const autoDisable = node.props.disabled === undefined &&\r\n                    node.props.submitBehavior !== 'live';\r\n                if (autoDisable)\r\n                    node.props.disabled = true;\r\n                node.store.set(createMessage({\r\n                    key: 'loading',\r\n                    value: true,\r\n                    visible: false,\r\n                }));\r\n                await retVal;\r\n                if (autoDisable)\r\n                    node.props.disabled = false;\r\n                node.store.remove('loading');\r\n            }\r\n        }\r\n        else {\r\n            if (submitEvent.target instanceof HTMLFormElement) {\r\n                submitEvent.target.submit();\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * A feature to add a submit handler and actions section.\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction form$1(node) {\r\n    node.props.isForm = true;\r\n    node.on('created', () => {\r\n        var _a;\r\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\r\n            node.context.handlers.submit = handleSubmit.bind(null, node);\r\n        }\r\n        if (!has(node.props, 'actions')) {\r\n            node.props.actions = true;\r\n        }\r\n    });\r\n    node.on('settled:blocking', () => node.store.remove('incomplete'));\r\n}\r\n\r\n/**\r\n * A feature that applies `ignore=\"true\"` by default.\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction ignore(node) {\r\n    if (node.props.ignore === undefined) {\r\n        node.props.ignore = true;\r\n        node.parent = null;\r\n    }\r\n}\r\n\r\n/**\r\n * A feature that ensures the input has an `initialValue` prop.\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction initialValue(node) {\r\n    node.on('created', () => {\r\n        if (node.context) {\r\n            node.context.initialValue = node.value || '';\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Sets the value of a radio button when checked.\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n * @param event - Event\r\n *\r\n * @public\r\n */\r\nfunction toggleChecked(node, event) {\r\n    if (event.target instanceof HTMLInputElement) {\r\n        node.input(optionValue(node.props.options, event.target.value));\r\n    }\r\n}\r\n/**\r\n * Checks if the value being checked is the current value.\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n * @param value - The value to check\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction isChecked(node, value) {\r\n    var _a, _b;\r\n    // We need to force vue’s reactivity to respond when the value is run:\r\n    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;\r\n    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;\r\n    return shouldSelect(optionValue(node.props.options, value), node._value);\r\n}\r\n/**\r\n * A feature to check if the value being checked is the current value.\r\n *\r\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\r\n *\r\n * @public\r\n */\r\nfunction radios(node) {\r\n    node.on('created', () => {\r\n        var _a, _b;\r\n        if (!Array.isArray(node.props.options)) {\r\n            warn(350, node);\r\n        }\r\n        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\r\n            node.context.handlers.toggleChecked = toggleChecked.bind(null, node);\r\n        }\r\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {\r\n            node.context.fns.isChecked = isChecked.bind(null, node);\r\n        }\r\n    });\r\n    node.hook.prop(normalizeBoxes(node));\r\n}\r\n\r\n/**\r\n * Checks if a the given option should have the selected attribute.\r\n * @param node - The node being evaluated.\r\n * @param option - The option value to check\r\n * @returns\r\n * @public\r\n */\r\nfunction isSelected(node, option) {\r\n    // Here we trick reactivity (if at play) to watch this function.\r\n    node.context && node.context.value;\r\n    const optionValue = '__original' in option ? option.__original : option.value;\r\n    function hasNoNullOption() {\r\n        return !node.props.options.some((option) => ('__original' in option ? option.__original : option.value) === null);\r\n    }\r\n    return Array.isArray(node._value)\r\n        ? node._value.some((optionA) => shouldSelect(optionA, optionValue))\r\n        : (node._value === undefined ||\r\n            (node._value === null && hasNoNullOption())) &&\r\n            option.attrs &&\r\n            option.attrs['data-is-placeholder']\r\n            ? true\r\n            : shouldSelect(optionValue, node._value);\r\n}\r\n/**\r\n * Defers the change event till after the next cycle.\r\n * @param node - The node being evaluated.\r\n * @param e - The change event.\r\n */\r\nasync function deferChange(node, e) {\r\n    var _a;\r\n    if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {\r\n        await new Promise((r) => setTimeout(r, 0));\r\n        await node.settled;\r\n        node.props.attrs.onChange(e);\r\n    }\r\n}\r\n/**\r\n * Select the correct values.\r\n * @param e - The input event emitted by the select.\r\n */\r\nfunction selectInput(node, e) {\r\n    const target = e.target;\r\n    const value = target.hasAttribute('multiple')\r\n        ? Array.from(target.selectedOptions).map((o) => optionValue(node.props.options, o.value))\r\n        : optionValue(node.props.options, target.value);\r\n    node.input(value);\r\n}\r\n/**\r\n * Appends a placeholder to the options list.\r\n * @param options - An options list\r\n * @param placeholder - A placeholder string to append\r\n * @returns\r\n */\r\nfunction applyPlaceholder(options, placeholder) {\r\n    if (!options.some((option) => option.attrs && option.attrs['data-is-placeholder'])) {\r\n        return [\r\n            {\r\n                label: placeholder,\r\n                value: '',\r\n                attrs: {\r\n                    hidden: true,\r\n                    disabled: true,\r\n                    'data-is-placeholder': 'true',\r\n                },\r\n            },\r\n            ...options,\r\n        ];\r\n    }\r\n    return options;\r\n}\r\n/**\r\n * Converts the options prop to usable values.\r\n * @param node - A formkit node.\r\n * @public\r\n */\r\nfunction select$1(node) {\r\n    // Set the initial value of a multi-input\r\n    node.on('created', () => {\r\n        var _a, _b, _c;\r\n        const isMultiple = undefine((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.multiple);\r\n        if (!isMultiple &&\r\n            node.props.placeholder &&\r\n            Array.isArray(node.props.options)) {\r\n            node.hook.prop(({ prop, value }, next) => {\r\n                if (prop === 'options') {\r\n                    value = applyPlaceholder(value, node.props.placeholder);\r\n                }\r\n                return next({ prop, value });\r\n            });\r\n            node.props.options = applyPlaceholder(node.props.options, node.props.placeholder);\r\n        }\r\n        if (isMultiple) {\r\n            if (node.value === undefined) {\r\n                node.input([], false);\r\n            }\r\n        }\r\n        else if (node.context && !node.context.options) {\r\n            // If this input is (probably) using the default slot, we need to add a\r\n            // \"value\" attribute to get bound\r\n            node.props.attrs = Object.assign({}, node.props.attrs, {\r\n                value: node._value,\r\n            });\r\n            node.on('input', ({ payload }) => {\r\n                node.props.attrs = Object.assign({}, node.props.attrs, {\r\n                    value: payload,\r\n                });\r\n            });\r\n        }\r\n        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.handlers) {\r\n            node.context.handlers.selectInput = selectInput.bind(null, node);\r\n            node.context.handlers.onChange = deferChange.bind(null, node);\r\n        }\r\n        if ((_c = node.context) === null || _c === void 0 ? void 0 : _c.fns) {\r\n            node.context.fns.isSelected = isSelected.bind(null, node);\r\n            node.context.fns.showPlaceholder = (value, placeholder) => {\r\n                if (!Array.isArray(node.props.options))\r\n                    return false;\r\n                const hasMatchingValue = node.props.options.some((option) => {\r\n                    if (option.attrs && 'data-is-placeholder' in option.attrs)\r\n                        return false;\r\n                    const optionValue = '__original' in option ? option.__original : option.value;\r\n                    return eq(value, optionValue);\r\n                });\r\n                return placeholder && !hasMatchingValue ? true : undefined;\r\n            };\r\n        }\r\n    });\r\n    node.hook.input((value, next) => {\r\n        var _a, _b, _c;\r\n        if (!node.props.placeholder &&\r\n            value === undefined &&\r\n            Array.isArray((_a = node.props) === null || _a === void 0 ? void 0 : _a.options) &&\r\n            node.props.options.length &&\r\n            !undefine((_c = (_b = node.props) === null || _b === void 0 ? void 0 : _b.attrs) === null || _c === void 0 ? void 0 : _c.multiple)) {\r\n            value =\r\n                '__original' in node.props.options[0]\r\n                    ? node.props.options[0].__original\r\n                    : node.props.options[0].value;\r\n        }\r\n        return next(value);\r\n    });\r\n}\r\n\r\n/**\r\n * Adds icon props definition.\r\n *\r\n * @param sectionKey - the location the icon should be loaded.\r\n * @param defaultIcon - the icon that should be loaded if a match is found in the user's CSS.\r\n *\r\n * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.\r\n *\r\n * @public\r\n */\r\nfunction defaultIcon(sectionKey, defaultIcon) {\r\n    return (node) => {\r\n        if (node.props[`${sectionKey}Icon`] === undefined) {\r\n            node.props[`${sectionKey}Icon`] = `default:${defaultIcon}`;\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Type guard for schema objects.\r\n *\r\n * @param schema - returns `true` if the node is a schema node but not a string\r\n * or conditional.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction isSchemaObject(schema) {\r\n    return (typeof schema === 'object' &&\r\n        ('$el' in schema || '$cmp' in schema || '$formkit' in schema));\r\n}\r\n/**\r\n * Checks if the current schema node is a slot condition.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * {\r\n *  if: '$slot.name',\r\n *  then: '$slot.name',\r\n *  else: []\r\n * } // this schema node would return true.\r\n * ```\r\n *\r\n * @param node - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction isSlotCondition(node) {\r\n    if (isConditional(node) &&\r\n        node.if &&\r\n        node.if.startsWith('$slots.') &&\r\n        typeof node.then === 'string' &&\r\n        node.then.startsWith('$slots.') &&\r\n        'else' in node) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Finds a seciton by name in a schema.\r\n *\r\n * @param schema - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode} array.\r\n * @param target - The name of the section to find.\r\n *\r\n * @returns a tuple of the schema and the section or a tuple of `false` and `false` if not found.\r\n *\r\n * @public\r\n */\r\nfunction findSection(schema, target) {\r\n    var _a;\r\n    for (let index = 0; index < schema.length; index++) {\r\n        const section = schema[index];\r\n        if (isSlotCondition(section)) {\r\n            if (isComponent(section.else) || isDOM(section.else)) {\r\n                if (((_a = section.else.meta) === null || _a === void 0 ? void 0 : _a.section) === target) {\r\n                    return [schema, section];\r\n                }\r\n                else if (section.else.children &&\r\n                    Array.isArray(section.else.children) &&\r\n                    section.else.children.length) {\r\n                    const found = findSection(section.else.children, target);\r\n                    if (found[0]) {\r\n                        return found;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return [false, false];\r\n}\r\n/**\r\n * Extends a single schema node with an extension. The extension can be any\r\n * partial node including strings.\r\n *\r\n * @param schema - The base schema node.\r\n * @param extension - The values to extend on the base schema node.\r\n *\r\n * @returns {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}\r\n *\r\n * @public\r\n */\r\nfunction extendSchema(schema, extension = {}) {\r\n    if (typeof schema === 'string') {\r\n        return isSchemaObject(extension) || typeof extension === 'string'\r\n            ? extension\r\n            : schema;\r\n    }\r\n    else if (Array.isArray(schema)) {\r\n        return isSchemaObject(extension) ? extension : schema;\r\n    }\r\n    return extend(schema, extension);\r\n}\r\n/**\r\n * @deprecated This function is deprecated. Use `createSection` instead!\r\n *\r\n * @param key - A new section key name.\r\n * @param schema - The default schema in this composable slot.\r\n *\r\n * @returns {@link @formkit/core#FormKitSchemaComposable | FormKitSchemaComposable}\r\n *\r\n * @public\r\n */\r\nfunction composable(key, schema) {\r\n    warn(800, 'composable function');\r\n    return (extendWith = {}, children = undefined) => {\r\n        const root = typeof schema === 'function'\r\n            ? schema(children)\r\n            : typeof schema === 'object'\r\n                ? clone(schema)\r\n                : schema;\r\n        const isObj = isSchemaObject(root);\r\n        if (isObj && !('children' in root) && children) {\r\n            if (Array.isArray(children)) {\r\n                if (children.length) {\r\n                    root.children = children;\r\n                }\r\n            }\r\n            else {\r\n                root.children = [children];\r\n            }\r\n        }\r\n        const extended = extendSchema(root, extendWith);\r\n        return {\r\n            if: `$slots.${key}`,\r\n            then: `$slots.${key}`,\r\n            else: Array.isArray(extended) ? extended : [extended],\r\n        };\r\n    };\r\n}\r\n/**\r\n * Creates an input schema with all of the wrapping base schema.\r\n *\r\n * @param inputSection - Content to store in the input section key location.\r\n *\r\n * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}\r\n *\r\n * @public\r\n */\r\nfunction useSchema(inputSection) {\r\n    return outer(wrapper(label('$label'), inner(prefix(), inputSection(), suffix())), help('$help'), messages(message('$message.value')));\r\n}\r\nfunction createSection(section, el, root = false) {\r\n    return (...children) => {\r\n        const extendable = (extensions) => {\r\n            const node = !el || typeof el === 'string' ? { $el: el } : el();\r\n            if (isDOM(node) || isComponent(node)) {\r\n                if (!node.meta) {\r\n                    node.meta = { section };\r\n                }\r\n                if (children.length && !node.children) {\r\n                    node.children = [\r\n                        ...children.map((child) => typeof child === 'string' ? child : child(extensions)),\r\n                    ];\r\n                }\r\n                if (isDOM(node)) {\r\n                    node.attrs = {\r\n                        class: `$classes.${section}`,\r\n                        ...(node.attrs || {}),\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                if: `$slots.${section}`,\r\n                then: `$slots.${section}`,\r\n                else: section in extensions\r\n                    ? extendSchema(node, extensions[section])\r\n                    : node,\r\n            };\r\n        };\r\n        extendable._s = section;\r\n        return root ? createRoot(extendable) : extendable;\r\n    };\r\n}\r\n/**\r\n * Returns an extendable schema root node.\r\n *\r\n * @param rootSection - Creates the root node.\r\n *\r\n * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}\r\n *\r\n * @internal\r\n */\r\nfunction createRoot(rootSection) {\r\n    return (extensions) => {\r\n        return [rootSection(extensions)];\r\n    };\r\n}\r\n/**\r\n * Applies attributes to a given schema section by applying a higher order\r\n * function that merges a given set of attributes into the node.\r\n *\r\n * @param attrs - Attributes to apply to a {@link FormKitSchemaExtendableSection\r\n * | FormKitSchemaExtendableSection}.\r\n * @param section - A section to apply attributes to.\r\n *\r\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\r\n *\r\n * @public\r\n */\r\nfunction $attrs(attrs, section) {\r\n    const extendable = (extensions) => {\r\n        const node = section(extensions);\r\n        const attributes = typeof attrs === 'function' ? attrs() : attrs;\r\n        if (!isObject(attributes))\r\n            return node;\r\n        if (isSlotCondition(node) && isDOM(node.else)) {\r\n            node.else.attrs = { ...node.else.attrs, ...attributes };\r\n        }\r\n        else if (isDOM(node)) {\r\n            node.attrs = { ...node.attrs, ...attributes };\r\n        }\r\n        return node;\r\n    };\r\n    extendable._s = section._s;\r\n    return extendable;\r\n}\r\n/**\r\n * Applies a condition to a given schema section.\r\n *\r\n * @param condition - A schema condition to apply to a section.\r\n * @param then - The section that applies if the condition is true.\r\n * @param otherwise - (else) The section that applies if the condition is false.\r\n *\r\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\r\n *\r\n * @public\r\n */\r\nfunction $if(condition, then, otherwise) {\r\n    const extendable = (extensions) => {\r\n        const node = then(extensions);\r\n        if (otherwise ||\r\n            (isSchemaObject(node) && 'if' in node) ||\r\n            isSlotCondition(node)) {\r\n            const conditionalNode = {\r\n                if: condition,\r\n                then: node,\r\n            };\r\n            if (otherwise) {\r\n                conditionalNode.else = otherwise(extensions);\r\n            }\r\n            return conditionalNode;\r\n        }\r\n        else if (isSlotCondition(node)) {\r\n            Object.assign(node.else, { if: condition });\r\n        }\r\n        else if (isSchemaObject(node)) {\r\n            Object.assign(node, { if: condition });\r\n        }\r\n        return node;\r\n    };\r\n    extendable._s = token();\r\n    return extendable;\r\n}\r\n/**\r\n * Applies a condition to a given schema section.\r\n *\r\n * @param varName - The name of the variable that holds the current instance.\r\n * @param inName - The variable we are iterating over.\r\n * @param section - A section to repeat.\r\n *\r\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\r\n *\r\n * @public\r\n */\r\nfunction $for(varName, inName, section) {\r\n    return (extensions) => {\r\n        const node = section(extensions);\r\n        if (isSlotCondition(node)) {\r\n            Object.assign(node.else, { for: [varName, inName] });\r\n        }\r\n        else if (isSchemaObject(node)) {\r\n            Object.assign(node, { for: [varName, inName] });\r\n        }\r\n        return node;\r\n    };\r\n}\r\n/**\r\n * Extends a schema node with a given set of extensions.\r\n *\r\n * @param section - A section to apply an extension to.\r\n * @param extendWith - A partial schema snippet to apply to the section.\r\n *\r\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\r\n *\r\n * @public\r\n */\r\nfunction $extend(section, extendWith) {\r\n    const extendable = (extensions) => {\r\n        const node = section({});\r\n        if (isSlotCondition(node)) {\r\n            if (Array.isArray(node.else))\r\n                return node;\r\n            node.else = extendSchema(extendSchema(node.else, extendWith), section._s ? extensions[section._s] : {});\r\n            return node;\r\n        }\r\n        return extendSchema(extendSchema(node, extendWith), section._s ? extensions[section._s] : {});\r\n    };\r\n    extendable._s = section._s;\r\n    return extendable;\r\n}\r\n/**\r\n * Creates a root schema section.\r\n *\r\n * @param section - A section to make a root from.\r\n *\r\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\r\n *\r\n * @public\r\n */\r\nfunction $root(section) {\r\n    return createRoot(section);\r\n}\r\n\r\n/**\r\n * Input definition for a button.\r\n * @public\r\n */\r\nconst button = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: outer(messages(message('$message.value')), wrapper(buttonInput(icon('prefix'), prefix(), buttonLabel('$label || $ui.submit.value'), suffix(), icon('suffix'))), help('$help')),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'input',\r\n    /**\r\n     * The family of inputs this one belongs too. For example \"text\" and \"email\"\r\n     * are both part of the \"text\" family. This is primary used for styling.\r\n     */\r\n    family: 'button',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: [],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [localize('submit'), ignore],\r\n};\r\n\r\n/**\r\n * Input definition for a checkbox(ess).\r\n * @public\r\n */\r\nconst checkbox = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: outer($if('$options == undefined', \r\n    /**\r\n     * Single checkbox structure.\r\n     */\r\n    boxWrapper(inner(prefix(), box(), decorator(icon('decorator')), suffix()), $extend(boxLabel('$label'), {\r\n        if: '$label',\r\n    })), \r\n    /**\r\n     * Multi checkbox structure.\r\n     */\r\n    fieldset(legend('$label'), help('$help'), boxOptions(boxOption(boxWrapper(inner(prefix(), $extend(box(), {\r\n        bind: '$option.attrs',\r\n        attrs: {\r\n            id: '$option.attrs.id',\r\n            value: '$option.value',\r\n            checked: '$fns.isChecked($option.value)',\r\n        },\r\n    }), decorator(icon('decorator')), suffix()), $extend(boxLabel('$option.label'), {\r\n        if: '$option.label',\r\n    })), boxHelp('$option.help'))))), \r\n    // Help text only goes under the input when it is a single.\r\n    $if('$options == undefined && $help', help('$help')), messages(message('$message.value'))),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'input',\r\n    /**\r\n     * The family of inputs this one belongs too. For example \"text\" and \"email\"\r\n     * are both part of the \"text\" family. This is primary used for styling.\r\n     */\r\n    family: 'box',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: ['options', 'onValue', 'offValue', 'optionsLoader'],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [\r\n        options,\r\n        checkboxes,\r\n        defaultIcon('decorator', 'checkboxDecorator'),\r\n    ],\r\n};\r\n\r\n/**\r\n * Input definition for a file input.\r\n * @public\r\n */\r\nconst file = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), fileInput(), fileList(fileItem(icon('fileItem'), fileName('$file.name'), $if('$value.length === 1', fileRemove(icon('fileRemove'), '$ui.remove.value')))), $if('$value.length > 1', fileRemove('$ui.removeAll.value')), noFiles(icon('noFiles'), '$ui.noFiles.value'), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'input',\r\n    /**\r\n     * The family of inputs this one belongs too. For example \"text\" and \"email\"\r\n     * are both part of the \"text\" family. This is primary used for styling.\r\n     */\r\n    family: 'text',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: [],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [\r\n        files,\r\n        defaultIcon('fileItem', 'fileItem'),\r\n        defaultIcon('fileRemove', 'fileRemove'),\r\n        defaultIcon('noFiles', 'noFiles'),\r\n    ],\r\n};\r\n\r\n/**\r\n * Input definition for a form.\r\n * @public\r\n */\r\nconst form = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: formInput('$slots.default', messages(message('$message.value')), actions(submitInput())),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'group',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: [\r\n        'actions',\r\n        'submit',\r\n        'submitLabel',\r\n        'submitAttrs',\r\n        'submitBehavior',\r\n        'incompleteMessage',\r\n    ],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [form$1, disables],\r\n};\r\n\r\n/**\r\n * Input definition for a group.\r\n * @public\r\n */\r\nconst group = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: fragment('$slots.default'),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'group',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: [],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [disables],\r\n};\r\n\r\n/**\r\n * Input definition for a hidden input.\r\n * @public\r\n */\r\nconst hidden = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: $root(textInput()),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'input',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: [],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [],\r\n};\r\n\r\n/**\r\n * Input definition for a list.\r\n * @public\r\n */\r\nconst list = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: fragment('$slots.default'),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'list',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: [],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [disables],\r\n};\r\n\r\n/**\r\n * Input definition for a radio.\r\n * @public\r\n */\r\nconst radio = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: outer($if('$options == undefined', \r\n    /**\r\n     * Single radio structure.\r\n     */\r\n    boxWrapper(inner(prefix(), box(), decorator(icon('decorator')), suffix()), $if('$label', boxLabel('$label'))), \r\n    /**\r\n     * Multi radio structure.\r\n     */\r\n    fieldset(legend('$label'), help('$help'), boxOptions(boxOption(boxWrapper(inner(prefix(), $extend(box(), {\r\n        bind: '$option.attrs',\r\n        attrs: {\r\n            id: '$option.attrs.id',\r\n            value: '$option.value',\r\n            checked: '$fns.isChecked($option.value)',\r\n        },\r\n    }), decorator(icon('decorator')), suffix()), $if('$option.label', boxLabel('$option.label'))), boxHelp('$option.help'))))), \r\n    // Help text only goes under the input when it is a single.\r\n    $if('$options === undefined && $help', help('$help')), messages(message('$message.value'))),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'input',\r\n    /**\r\n     * The family of inputs this one belongs too. For example \"text\" and \"email\"\r\n     * are both part of the \"text\" family. This is primary used for styling.\r\n     */\r\n    family: 'box',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: ['options', 'onValue', 'offValue', 'optionsLoader'],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [\r\n        disables,\r\n        options,\r\n        radios,\r\n        defaultIcon('decorator', 'radioDecorator'),\r\n    ],\r\n};\r\n\r\n/**\r\n * Input definition for a select.\r\n * @public\r\n */\r\nconst select = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: outer(wrapper(label('$label'), inner(icon('prefix'), prefix(), selectInput$1($if('$slots.default', () => '$slots.default', $if('$slots.option', optionSlot, option('$option.label')))), $if('$attrs.multiple !== undefined', () => '', icon('select')), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'input',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: ['options', 'placeholder', 'optionsLoader'],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [options, select$1, defaultIcon('select', 'select')],\r\n};\r\n\r\n/**\r\n * Input definition for a textarea.\r\n * @public\r\n */\r\nconst textarea = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), textareaInput(), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'input',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: [],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [initialValue],\r\n};\r\n\r\n/**\r\n * Input definition for a text.\r\n * @public\r\n */\r\nconst text = {\r\n    /**\r\n     * The actual schema of the input, or a function that returns the schema.\r\n     */\r\n    schema: outer(wrapper(label('$label'), inner(icon('prefix', 'label'), prefix(), textInput(), suffix(), icon('suffix'))), help('$help'), messages(message('$message.value'))),\r\n    /**\r\n     * The type of node, can be a list, group, or input.\r\n     */\r\n    type: 'input',\r\n    /**\r\n     * The family of inputs this one belongs too. For example \"text\" and \"email\"\r\n     * are both part of the \"text\" family. This is primary used for styling.\r\n     */\r\n    family: 'text',\r\n    /**\r\n     * An array of extra props to accept for this input.\r\n     */\r\n    props: [],\r\n    /**\r\n     * Additional features that should be added to your input\r\n     */\r\n    features: [],\r\n};\r\n\r\nvar index = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    button: button,\r\n    submit: button,\r\n    checkbox: checkbox,\r\n    file: file,\r\n    form: form,\r\n    group: group,\r\n    hidden: hidden,\r\n    list: list,\r\n    radio: radio,\r\n    select: select,\r\n    textarea: textarea,\r\n    text: text,\r\n    color: text,\r\n    date: text,\r\n    datetimeLocal: text,\r\n    email: text,\r\n    month: text,\r\n    number: text,\r\n    password: text,\r\n    search: text,\r\n    tel: text,\r\n    time: text,\r\n    url: text,\r\n    week: text,\r\n    range: text\r\n});\r\n\r\nexport { $attrs, $extend, $for, $if, $root, actions, box, boxHelp, boxLabel, boxOption, boxOptions, boxWrapper, button, buttonInput, buttonLabel, checkbox, checkboxes, text as color, composable, createLibraryPlugin, createSection, text as date, text as datetimeLocal, decorator, defaultIcon, disables as disablesChildren, text as email, extendSchema, fieldset, file, fileInput, fileItem, fileList, fileName, fileRemove, files, findSection, form, formInput, form$1 as forms, fragment, group, help, hidden, icon, ignore as ignores, initialValue, inner, index as inputs, isSchemaObject, isSlotCondition, label, legend, list, localize, message, messages, text as month, noFiles, normalizeBoxes, normalizeOptions, text as number, option, optionSlot, options, outer, text as password, prefix, radio, radios, text as range, text as search, select, selectInput$1 as selectInput, select$1 as selects, button as submit, submitInput, suffix, text as tel, text, textInput, textarea, textareaInput, text as time, text as url, useSchema, text as week, wrapper };\r\n"],
  "mappings": "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",
  "names": ["use", "index", "receipts", "wrapper", "node", "bubble", "error", "messages", "message", "errors", "options", "message", "options", "calm", "hydrate", "setIndex", "index", "fragment", "errors", "message", "trap", "char", "depth", "token", "options", "option", "files", "file", "optionValue", "defaultIcon", "index", "select", "text"]
}
