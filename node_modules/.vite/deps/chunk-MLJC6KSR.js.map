{
  "version": 3,
  "sources": ["../../@formkit/utils/dist/index.mjs"],
  "sourcesContent": ["/**\r\n * Commonly shared utility functions between official FormKit packages.\r\n *\r\n * You can add this package by using `npm install @formkit/utils` or `yarn add @formkit/utils`.\r\n *\r\n * @packageDocumentation\r\n */\r\nconst isBrowser = typeof window !== 'undefined';\r\n/**\r\n * Explicit keys that should always be cloned.\r\n */\r\nconst explicitKeys = [\r\n    '__key',\r\n    '__init',\r\n    '__shim',\r\n    '__original',\r\n    '__index',\r\n    '__prevKey',\r\n];\r\n/**\r\n * Generates a random string.\r\n *\r\n * @example\r\n *\r\n * ```javascript\r\n * import { token } from '@formkit/utils'\r\n *\r\n * const tk = token()\r\n * // 'jkbyqnphqm'\r\n * ```\r\n *\r\n * @returns string\r\n *\r\n * @public\r\n */\r\nfunction token() {\r\n    return Math.random().toString(36).substring(2, 15);\r\n}\r\n/**\r\n * Creates a new set of the specified type and uses the values from an Array or\r\n * an existing Set.\r\n *\r\n * @example\r\n *\r\n * ```javascript\r\n * import { setify } from '@formkit/utils'\r\n *\r\n * const tk = setify(['a', 'b'])\r\n * // Set(2) {'a', 'b'}\r\n * ```\r\n *\r\n * @param items - An array or a Set.\r\n *\r\n * @returns `Set<T>`\r\n *\r\n * @public\r\n */\r\nfunction setify(items) {\r\n    return items instanceof Set ? items : new Set(items);\r\n}\r\n/**\r\n * Given 2 arrays, return them as a combined array with no duplicates.\r\n *\r\n * @param arr1 - First array.\r\n * @param arr2 - Second array.\r\n *\r\n * @returns `any[]`\r\n *\r\n * @public\r\n */\r\nfunction dedupe(arr1, arr2) {\r\n    const original = arr1 instanceof Set ? arr1 : new Set(arr1);\r\n    if (arr2)\r\n        arr2.forEach((item) => original.add(item));\r\n    return [...original];\r\n}\r\n/**\r\n * Checks if the given property exists on the given object.\r\n *\r\n * @param obj - An object to check.\r\n * @param property - The property to check.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction has(obj, property) {\r\n    return Object.prototype.hasOwnProperty.call(obj, property);\r\n}\r\n/**\r\n * Compare two values for equality, optionally at depth.\r\n *\r\n * @param valA - First value.\r\n * @param valB - Second value.\r\n * @param deep - If it will compare deeply if it's an object.\r\n * @param explicit - An array of keys to explicity check.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction eq(valA, // eslint-disable-line\r\nvalB, // eslint-disable-line\r\ndeep = true, explicit = ['__key']) {\r\n    if (valA === valB)\r\n        return true;\r\n    if (typeof valB === 'object' && typeof valA === 'object') {\r\n        if (valA instanceof Map)\r\n            return false;\r\n        if (valA instanceof Set)\r\n            return false;\r\n        if (valA instanceof Date)\r\n            return false;\r\n        if (valA === null || valB === null)\r\n            return false;\r\n        if (Object.keys(valA).length !== Object.keys(valB).length)\r\n            return false;\r\n        for (const k of explicit) {\r\n            if ((k in valA || k in valB) && valA[k] !== valB[k])\r\n                return false;\r\n        }\r\n        for (const key in valA) {\r\n            if (!(key in valB))\r\n                return false;\r\n            if (valA[key] !== valB[key] && !deep)\r\n                return false;\r\n            if (deep && !eq(valA[key], valB[key], deep, explicit))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Determines if a value is empty or not.\r\n *\r\n * @param value - The value to check if it's empty.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction empty(value // eslint-disable-line\r\n) {\r\n    const type = typeof value;\r\n    if (type === 'number')\r\n        return false;\r\n    if (value === undefined)\r\n        return true;\r\n    if (type === 'string') {\r\n        return value === '';\r\n    }\r\n    if (type === 'object') {\r\n        if (value === null)\r\n            return true;\r\n        for (const _i in value)\r\n            return false;\r\n        if (value instanceof RegExp)\r\n            return false;\r\n        if (value instanceof Date)\r\n            return false;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Escape a string for use in regular expressions.\r\n *\r\n * @param string - String to be escaped.\r\n *\r\n * @returns `string`\r\n *\r\n * @public\r\n */\r\nfunction escapeExp(string) {\r\n    // $& means the whole matched string\r\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\n/**\r\n * Given a string date format, return a regex to match against.\r\n *\r\n * @param format - String to be transformed to RegExp.\r\n *\r\n * @example\r\n *\r\n * ```javascript\r\n * regexForFormat('MM') // returns '(0[1-9]|1[012])'\r\n * ```\r\n *\r\n * @returns `RegExp`\r\n *\r\n * @public\r\n */\r\nfunction regexForFormat(format) {\r\n    const escaped = `^${escapeExp(format)}$`;\r\n    const formats = {\r\n        MM: '(0[1-9]|1[012])',\r\n        M: '([1-9]|1[012])',\r\n        DD: '([012][0-9]|3[01])',\r\n        D: '([012]?[0-9]|3[01])',\r\n        YYYY: '\\\\d{4}',\r\n        YY: '\\\\d{2}',\r\n    };\r\n    const tokens = Object.keys(formats);\r\n    return new RegExp(tokens.reduce((regex, format) => {\r\n        return regex.replace(format, formats[format]);\r\n    }, escaped));\r\n}\r\n/**\r\n * Given a FormKit input type, returns the correct lowerCased() type.\r\n *\r\n * @param type - String to return to check for correct type\r\n *\r\n * @returns `'list' | 'group' | 'input'`\r\n *\r\n * @public\r\n */\r\nfunction nodeType(type) {\r\n    const t = type.toLowerCase();\r\n    if (t === 'list')\r\n        return 'list';\r\n    if (t === 'group')\r\n        return 'group';\r\n    return 'input';\r\n}\r\n/**\r\n * Determines if an object is an object.\r\n *\r\n * @param o - The value to be checked.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction isRecord(o) {\r\n    return Object.prototype.toString.call(o) === '[object Object]';\r\n}\r\n/**\r\n * Checks if an object is a simple array or record.\r\n *\r\n * @param o - Value to be checked.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction isObject(o) {\r\n    return isRecord(o) || Array.isArray(o);\r\n}\r\n/**\r\n * Attempts to determine if an object is a POJO (Plain Old JavaScript Object).\r\n * Mostly lifted from is-plain-object: https://github.com/jonschlinkert/is-plain-object\r\n * Copyright (c) 2014-2017, Jon Schlinkert.\r\n *\r\n * @param o - The value to be checked.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nfunction isPojo(o) {\r\n    if (isRecord(o) === false)\r\n        return false;\r\n    if (o.__FKNode__ || o.__POJO__ === false)\r\n        return false;\r\n    const ctor = o.constructor;\r\n    if (ctor === undefined)\r\n        return true;\r\n    const prot = ctor.prototype;\r\n    if (isRecord(prot) === false)\r\n        return false;\r\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Recursively merge data from additional into original returning a new object.\r\n *\r\n * @param original - The original array.\r\n * @param additional - The array to merge.\r\n * @param extendArrays - If it will extend/concatenate array values instead of\r\n * replacing them.\r\n * @param ignoreUndefined - If it will preserve values from the original object\r\n * even if the additional object has those values set to undefined.\r\n *\r\n * @returns `Record<string, any> | string | null`\r\n *\r\n * @public\r\n */\r\nfunction extend(original, additional, extendArrays = false, ignoreUndefined = false) {\r\n    if (additional === null)\r\n        return null;\r\n    const merged = {};\r\n    if (typeof additional === 'string')\r\n        return additional;\r\n    for (const key in original) {\r\n        if (has(additional, key) &&\r\n            (additional[key] !== undefined || !ignoreUndefined)) {\r\n            if (extendArrays &&\r\n                Array.isArray(original[key]) &&\r\n                Array.isArray(additional[key])) {\r\n                merged[key] = original[key].concat(additional[key]);\r\n                continue;\r\n            }\r\n            if (additional[key] === undefined) {\r\n                continue;\r\n            }\r\n            if (isPojo(original[key]) && isPojo(additional[key])) {\r\n                merged[key] = extend(original[key], additional[key], extendArrays, ignoreUndefined);\r\n            }\r\n            else {\r\n                merged[key] = additional[key];\r\n            }\r\n        }\r\n        else {\r\n            merged[key] = original[key];\r\n        }\r\n    }\r\n    for (const key in additional) {\r\n        if (!has(merged, key) && additional[key] !== undefined) {\r\n            merged[key] = additional[key];\r\n        }\r\n    }\r\n    return merged;\r\n}\r\n/**\r\n * Determine if the given string is fully quoted.\r\n *\r\n * @example\r\n *\r\n * ```javascript\r\n * hello - false\r\n * \"hello\" - true\r\n * 'world' - true\r\n * \"hello\"==\"world\" - false\r\n * \"hello'this'\" - false\r\n * \"hello\"'there' - false\r\n * \"hello\"\"there\" - false\r\n * 'hello === world' - true\r\n * ```\r\n *\r\n * @param str - The string to check.\r\n *\r\n * @returns `boolean`\r\n *\r\n * @public\r\n */\r\nfunction isQuotedString(str) {\r\n    // quickly return false if the value is note quoted\r\n    if (str[0] !== '\"' && str[0] !== \"'\")\r\n        return false;\r\n    if (str[0] !== str[str.length - 1])\r\n        return false;\r\n    const quoteType = str[0];\r\n    for (let p = 1; p < str.length; p++) {\r\n        if (str[p] === quoteType &&\r\n            (p === 1 || str[p - 1] !== '\\\\') &&\r\n            p !== str.length - 1) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Remove extra escape characters.\r\n *\r\n * @param str - String to remove extra escape characters from.\r\n *\r\n * @returns `string`\r\n *\r\n * @public\r\n */\r\nfunction rmEscapes(str) {\r\n    if (!str.length)\r\n        return '';\r\n    let clean = '';\r\n    let lastChar = '';\r\n    for (let p = 0; p < str.length; p++) {\r\n        const char = str.charAt(p);\r\n        if (char !== '\\\\' || lastChar === '\\\\') {\r\n            clean += char;\r\n        }\r\n        lastChar = char;\r\n    }\r\n    return clean;\r\n}\r\n/**\r\n * Performs a recursive `Object.assign`-like operation.\r\n *\r\n * @param a - An object to be assigned.\r\n * @param b - An object to get values from.\r\n *\r\n * @returns `A & B`\r\n *\r\n * @public\r\n */\r\nfunction assignDeep(a, b) {\r\n    for (const key in a) {\r\n        if (has(b, key) &&\r\n            a[key] !== b[key] &&\r\n            !(isPojo(a[key]) && isPojo(b[key]))) {\r\n            a[key] = b[key];\r\n        }\r\n        else if (isPojo(a[key]) && isPojo(b[key])) {\r\n            assignDeep(a[key], b[key]);\r\n        }\r\n    }\r\n    for (const key in b) {\r\n        if (!has(a, key)) {\r\n            a[key] = b[key];\r\n        }\r\n    }\r\n    return a;\r\n}\r\n/**\r\n * Filters out values from an object that should not be considered \"props\" of\r\n * a core node, like \"value\" and \"name\".\r\n *\r\n * @param sets - The arrays to get values filtered out of.\r\n *\r\n * @returns `Record<string, any>`\r\n *\r\n * @public\r\n */\r\nfunction nodeProps(...sets) {\r\n    return sets.reduce((valid, props) => {\r\n        const { value, name, modelValue, config, plugins, ...validProps } = props; // eslint-disable-line\r\n        return Object.assign(valid, validProps);\r\n    }, {});\r\n}\r\n/**\r\n * Parse a string for comma-separated arguments.\r\n *\r\n * @param str - String to parse arguments from.\r\n *\r\n * @returns `string[]`\r\n *\r\n * @public\r\n */\r\nfunction parseArgs(str) {\r\n    const args = [];\r\n    let arg = '';\r\n    let depth = 0;\r\n    let quote = '';\r\n    let lastChar = '';\r\n    for (let p = 0; p < str.length; p++) {\r\n        const char = str.charAt(p);\r\n        if (char === quote && lastChar !== '\\\\') {\r\n            quote = '';\r\n        }\r\n        else if ((char === \"'\" || char === '\"') && !quote && lastChar !== '\\\\') {\r\n            quote = char;\r\n        }\r\n        else if (char === '(' && !quote) {\r\n            depth++;\r\n        }\r\n        else if (char === ')' && !quote) {\r\n            depth--;\r\n        }\r\n        if (char === ',' && !quote && depth === 0) {\r\n            args.push(arg);\r\n            arg = '';\r\n        }\r\n        else if (char !== ' ' || quote) {\r\n            arg += char;\r\n        }\r\n        lastChar = char;\r\n    }\r\n    if (arg) {\r\n        args.push(arg);\r\n    }\r\n    return args;\r\n}\r\n/**\r\n * Return a new (shallow) object with any desired props removed.\r\n *\r\n * @param obj - The starting object.\r\n * @param toRemove - The array of properties to remove. Accepts strings or\r\n * regular expressions.\r\n *\r\n * @returns `Record<string, any>`\r\n *\r\n * @public\r\n */\r\nfunction except(obj, toRemove) {\r\n    const clean = {};\r\n    const exps = toRemove.filter((n) => n instanceof RegExp);\r\n    const keysToRemove = new Set(toRemove);\r\n    for (const key in obj) {\r\n        if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {\r\n            clean[key] = obj[key];\r\n        }\r\n    }\r\n    return clean;\r\n}\r\n/**\r\n * Extracts a set of keys from a given object. Importantly, this will extract\r\n * values even if they are not set on the original object — they will just have\r\n * an undefined value.\r\n *\r\n * @param obj - The object to get values from.\r\n * @param include - The array of items to get.\r\n *\r\n * @returns `Record<string, any>`\r\n *\r\n * @public\r\n */\r\nfunction only(obj, include) {\r\n    const clean = {};\r\n    const exps = include.filter((n) => n instanceof RegExp);\r\n    include.forEach((key) => {\r\n        if (!(key instanceof RegExp)) {\r\n            clean[key] = obj[key];\r\n        }\r\n    });\r\n    Object.keys(obj).forEach((key) => {\r\n        if (exps.some((exp) => exp.test(key))) {\r\n            clean[key] = obj[key];\r\n        }\r\n    });\r\n    return clean;\r\n}\r\n/**\r\n * This converts kebab-case to camelCase. It ONLY converts from kebab to camel.\r\n *\r\n * @param str - String to be camel cased.\r\n *\r\n * @returns `string`\r\n *\r\n * @public\r\n */\r\nfunction camel(str) {\r\n    return str.replace(/-([a-z0-9])/gi, (_s, g) => g.toUpperCase());\r\n}\r\n/**\r\n * This converts camel-case to kebab case. It ONLY converts from camel to kebab.\r\n *\r\n * @param str - String to be kebabed.\r\n *\r\n * @returns `string`\r\n *\r\n * @public\r\n */\r\nfunction kebab(str) {\r\n    return str\r\n        .replace(/([a-z0-9])([A-Z])/g, (_s, trail, cap) => trail + '-' + cap.toLowerCase())\r\n        .replace(' ', '-')\r\n        .toLowerCase();\r\n}\r\n/**\r\n * Shallowly clones the given object.\r\n *\r\n * @param obj - Object to be shallowly cloned.\r\n * @param explicit - The array of keys to be explicity cloned.\r\n *\r\n * @returns `T`\r\n *\r\n * @public\r\n */\r\nfunction shallowClone(obj, explicit = explicitKeys) {\r\n    if (obj !== null && typeof obj === 'object') {\r\n        let returnObject;\r\n        if (Array.isArray(obj))\r\n            returnObject = [...obj];\r\n        else if (isPojo(obj))\r\n            returnObject = { ...obj };\r\n        if (returnObject) {\r\n            applyExplicit(obj, returnObject, explicit);\r\n            return returnObject;\r\n        }\r\n    }\r\n    return obj;\r\n}\r\n/**\r\n * Perform a recursive clone on a given object. Only intended to be used\r\n * for simple objects like arrays and POJOs.\r\n *\r\n * @param obj - Object to be cloned.\r\n * @param explicit - Array of items to be explicity cloned.\r\n *\r\n * @returns `T`\r\n *\r\n * @public\r\n */\r\nfunction clone(obj, explicit = explicitKeys) {\r\n    if (obj === null ||\r\n        obj instanceof RegExp ||\r\n        obj instanceof Date ||\r\n        obj instanceof Map ||\r\n        obj instanceof Set ||\r\n        (typeof File === 'function' && obj instanceof File))\r\n        return obj;\r\n    let returnObject;\r\n    if (Array.isArray(obj)) {\r\n        returnObject = obj.map((value) => {\r\n            if (typeof value === 'object')\r\n                return clone(value, explicit);\r\n            return value;\r\n        });\r\n    }\r\n    else {\r\n        returnObject = Object.keys(obj).reduce((newObj, key) => {\r\n            newObj[key] =\r\n                typeof obj[key] === 'object'\r\n                    ? clone(obj[key], explicit)\r\n                    : obj[key];\r\n            return newObj;\r\n        }, {});\r\n    }\r\n    for (const key of explicit) {\r\n        if (key in obj) {\r\n            Object.defineProperty(returnObject, key, {\r\n                enumerable: false,\r\n                value: obj[key],\r\n            });\r\n        }\r\n    }\r\n    return returnObject;\r\n}\r\n/**\r\n * Clones anything. If the item is scalar, no worries, it passes it back. If it\r\n * is an object, it performs a (fast/loose) clone operation.\r\n *\r\n * @param obj - The value to be cloned.\r\n *\r\n * @returns `T`\r\n *\r\n * @public\r\n */\r\nfunction cloneAny(obj) {\r\n    return typeof obj === 'object'\r\n        ? clone(obj)\r\n        : obj;\r\n}\r\n/**\r\n * Get a specific value via dot notation.\r\n *\r\n * @param obj - An object to fetch data from.\r\n * @param addr - An \"address\" in dot notation.\r\n *\r\n * @returns `unknown`\r\n *\r\n * @public\r\n */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nfunction getAt(obj, addr) {\r\n    if (!obj || typeof obj !== 'object')\r\n        return null;\r\n    const segments = addr.split('.');\r\n    let o = obj;\r\n    for (const i in segments) {\r\n        const segment = segments[i];\r\n        if (has(o, segment)) {\r\n            o = o[segment];\r\n        }\r\n        if (+i === segments.length - 1)\r\n            return o;\r\n        if (!o || typeof o !== 'object')\r\n            return null;\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Determines if the value of a prop that is either present (true) or not\r\n * present (undefined). For example, the prop disabled should disable\r\n * by just existing, but what if it is set to the string \"false\" — then it\r\n * should not be disabled.\r\n *\r\n * @param value - Value to check for undefined.\r\n *\r\n * @returns `true | undefined`\r\n *\r\n * @public\r\n */\r\nfunction undefine(value) {\r\n    return value !== undefined && value !== 'false' && value !== false\r\n        ? true\r\n        : undefined;\r\n}\r\n/**\r\n * Defines an object as an initial value.\r\n *\r\n * @param obj - Object to be added an initial value.\r\n *\r\n * @returns `T & { __init?: true }`\r\n *\r\n * @public\r\n */\r\n/* eslint-disable-next-line @typescript-eslint/ban-types */\r\nfunction init(obj) {\r\n    return !Object.isFrozen(obj)\r\n        ? Object.defineProperty(obj, '__init', {\r\n            enumerable: false,\r\n            value: true,\r\n        })\r\n        : obj;\r\n}\r\n/**\r\n * Turn any string into a URL/DOM-safe string.\r\n *\r\n * @param str - String to be slugified to a URL-safe string.\r\n *\r\n * @returns `string`\r\n *\r\n * @public\r\n */\r\nfunction slugify(str) {\r\n    return str\r\n        .normalize('NFD')\r\n        .replace(/[\\u0300-\\u036f]/g, '')\r\n        .toLowerCase()\r\n        .replace(/[^a-z0-9]/g, ' ')\r\n        .trim()\r\n        .replace(/\\s+/g, '-');\r\n}\r\n/**\r\n * Spreads an object or an array, otherwise returns the same value.\r\n *\r\n * @param obj - The object to be spread.\r\n * @param explicit - The array of items to be explicity spread.\r\n *\r\n * @returns `T`\r\n *\r\n * @public\r\n */\r\nfunction spread(obj, explicit = explicitKeys) {\r\n    if (obj && typeof obj === 'object') {\r\n        if (obj instanceof RegExp)\r\n            return obj;\r\n        if (obj instanceof Date)\r\n            return obj;\r\n        let spread;\r\n        if (Array.isArray(obj)) {\r\n            spread = [...obj];\r\n        }\r\n        else {\r\n            spread = { ...obj };\r\n        }\r\n        // eslint-disable-next-line @typescript-eslint/ban-types\r\n        return applyExplicit(obj, spread, explicit);\r\n    }\r\n    return obj;\r\n}\r\n/**\r\n * Apply non enumerable properties to an object.\r\n *\r\n * @param original - Original object\r\n * @param obj - Objecto to aplly the values\r\n * @param explicit - Array of items to be explicity added.\r\n *\r\n * @returns `T`\r\n *\r\n * @public\r\n */\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction applyExplicit(original, obj, explicit) {\r\n    for (const key of explicit) {\r\n        if (key in original) {\r\n            Object.defineProperty(obj, key, {\r\n                enumerable: false,\r\n                value: original[key],\r\n            });\r\n        }\r\n    }\r\n    return obj;\r\n}\r\n/**\r\n * Uses a global mutation observer to wait for a given element to appear in the\r\n * DOM.\r\n * @param childId - The id of the child node.\r\n * @param callback - The callback to call when the child node is found.\r\n *\r\n * @public\r\n */\r\nfunction whenAvailable(childId, callback) {\r\n    if (isBrowser) {\r\n        const el = document.getElementById(childId);\r\n        if (el)\r\n            return callback(el);\r\n        const observer = new MutationObserver(() => {\r\n            const el = document.getElementById(childId);\r\n            if (el) {\r\n                observer.disconnect();\r\n                callback(el);\r\n            }\r\n        });\r\n        observer.observe(document.body, { childList: true, subtree: true });\r\n    }\r\n}\r\n\r\nexport { assignDeep, camel, clone, cloneAny, dedupe, empty, eq, escapeExp, except, extend, getAt, has, init, isObject, isPojo, isQuotedString, isRecord, kebab, nodeProps, nodeType, only, parseArgs, regexForFormat, rmEscapes, setify, shallowClone, slugify, spread, token, undefine, whenAvailable };\r\n"],
  "mappings": ";AAOA,IAAM,YAAY,OAAO,WAAW;AAIpC,IAAM,eAAe;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACJ;AAiBA,SAAS,QAAQ;AACb,SAAO,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,GAAG,EAAE;AACrD;AAiCA,SAAS,OAAO,MAAM,MAAM;AACxB,QAAM,WAAW,gBAAgB,MAAM,OAAO,IAAI,IAAI,IAAI;AAC1D,MAAI;AACA,SAAK,QAAQ,CAAC,SAAS,SAAS,IAAI,IAAI,CAAC;AAC7C,SAAO,CAAC,GAAG,QAAQ;AACvB;AAWA,SAAS,IAAI,KAAK,UAAU;AACxB,SAAO,OAAO,UAAU,eAAe,KAAK,KAAK,QAAQ;AAC7D;AAaA,SAAS,GAAG,MACZ,MACA,OAAO,MAAM,WAAW,CAAC,OAAO,GAAG;AAC/B,MAAI,SAAS;AACT,WAAO;AACX,MAAI,OAAO,SAAS,YAAY,OAAO,SAAS,UAAU;AACtD,QAAI,gBAAgB;AAChB,aAAO;AACX,QAAI,gBAAgB;AAChB,aAAO;AACX,QAAI,gBAAgB;AAChB,aAAO;AACX,QAAI,SAAS,QAAQ,SAAS;AAC1B,aAAO;AACX,QAAI,OAAO,KAAK,IAAI,EAAE,WAAW,OAAO,KAAK,IAAI,EAAE;AAC/C,aAAO;AACX,eAAW,KAAK,UAAU;AACtB,WAAK,KAAK,QAAQ,KAAK,SAAS,KAAK,CAAC,MAAM,KAAK,CAAC;AAC9C,eAAO;AAAA,IACf;AACA,eAAW,OAAO,MAAM;AACpB,UAAI,EAAE,OAAO;AACT,eAAO;AACX,UAAI,KAAK,GAAG,MAAM,KAAK,GAAG,KAAK,CAAC;AAC5B,eAAO;AACX,UAAI,QAAQ,CAAC,GAAG,KAAK,GAAG,GAAG,KAAK,GAAG,GAAG,MAAM,QAAQ;AAChD,eAAO;AAAA,IACf;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAUA,SAAS,MAAM,OACb;AACE,QAAM,OAAO,OAAO;AACpB,MAAI,SAAS;AACT,WAAO;AACX,MAAI,UAAU;AACV,WAAO;AACX,MAAI,SAAS,UAAU;AACnB,WAAO,UAAU;AAAA,EACrB;AACA,MAAI,SAAS,UAAU;AACnB,QAAI,UAAU;AACV,aAAO;AACX,eAAW,MAAM;AACb,aAAO;AACX,QAAI,iBAAiB;AACjB,aAAO;AACX,QAAI,iBAAiB;AACjB,aAAO;AACX,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAUA,SAAS,UAAU,QAAQ;AAEvB,SAAO,OAAO,QAAQ,uBAAuB,MAAM;AACvD;AAgBA,SAAS,eAAe,QAAQ;AAC5B,QAAM,UAAU,IAAI,UAAU,MAAM;AACpC,QAAM,UAAU;AAAA,IACZ,IAAI;AAAA,IACJ,GAAG;AAAA,IACH,IAAI;AAAA,IACJ,GAAG;AAAA,IACH,MAAM;AAAA,IACN,IAAI;AAAA,EACR;AACA,QAAM,SAAS,OAAO,KAAK,OAAO;AAClC,SAAO,IAAI,OAAO,OAAO,OAAO,CAAC,OAAOA,YAAW;AAC/C,WAAO,MAAM,QAAQA,SAAQ,QAAQA,OAAM,CAAC;AAAA,EAChD,GAAG,OAAO,CAAC;AACf;AA4BA,SAAS,SAAS,GAAG;AACjB,SAAO,OAAO,UAAU,SAAS,KAAK,CAAC,MAAM;AACjD;AAUA,SAAS,SAAS,GAAG;AACjB,SAAO,SAAS,CAAC,KAAK,MAAM,QAAQ,CAAC;AACzC;AAaA,SAAS,OAAO,GAAG;AACf,MAAI,SAAS,CAAC,MAAM;AAChB,WAAO;AACX,MAAI,EAAE,cAAc,EAAE,aAAa;AAC/B,WAAO;AACX,QAAM,OAAO,EAAE;AACf,MAAI,SAAS;AACT,WAAO;AACX,QAAM,OAAO,KAAK;AAClB,MAAI,SAAS,IAAI,MAAM;AACnB,WAAO;AACX,MAAI,KAAK,eAAe,eAAe,MAAM,OAAO;AAChD,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAeA,SAAS,OAAO,UAAU,YAAY,eAAe,OAAO,kBAAkB,OAAO;AACjF,MAAI,eAAe;AACf,WAAO;AACX,QAAM,SAAS,CAAC;AAChB,MAAI,OAAO,eAAe;AACtB,WAAO;AACX,aAAW,OAAO,UAAU;AACxB,QAAI,IAAI,YAAY,GAAG,MAClB,WAAW,GAAG,MAAM,UAAa,CAAC,kBAAkB;AACrD,UAAI,gBACA,MAAM,QAAQ,SAAS,GAAG,CAAC,KAC3B,MAAM,QAAQ,WAAW,GAAG,CAAC,GAAG;AAChC,eAAO,GAAG,IAAI,SAAS,GAAG,EAAE,OAAO,WAAW,GAAG,CAAC;AAClD;AAAA,MACJ;AACA,UAAI,WAAW,GAAG,MAAM,QAAW;AAC/B;AAAA,MACJ;AACA,UAAI,OAAO,SAAS,GAAG,CAAC,KAAK,OAAO,WAAW,GAAG,CAAC,GAAG;AAClD,eAAO,GAAG,IAAI,OAAO,SAAS,GAAG,GAAG,WAAW,GAAG,GAAG,cAAc,eAAe;AAAA,MACtF,OACK;AACD,eAAO,GAAG,IAAI,WAAW,GAAG;AAAA,MAChC;AAAA,IACJ,OACK;AACD,aAAO,GAAG,IAAI,SAAS,GAAG;AAAA,IAC9B;AAAA,EACJ;AACA,aAAW,OAAO,YAAY;AAC1B,QAAI,CAAC,IAAI,QAAQ,GAAG,KAAK,WAAW,GAAG,MAAM,QAAW;AACpD,aAAO,GAAG,IAAI,WAAW,GAAG;AAAA,IAChC;AAAA,EACJ;AACA,SAAO;AACX;AAuBA,SAAS,eAAe,KAAK;AAEzB,MAAI,IAAI,CAAC,MAAM,OAAO,IAAI,CAAC,MAAM;AAC7B,WAAO;AACX,MAAI,IAAI,CAAC,MAAM,IAAI,IAAI,SAAS,CAAC;AAC7B,WAAO;AACX,QAAM,YAAY,IAAI,CAAC;AACvB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACjC,QAAI,IAAI,CAAC,MAAM,cACV,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,SAC3B,MAAM,IAAI,SAAS,GAAG;AACtB,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;AAUA,SAAS,UAAU,KAAK;AACpB,MAAI,CAAC,IAAI;AACL,WAAO;AACX,MAAI,QAAQ;AACZ,MAAI,WAAW;AACf,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACjC,UAAM,OAAO,IAAI,OAAO,CAAC;AACzB,QAAI,SAAS,QAAQ,aAAa,MAAM;AACpC,eAAS;AAAA,IACb;AACA,eAAW;AAAA,EACf;AACA,SAAO;AACX;AAuCA,SAAS,aAAa,MAAM;AACxB,SAAO,KAAK,OAAO,CAAC,OAAO,UAAU;AACjC,UAAM,EAAE,OAAO,MAAM,YAAY,QAAQ,SAAS,GAAG,WAAW,IAAI;AACpE,WAAO,OAAO,OAAO,OAAO,UAAU;AAAA,EAC1C,GAAG,CAAC,CAAC;AACT;AAUA,SAAS,UAAU,KAAK;AACpB,QAAM,OAAO,CAAC;AACd,MAAI,MAAM;AACV,MAAI,QAAQ;AACZ,MAAI,QAAQ;AACZ,MAAI,WAAW;AACf,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACjC,UAAM,OAAO,IAAI,OAAO,CAAC;AACzB,QAAI,SAAS,SAAS,aAAa,MAAM;AACrC,cAAQ;AAAA,IACZ,YACU,SAAS,OAAO,SAAS,QAAQ,CAAC,SAAS,aAAa,MAAM;AACpE,cAAQ;AAAA,IACZ,WACS,SAAS,OAAO,CAAC,OAAO;AAC7B;AAAA,IACJ,WACS,SAAS,OAAO,CAAC,OAAO;AAC7B;AAAA,IACJ;AACA,QAAI,SAAS,OAAO,CAAC,SAAS,UAAU,GAAG;AACvC,WAAK,KAAK,GAAG;AACb,YAAM;AAAA,IACV,WACS,SAAS,OAAO,OAAO;AAC5B,aAAO;AAAA,IACX;AACA,eAAW;AAAA,EACf;AACA,MAAI,KAAK;AACL,SAAK,KAAK,GAAG;AAAA,EACjB;AACA,SAAO;AACX;AAYA,SAAS,OAAO,KAAK,UAAU;AAC3B,QAAM,QAAQ,CAAC;AACf,QAAM,OAAO,SAAS,OAAO,CAAC,MAAM,aAAa,MAAM;AACvD,QAAM,eAAe,IAAI,IAAI,QAAQ;AACrC,aAAW,OAAO,KAAK;AACnB,QAAI,CAAC,aAAa,IAAI,GAAG,KAAK,CAAC,KAAK,KAAK,CAAC,QAAQ,IAAI,KAAK,GAAG,CAAC,GAAG;AAC9D,YAAM,GAAG,IAAI,IAAI,GAAG;AAAA,IACxB;AAAA,EACJ;AACA,SAAO;AACX;AAaA,SAAS,KAAK,KAAK,SAAS;AACxB,QAAM,QAAQ,CAAC;AACf,QAAM,OAAO,QAAQ,OAAO,CAAC,MAAM,aAAa,MAAM;AACtD,UAAQ,QAAQ,CAAC,QAAQ;AACrB,QAAI,EAAE,eAAe,SAAS;AAC1B,YAAM,GAAG,IAAI,IAAI,GAAG;AAAA,IACxB;AAAA,EACJ,CAAC;AACD,SAAO,KAAK,GAAG,EAAE,QAAQ,CAAC,QAAQ;AAC9B,QAAI,KAAK,KAAK,CAAC,QAAQ,IAAI,KAAK,GAAG,CAAC,GAAG;AACnC,YAAM,GAAG,IAAI,IAAI,GAAG;AAAA,IACxB;AAAA,EACJ,CAAC;AACD,SAAO;AACX;AAUA,SAAS,MAAM,KAAK;AAChB,SAAO,IAAI,QAAQ,iBAAiB,CAAC,IAAI,MAAM,EAAE,YAAY,CAAC;AAClE;AAUA,SAAS,MAAM,KAAK;AAChB,SAAO,IACF,QAAQ,sBAAsB,CAAC,IAAI,OAAO,QAAQ,QAAQ,MAAM,IAAI,YAAY,CAAC,EACjF,QAAQ,KAAK,GAAG,EAChB,YAAY;AACrB;AAWA,SAAS,aAAa,KAAK,WAAW,cAAc;AAChD,MAAI,QAAQ,QAAQ,OAAO,QAAQ,UAAU;AACzC,QAAI;AACJ,QAAI,MAAM,QAAQ,GAAG;AACjB,qBAAe,CAAC,GAAG,GAAG;AAAA,aACjB,OAAO,GAAG;AACf,qBAAe,EAAE,GAAG,IAAI;AAC5B,QAAI,cAAc;AACd,oBAAc,KAAK,cAAc,QAAQ;AACzC,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;AAYA,SAAS,MAAM,KAAK,WAAW,cAAc;AACzC,MAAI,QAAQ,QACR,eAAe,UACf,eAAe,QACf,eAAe,OACf,eAAe,OACd,OAAO,SAAS,cAAc,eAAe;AAC9C,WAAO;AACX,MAAI;AACJ,MAAI,MAAM,QAAQ,GAAG,GAAG;AACpB,mBAAe,IAAI,IAAI,CAAC,UAAU;AAC9B,UAAI,OAAO,UAAU;AACjB,eAAO,MAAM,OAAO,QAAQ;AAChC,aAAO;AAAA,IACX,CAAC;AAAA,EACL,OACK;AACD,mBAAe,OAAO,KAAK,GAAG,EAAE,OAAO,CAAC,QAAQ,QAAQ;AACpD,aAAO,GAAG,IACN,OAAO,IAAI,GAAG,MAAM,WACd,MAAM,IAAI,GAAG,GAAG,QAAQ,IACxB,IAAI,GAAG;AACjB,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AAAA,EACT;AACA,aAAW,OAAO,UAAU;AACxB,QAAI,OAAO,KAAK;AACZ,aAAO,eAAe,cAAc,KAAK;AAAA,QACrC,YAAY;AAAA,QACZ,OAAO,IAAI,GAAG;AAAA,MAClB,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO;AACX;AAWA,SAAS,SAAS,KAAK;AACnB,SAAO,OAAO,QAAQ,WAChB,MAAM,GAAG,IACT;AACV;AAYA,SAAS,MAAM,KAAK,MAAM;AACtB,MAAI,CAAC,OAAO,OAAO,QAAQ;AACvB,WAAO;AACX,QAAM,WAAW,KAAK,MAAM,GAAG;AAC/B,MAAI,IAAI;AACR,aAAW,KAAK,UAAU;AACtB,UAAM,UAAU,SAAS,CAAC;AAC1B,QAAI,IAAI,GAAG,OAAO,GAAG;AACjB,UAAI,EAAE,OAAO;AAAA,IACjB;AACA,QAAI,CAAC,MAAM,SAAS,SAAS;AACzB,aAAO;AACX,QAAI,CAAC,KAAK,OAAO,MAAM;AACnB,aAAO;AAAA,EACf;AACA,SAAO;AACX;AAaA,SAAS,SAAS,OAAO;AACrB,SAAO,UAAU,UAAa,UAAU,WAAW,UAAU,QACvD,OACA;AACV;AAWA,SAAS,KAAK,KAAK;AACf,SAAO,CAAC,OAAO,SAAS,GAAG,IACrB,OAAO,eAAe,KAAK,UAAU;AAAA,IACnC,YAAY;AAAA,IACZ,OAAO;AAAA,EACX,CAAC,IACC;AACV;AAUA,SAAS,QAAQ,KAAK;AAClB,SAAO,IACF,UAAU,KAAK,EACf,QAAQ,oBAAoB,EAAE,EAC9B,YAAY,EACZ,QAAQ,cAAc,GAAG,EACzB,KAAK,EACL,QAAQ,QAAQ,GAAG;AAC5B;AAyCA,SAAS,cAAc,UAAU,KAAK,UAAU;AAC5C,aAAW,OAAO,UAAU;AACxB,QAAI,OAAO,UAAU;AACjB,aAAO,eAAe,KAAK,KAAK;AAAA,QAC5B,YAAY;AAAA,QACZ,OAAO,SAAS,GAAG;AAAA,MACvB,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO;AACX;AASA,SAAS,cAAc,SAAS,UAAU;AACtC,MAAI,WAAW;AACX,UAAM,KAAK,SAAS,eAAe,OAAO;AAC1C,QAAI;AACA,aAAO,SAAS,EAAE;AACtB,UAAM,WAAW,IAAI,iBAAiB,MAAM;AACxC,YAAMC,MAAK,SAAS,eAAe,OAAO;AAC1C,UAAIA,KAAI;AACJ,iBAAS,WAAW;AACpB,iBAASA,GAAE;AAAA,MACf;AAAA,IACJ,CAAC;AACD,aAAS,QAAQ,SAAS,MAAM,EAAE,WAAW,MAAM,SAAS,KAAK,CAAC;AAAA,EACtE;AACJ;",
  "names": ["format", "el"]
}
