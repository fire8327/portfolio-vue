{
  "version": 3,
  "sources": ["../../@formkit/rules/dist/index.mjs", "../../@formkit/observer/dist/index.mjs", "../../@formkit/validation/dist/index.mjs", "../../@formkit/themes/dist/index.mjs", "../../@formkit/dev/dist/index.mjs", "../../@formkit/vue/dist/index.mjs"],
  "sourcesContent": ["import { has, regexForFormat, eq, empty } from '@formkit/utils';\r\n\r\n/**\r\n * Determine if the given input's value was should be considered \"accepted\".\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst accepted = function accepted({ value }) {\r\n    return ['yes', 'on', '1', 1, true, 'true'].includes(value);\r\n};\r\naccepted.skipEmpty = false;\r\n\r\n/**\r\n * Determine if the given input's value is after a given date.\r\n * Defaults to current time.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst date_after = function ({ value }, compare = false) {\r\n    const timestamp = Date.parse(compare || new Date());\r\n    const fieldValue = Date.parse(String(value));\r\n    return isNaN(fieldValue) ? false : fieldValue > timestamp;\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is only alpha characters.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst alpha = function ({ value }, set = 'default') {\r\n    const sets = {\r\n        default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćČčĎďĘęĚěŁłŃńŇňŘřŚśŠšŤťŮůŹźŻŽžż]+$/,\r\n        latin: /^[a-zA-Z]+$/,\r\n    };\r\n    const selectedSet = has(sets, set) ? set : 'default';\r\n    return sets[selectedSet].test(String(value));\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is only alpha characters.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst alpha_spaces = function ({ value }, set = 'default') {\r\n    const sets = {\r\n        default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćČčĎďĘęĚěŁłŃńŇňŘřŚśŠšŤťŮůŹźŻŽžż ]+$/,\r\n        latin: /^[a-zA-Z ]+$/,\r\n    };\r\n    const selectedSet = has(sets, set) ? set : 'default';\r\n    return sets[selectedSet].test(String(value));\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is only alpha or numeric characters.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst alphanumeric = function ({ value }, set = 'default') {\r\n    const sets = {\r\n        default: /^[a-zA-Z0-9À-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,\r\n        latin: /^[a-zA-Z0-9]+$/,\r\n    };\r\n    const selectedSet = has(sets, set) ? set : 'default';\r\n    return sets[selectedSet].test(String(value));\r\n};\r\n\r\n/**\r\n * Determine if the given input's value before a given date.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst date_before = function ({ value }, compare = false) {\r\n    const timestamp = Date.parse(compare || new Date());\r\n    const fieldValue = Date.parse(String(value));\r\n    return isNaN(fieldValue) ? false : fieldValue < timestamp;\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is between two other values.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst between = function between({ value }, from, to) {\r\n    if (!isNaN(value) && !isNaN(from) && !isNaN(to)) {\r\n        const val = 1 * value;\r\n        from = Number(from);\r\n        to = Number(to);\r\n        const [a, b] = from <= to ? [from, to] : [to, from];\r\n        return val >= 1 * a && val <= 1 * b;\r\n    }\r\n    return false;\r\n};\r\n\r\nconst hasConfirm = /(_confirm(?:ed)?)$/;\r\n/**\r\n * Determine if the given input's value matches another input's value\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst confirm = function confirm(node, address, comparison = 'loose') {\r\n    var _a;\r\n    if (!address) {\r\n        address = hasConfirm.test(node.name)\r\n            ? node.name.replace(hasConfirm, '')\r\n            : `${node.name}_confirm`;\r\n    }\r\n    const foreignValue = (_a = node.at(address)) === null || _a === void 0 ? void 0 : _a.value;\r\n    return comparison === 'strict'\r\n        ? node.value === foreignValue\r\n        : node.value == foreignValue;\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is between two other dates\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst date_between = function date_between({ value }, dateA, dateB) {\r\n    dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA);\r\n    dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB);\r\n    const compareTo = value instanceof Date ? value.getTime() : Date.parse(String(value));\r\n    if (dateA && !dateB) {\r\n        dateB = dateA;\r\n        dateA = Date.now();\r\n    }\r\n    else if (!dateA || !compareTo) {\r\n        return false;\r\n    }\r\n    return compareTo >= dateA && compareTo <= dateB;\r\n};\r\n\r\n/**\r\n * Determine if the given input's value matches a specified date format\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst date_format = function date({ value }, format) {\r\n    if (format && typeof format === 'string') {\r\n        return regexForFormat(format).test(String(value));\r\n    }\r\n    return !isNaN(Date.parse(String(value)));\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is a plausible email address.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst email = function email({ value }) {\r\n    const isEmail = /^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\r\n    return isEmail.test(String(value));\r\n};\r\n\r\n/**\r\n * Determine if the given input's value ends with a given string\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst ends_with = function ends_with({ value }, ...stack) {\r\n    if (typeof value === 'string' && stack.length) {\r\n        return stack.some((item) => {\r\n            return value.endsWith(item);\r\n        });\r\n    }\r\n    else if (typeof value === 'string' && stack.length === 0) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is in a set of possible values.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst is = function is({ value }, ...stack) {\r\n    return stack.some((item) => {\r\n        if (typeof item === 'object') {\r\n            return eq(item, value);\r\n        }\r\n        return item == value;\r\n    });\r\n};\r\n\r\n/**\r\n * Determine if the given input's value length is full width.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst length = function length({ value }, first = 0, second = Infinity) {\r\n    first = parseInt(first);\r\n    second = isNaN(parseInt(second)) ? Infinity : parseInt(second);\r\n    const min = first <= second ? first : second;\r\n    const max = second >= first ? second : first;\r\n    if (typeof value === 'string' || Array.isArray(value)) {\r\n        return value.length >= min && value.length <= max;\r\n    }\r\n    else if (value && typeof value === 'object') {\r\n        const length = Object.keys(value).length;\r\n        return length >= min && length <= max;\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Determine if the given input's value matches one or more values or regular expressions.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst matches = function matches({ value }, ...stack) {\r\n    return stack.some((pattern) => {\r\n        if (typeof pattern === 'string' &&\r\n            pattern.substr(0, 1) === '/' &&\r\n            pattern.substr(-1) === '/') {\r\n            pattern = new RegExp(pattern.substr(1, pattern.length - 2));\r\n        }\r\n        if (pattern instanceof RegExp) {\r\n            return pattern.test(String(value));\r\n        }\r\n        return pattern === value;\r\n    });\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is less than the maximum\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst max = function max({ value }, maximum = 10) {\r\n    if (Array.isArray(value)) {\r\n        return value.length <= maximum;\r\n    }\r\n    return Number(value) <= Number(maximum);\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is less than a certain value.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst min = function min({ value }, minimum = 1) {\r\n    if (Array.isArray(value)) {\r\n        return value.length >= minimum;\r\n    }\r\n    return Number(value) >= Number(minimum);\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is not in a given stack\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst not = function not({ value }, ...stack) {\r\n    return !stack.some((item) => {\r\n        if (typeof item === 'object') {\r\n            return eq(item, value);\r\n        }\r\n        return item === value;\r\n    });\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is numeric\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst number = function number({ value }) {\r\n    return !isNaN(value);\r\n};\r\n\r\n/**\r\n * Determine if the given input's value was required.\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst required = function required({ value }, action = 'default') {\r\n    return action === 'trim' && typeof value === 'string'\r\n        ? !empty(value.trim())\r\n        : !empty(value);\r\n};\r\n/**\r\n * This rules should run even if the inputs is empty (obviously)\r\n */\r\nrequired.skipEmpty = false;\r\n\r\n/**\r\n * Determine if the given input's value starts with a substring\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst starts_with = function starts_with({ value }, ...stack) {\r\n    if (typeof value === 'string' && stack.length) {\r\n        return stack.some((item) => {\r\n            return value.startsWith(item);\r\n        });\r\n    }\r\n    else if (typeof value === 'string' && stack.length === 0) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Determine if the given input's value is an http url\r\n * @param context - The FormKitValidationContext\r\n * @public\r\n */\r\nconst url = function url({ value }, ...stack) {\r\n    try {\r\n        const protocols = stack.length ? stack : ['http:', 'https:'];\r\n        const url = new URL(String(value));\r\n        return protocols.includes(url.protocol);\r\n    }\r\n    catch {\r\n        return false;\r\n    }\r\n};\r\n\r\nexport { accepted, alpha, alpha_spaces, alphanumeric, between, confirm, date_after, date_before, date_between, date_format, email, ends_with, is, length, matches, max, min, not, number, required, starts_with, url };\r\n", "import { has } from '@formkit/utils';\r\nimport { isNode } from '@formkit/core';\r\n\r\n/**\r\n * FormKit Observer is a utility to wrap a FormKitNode in a dependency tracking observer proxy.\r\n *\r\n * @packageDocumentation\r\n */\r\n/**\r\n * A registry of all revoked observers.\r\n */\r\nconst revokedObservers = new WeakSet();\r\n/**\r\n * Creates the observer.\r\n * @param node - The {@link @formkit/core#FormKitNode | FormKitNode} to observe.\r\n * @param dependencies - The dependent nodes and the events that are required to\r\n * watch for changes.\r\n * @returns Returns a {@link @formkit/observer#FormKitObservedNode | FormKitObservedNode}.\r\n * @public\r\n */\r\nfunction createObserver(node, dependencies) {\r\n    // The dependencies touched during tracking\r\n    const deps = dependencies || Object.assign(new Map(), { active: false });\r\n    // A registry of event receipts returned by the event system\r\n    const receipts = new Map();\r\n    /**\r\n     * Simple function to add a dependency to the deps map.\r\n     * @param event - The name of the event type (like commit/input etc)\r\n     */\r\n    const addDependency = function (event) {\r\n        var _a;\r\n        if (!deps.active)\r\n            return;\r\n        if (!deps.has(node))\r\n            deps.set(node, new Set());\r\n        (_a = deps.get(node)) === null || _a === void 0 ? void 0 : _a.add(event);\r\n    };\r\n    /**\r\n     * Proxies the props of a node so we know which ones were messed with, could\r\n     * potentially be more generalized in the future if we want to support\r\n     * more sub-objects.\r\n     * @param props - The props object from a node\r\n     * @returns\r\n     */\r\n    const observeProps = function (props) {\r\n        return new Proxy(props, {\r\n            get(...args) {\r\n                typeof args[1] === 'string' && addDependency(`prop:${args[1]}`);\r\n                return Reflect.get(...args);\r\n            },\r\n        });\r\n    };\r\n    /**\r\n     * Observes the FormKit ledger \"value\".\r\n     * @param ledger - A formkit ledger counter.\r\n     */\r\n    const observeLedger = function (ledger) {\r\n        return new Proxy(ledger, {\r\n            get(...args) {\r\n                if (args[1] === 'value') {\r\n                    return (key) => {\r\n                        addDependency(`count:${key}`);\r\n                        return ledger.value(key);\r\n                    };\r\n                }\r\n                return Reflect.get(...args);\r\n            },\r\n        });\r\n    };\r\n    /**\r\n     * Return values from our observer proxy first pass through this function\r\n     * which gives us a chance to listen sub-dependencies and properties.\r\n     */\r\n    const observe = function (value, property) {\r\n        if (isNode(value)) {\r\n            return createObserver(value, deps);\r\n        }\r\n        if (property === 'value')\r\n            addDependency('commit');\r\n        if (property === '_value')\r\n            addDependency('input');\r\n        if (property === 'props')\r\n            return observeProps(value);\r\n        if (property === 'ledger')\r\n            return observeLedger(value);\r\n        return value;\r\n    };\r\n    /**\r\n     * The actual proxy object of the original node.\r\n     */\r\n    const { proxy: observed, revoke, } = Proxy.revocable(node, {\r\n        get(...args) {\r\n            switch (args[1]) {\r\n                case '_node':\r\n                    return node;\r\n                case 'deps':\r\n                    return deps;\r\n                case 'watch':\r\n                    return (block, after) => watch(observed, block, after);\r\n                case 'observe':\r\n                    return () => {\r\n                        const old = new Map(deps);\r\n                        deps.clear();\r\n                        deps.active = true;\r\n                        return old;\r\n                    };\r\n                case 'stopObserve':\r\n                    return () => {\r\n                        const newDeps = new Map(deps);\r\n                        deps.active = false;\r\n                        return newDeps;\r\n                    };\r\n                case 'receipts':\r\n                    return receipts;\r\n                case 'kill':\r\n                    return () => {\r\n                        removeListeners(receipts);\r\n                        revokedObservers.add(args[2]);\r\n                        revoke();\r\n                        return undefined;\r\n                    };\r\n            }\r\n            const value = Reflect.get(...args);\r\n            // If we're dealing with a function, we need to sub-call the function\r\n            // get that return value, and pass it through the same logic.\r\n            if (typeof value === 'function') {\r\n                return (...subArgs) => {\r\n                    const subValue = value(...subArgs);\r\n                    return observe(subValue, args[1]);\r\n                };\r\n            }\r\n            return observe(value, args[1]);\r\n        },\r\n    });\r\n    return observed;\r\n}\r\n/**\r\n * Given two maps (`toAdd` and `toRemove`), apply the dependencies as event\r\n * listeners on the underlying nodes.\r\n * @param node - The node to apply dependencies to.\r\n * @param callback - The callback to add or remove.\r\n * @internal\r\n */\r\nfunction applyListeners(node, [toAdd, toRemove], callback) {\r\n    toAdd.forEach((events, depNode) => {\r\n        events.forEach((event) => {\r\n            var _a;\r\n            node.receipts.has(depNode) || node.receipts.set(depNode, {});\r\n            node.receipts.set(depNode, Object.assign((_a = node.receipts.get(depNode)) !== null && _a !== void 0 ? _a : {}, {\r\n                [event]: depNode.on(event, callback),\r\n            }));\r\n        });\r\n    });\r\n    toRemove.forEach((events, depNode) => {\r\n        events.forEach((event) => {\r\n            if (node.receipts.has(depNode)) {\r\n                const nodeReceipts = node.receipts.get(depNode);\r\n                if (nodeReceipts && has(nodeReceipts, event)) {\r\n                    depNode.off(nodeReceipts[event]);\r\n                    delete nodeReceipts[event];\r\n                    node.receipts.set(depNode, nodeReceipts);\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Remove all the receipts from the observed node and subtree.\r\n * @param receipts - The FormKit observer receipts to remove.\r\n * @public\r\n */\r\nfunction removeListeners(receipts) {\r\n    receipts.forEach((events, node) => {\r\n        for (const event in events) {\r\n            node.off(events[event]);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Observes a chunk of code to dependencies, and then re-calls that chunk of\r\n * code when those dependencies are manipulated.\r\n * @param node - The node to observer\r\n * @param block - The block of code to observe\r\n * @public\r\n */\r\nfunction watch(node, block, after) {\r\n    const doAfterObservation = (res) => {\r\n        const newDeps = node.stopObserve();\r\n        applyListeners(node, diffDeps(oldDeps, newDeps), () => watch(node, block, after));\r\n        if (after)\r\n            after(res);\r\n    };\r\n    const oldDeps = new Map(node.deps);\r\n    node.observe();\r\n    const res = block(node);\r\n    if (res instanceof Promise)\r\n        res.then((val) => doAfterObservation(val));\r\n    else\r\n        doAfterObservation(res);\r\n}\r\n/**\r\n * Determines which nodes should be added as dependencies and which should be\r\n * removed.\r\n * @param previous - The previous watcher dependencies.\r\n * @param current - The new/current watcher dependencies.\r\n * @returns A tuple of maps: `toAdd` and `toRemove`.\r\n * @public\r\n */\r\nfunction diffDeps(previous, current) {\r\n    const toAdd = new Map();\r\n    const toRemove = new Map();\r\n    current.forEach((events, node) => {\r\n        if (!previous.has(node)) {\r\n            toAdd.set(node, events);\r\n        }\r\n        else {\r\n            const eventsToAdd = new Set();\r\n            const previousEvents = previous.get(node);\r\n            events.forEach((event) => !(previousEvents === null || previousEvents === void 0 ? void 0 : previousEvents.has(event)) && eventsToAdd.add(event));\r\n            toAdd.set(node, eventsToAdd);\r\n        }\r\n    });\r\n    previous.forEach((events, node) => {\r\n        if (!current.has(node)) {\r\n            toRemove.set(node, events);\r\n        }\r\n        else {\r\n            const eventsToRemove = new Set();\r\n            const newEvents = current.get(node);\r\n            events.forEach((event) => !(newEvents === null || newEvents === void 0 ? void 0 : newEvents.has(event)) && eventsToRemove.add(event));\r\n            toRemove.set(node, eventsToRemove);\r\n        }\r\n    });\r\n    return [toAdd, toRemove];\r\n}\r\n/**\r\n * Checks if the given node is revoked.\r\n * @param node - Any observed node to check.\r\n * @returns A `boolean` indicating if the node is revoked.\r\n * @public\r\n */\r\nfunction isKilled(node) {\r\n    return revokedObservers.has(node);\r\n}\r\n\r\nexport { applyListeners, createObserver, diffDeps, isKilled, removeListeners };\r\n", "import { createMessage } from '@formkit/core';\r\nimport { createObserver, removeListeners, isKilled, applyListeners, diffDeps } from '@formkit/observer';\r\nimport { cloneAny, token, eq, empty, clone, has } from '@formkit/utils';\r\n\r\n/**\r\n * Message that gets set when the node is awaiting validation.\r\n */\r\nconst validatingMessage = createMessage({\r\n    type: 'state',\r\n    blocking: true,\r\n    visible: false,\r\n    value: true,\r\n    key: 'validating',\r\n});\r\n/**\r\n * The actual validation plugin function. Everything must be bootstrapped here.\r\n *\r\n * @param baseRules - Base validation rules to include in the plugin. By default,\r\n * FormKit makes all rules in the \\@formkit/rules package available via the\r\n * defaultConfig.\r\n *\r\n * @public\r\n */\r\nfunction createValidationPlugin(baseRules = {}) {\r\n    return function validationPlugin(node) {\r\n        let propRules = cloneAny(node.props.validationRules || {});\r\n        let availableRules = { ...baseRules, ...propRules };\r\n        // create an observed node\r\n        let observedNode = createObserver(node);\r\n        const state = { input: token(), rerun: null, isPassing: true };\r\n        let validation = cloneAny(node.props.validation);\r\n        // If the node's validation props change, reboot:\r\n        node.on('prop:validation', ({ payload }) => reboot(payload, availableRules));\r\n        node.on('prop:validationRules', ({ payload }) => reboot(validation, payload));\r\n        /**\r\n         * Reboots the validation using new rules or declarations/intents.\r\n         * @param newValidation - New validation declaration to use\r\n         * @param newRules - New validation rules to use\r\n         * @returns\r\n         */\r\n        function reboot(newValidation, newRules) {\r\n            var _a;\r\n            if (eq(Object.keys(propRules || {}), Object.keys(newRules || {})) &&\r\n                eq(validation, newValidation))\r\n                return;\r\n            propRules = cloneAny(newRules);\r\n            validation = cloneAny(newValidation);\r\n            availableRules = { ...baseRules, ...propRules };\r\n            // Destroy all observers that may re-trigger validation on an old stack\r\n            removeListeners(observedNode.receipts);\r\n            // Clear existing message observers\r\n            (_a = node.props.parsedRules) === null || _a === void 0 ? void 0 : _a.forEach((validation) => {\r\n                var _a;\r\n                validation.messageObserver = (_a = validation.messageObserver) === null || _a === void 0 ? void 0 : _a.kill();\r\n            });\r\n            // Remove all existing messages before re-validating\r\n            node.store.filter(() => false, 'validation');\r\n            node.props.parsedRules = parseRules(newValidation, availableRules);\r\n            observedNode.kill();\r\n            observedNode = createObserver(node);\r\n            validate(observedNode, node.props.parsedRules, state);\r\n        }\r\n        // Validate the field when this plugin is initialized\r\n        node.props.parsedRules = parseRules(validation, availableRules);\r\n        validate(observedNode, node.props.parsedRules, state);\r\n    };\r\n}\r\n/**\r\n * Given parsed validations, a value and a node, run the validations and set\r\n * the appropriate store messages on the node.\r\n * @param value - The value being validated\r\n * @param node - The Node this value belongs to\r\n * @param rules - The rules\r\n */\r\nfunction validate(node, validations, state) {\r\n    if (isKilled(node))\r\n        return;\r\n    state.input = token();\r\n    state.isPassing = true;\r\n    node.store.filter((message) => !message.meta.removeImmediately, 'validation');\r\n    validations.forEach((validation) => validation.debounce && clearTimeout(validation.timer));\r\n    if (validations.length) {\r\n        node.store.set(validatingMessage);\r\n        run(0, validations, node, state, false, () => {\r\n            node.store.remove(validatingMessage.key);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Runs validation rules recursively while collecting dependencies allowing for\r\n * cross-node validation rules that automatically re-trigger when a foreign\r\n * value is changed.\r\n * @param current - The index of the current validation rule\r\n * @param validations - The remaining validation rule stack to run\r\n * @param node - An observed node, the owner of this validation stack\r\n * @param state - An object of state information about this run\r\n * @param removeImmediately - Should messages created during this call be removed immediately when a new commit takes place?\r\n * @returns\r\n */\r\nfunction run(current, validations, node, state, removeImmediately, complete) {\r\n    const validation = validations[current];\r\n    if (!validation)\r\n        return complete();\r\n    const currentRun = state.input;\r\n    validation.state = null;\r\n    function next(async, result) {\r\n        state.isPassing = state.isPassing && !!result;\r\n        validation.queued = false;\r\n        const newDeps = node.stopObserve();\r\n        applyListeners(node, diffDeps(validation.deps, newDeps), () => {\r\n            validation.queued = true;\r\n            if (state.rerun)\r\n                clearTimeout(state.rerun);\r\n            state.rerun = setTimeout(validate, 0, node, validations, state);\r\n        });\r\n        validation.deps = newDeps;\r\n        if (state.input === currentRun) {\r\n            validation.state = result;\r\n            if (result === false) {\r\n                createFailedMessage(node, validation, removeImmediately || async);\r\n            }\r\n            else {\r\n                removeMessage(node, validation);\r\n            }\r\n            if (validations.length > current + 1) {\r\n                run(current + 1, validations, node, state, removeImmediately || async, complete);\r\n            }\r\n            else {\r\n                // The validation has completed\r\n                complete();\r\n            }\r\n        }\r\n    }\r\n    if ((!empty(node.value) || !validation.skipEmpty) &&\r\n        (state.isPassing || validation.force)) {\r\n        if (validation.queued) {\r\n            runRule(validation, node, (result) => {\r\n                result instanceof Promise\r\n                    ? result.then((r) => next(true, r))\r\n                    : next(false, result);\r\n            });\r\n        }\r\n        else {\r\n            // In this case our rule is not queued, so literally nothing happened that\r\n            // would affect it, we just need to move past this rule and make no\r\n            // modifications to state\r\n            run(current + 1, validations, node, state, removeImmediately, complete);\r\n        }\r\n    }\r\n    else {\r\n        // This rule is not being run because either:\r\n        //  1. The field is empty and this rule should not run when empty\r\n        //  2. A previous validation rule is failing and this one is not forced\r\n        // In this case we should call next validation.\r\n        if (empty(node.value) && validation.skipEmpty && state.isPassing) {\r\n            // This node has an empty value so its validation was skipped. So we\r\n            // need to queue it up, we do that by starting an observation and just\r\n            // touching the value attribute.\r\n            node.observe();\r\n            node.value;\r\n            // Because this validation rule is skipped when the node's value is empty\r\n            // so we keep the current value `state.isPassing` to the next rule execution\r\n            // if we pass null it will be typecasted to false and all following rules\r\n            // will be ignored including `required` rule which cause odds behavior\r\n            next(false, state.isPassing);\r\n        }\r\n        else {\r\n            next(false, null);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Run a validation rule debounced or not.\r\n * @param validation - A validation to debounce\r\n */\r\nfunction runRule(validation, node, after) {\r\n    if (validation.debounce) {\r\n        validation.timer = setTimeout(() => {\r\n            node.observe();\r\n            after(validation.rule(node, ...validation.args));\r\n        }, validation.debounce);\r\n    }\r\n    else {\r\n        node.observe();\r\n        after(validation.rule(node, ...validation.args));\r\n    }\r\n}\r\n/**\r\n * The messages given to this function have already been set on the node, but\r\n * any other validation messages on the node that are not included in this\r\n * stack should be removed because they have been resolved.\r\n * @param node - The node to operate on.\r\n * @param messages - A new stack of messages\r\n */\r\nfunction removeMessage(node, validation) {\r\n    const key = `rule_${validation.name}`;\r\n    if (validation.messageObserver) {\r\n        validation.messageObserver = validation.messageObserver.kill();\r\n    }\r\n    if (has(node.store, key)) {\r\n        node.store.remove(key);\r\n    }\r\n}\r\n/**\r\n *\r\n * @param value - The value that is failing\r\n * @param validation - The validation object\r\n */\r\nfunction createFailedMessage(node, validation, removeImmediately) {\r\n    if (isKilled(node))\r\n        return;\r\n    if (!validation.messageObserver) {\r\n        validation.messageObserver = createObserver(node._node);\r\n    }\r\n    validation.messageObserver.watch((node) => {\r\n        const i18nArgs = createI18nArgs(node, validation);\r\n        return i18nArgs;\r\n    }, (i18nArgs) => {\r\n        const customMessage = createCustomMessage(node, validation, i18nArgs);\r\n        // Here we short circuit the i18n system to force the output.\r\n        const message = createMessage({\r\n            blocking: validation.blocking,\r\n            key: `rule_${validation.name}`,\r\n            meta: {\r\n                /**\r\n                 * Use this key instead of the message root key to produce i18n validation\r\n                 * messages.\r\n                 */\r\n                messageKey: validation.name,\r\n                /**\r\n                 * For messages that were created *by or after* a debounced or async\r\n                 * validation rule — we make note of it so we can immediately remove them\r\n                 * as soon as the next commit happens.\r\n                 */\r\n                removeImmediately,\r\n                /**\r\n                 * Determines if this message should be passed to localization.\r\n                 */\r\n                localize: !customMessage,\r\n                /**\r\n                 * The arguments that will be passed to the validation rules\r\n                 */\r\n                i18nArgs,\r\n            },\r\n            type: 'validation',\r\n            value: customMessage || 'This field is not valid.',\r\n        });\r\n        node.store.set(message);\r\n    });\r\n}\r\n/**\r\n * Returns a custom validation message if applicable.\r\n * @param node - FormKit Node\r\n * @param validation - The validation rule being processed.\r\n */\r\nfunction createCustomMessage(node, validation, i18nArgs) {\r\n    const customMessage = node.props.validationMessages &&\r\n        has(node.props.validationMessages, validation.name)\r\n        ? node.props.validationMessages[validation.name]\r\n        : undefined;\r\n    if (typeof customMessage === 'function') {\r\n        return customMessage(...i18nArgs);\r\n    }\r\n    return customMessage;\r\n}\r\n/**\r\n * Creates the arguments passed to the i18n\r\n * @param node - The node that performed the validation\r\n * @param validation - The validation that failed\r\n */\r\nfunction createI18nArgs(node, validation) {\r\n    // If a custom message has been found, short circuit the i18n system.\r\n    return [\r\n        {\r\n            node,\r\n            name: createMessageName(node),\r\n            args: validation.args,\r\n        },\r\n    ];\r\n}\r\n/**\r\n * Given a node, this returns the name that should be used in validation\r\n * messages. This is either the `validationLabel` prop, the `label` prop, or\r\n * the name of the input (in that order).\r\n * @param node - The node to display\r\n * @returns\r\n * @public\r\n */\r\nfunction createMessageName(node) {\r\n    if (typeof node.props.validationLabel === 'function') {\r\n        return node.props.validationLabel(node);\r\n    }\r\n    return (node.props.validationLabel ||\r\n        node.props.label ||\r\n        node.props.name ||\r\n        String(node.name));\r\n}\r\n/**\r\n * Describes hints, must also be changed in the debounceExtractor.\r\n */\r\nconst hintPattern = '(?:[\\\\*+?()0-9]+)';\r\n/**\r\n * A pattern to describe rule names. Rules names can only contain letters,\r\n * numbers, and underscores and must start with a letter.\r\n */\r\nconst rulePattern = '[a-zA-Z][a-zA-Z0-9_]+';\r\n/**\r\n * Regular expression for extracting rule data.\r\n */\r\nconst ruleExtractor = new RegExp(`^(${hintPattern}?${rulePattern})(?:\\\\:(.*)+)?$`, 'i');\r\n/**\r\n * Validation hints are special characters preceding a validation rule, like\r\n * !phone\r\n */\r\nconst hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, 'i');\r\n/**\r\n * Given a hint string like ^(200)? or ^? or (200)?^ extract the hints to\r\n * matches.\r\n */\r\nconst debounceExtractor = /([\\*+?]+)?(\\(\\d+\\))([\\*+?]+)?/;\r\n/**\r\n * Determines if a given string is in the proper debounce format.\r\n */\r\nconst hasDebounce = /\\(\\d+\\)/;\r\n/**\r\n * The default values of the available validation hints.\r\n */\r\nconst defaultHints = {\r\n    blocking: true,\r\n    debounce: 0,\r\n    force: false,\r\n    skipEmpty: true,\r\n    name: '',\r\n};\r\n/**\r\n * Parse validation intents and strings into validation rule stacks.\r\n * @param validation - Either a string a validation rules, or proper array of structured rules.\r\n * @internal\r\n */\r\nfunction parseRules(validation, rules) {\r\n    if (!validation)\r\n        return [];\r\n    const intents = typeof validation === 'string'\r\n        ? extractRules(validation)\r\n        : clone(validation);\r\n    return intents.reduce((validations, args) => {\r\n        let rule = args.shift();\r\n        const hints = {};\r\n        if (typeof rule === 'string') {\r\n            const [ruleName, parsedHints] = parseHints(rule);\r\n            if (has(rules, ruleName)) {\r\n                rule = rules[ruleName];\r\n                Object.assign(hints, parsedHints);\r\n            }\r\n        }\r\n        if (typeof rule === 'function') {\r\n            validations.push({\r\n                rule,\r\n                args,\r\n                timer: 0,\r\n                state: null,\r\n                queued: true,\r\n                deps: new Map(),\r\n                ...defaultHints,\r\n                ...fnHints(hints, rule),\r\n            });\r\n        }\r\n        return validations;\r\n    }, []);\r\n}\r\n/**\r\n * A string of validation rules written in FormKitRule notation.\r\n * @param validation - The string of rules\r\n * @internal\r\n */\r\nfunction extractRules(validation) {\r\n    return validation.split('|').reduce((rules, rule) => {\r\n        const parsedRule = parseRule(rule);\r\n        if (parsedRule) {\r\n            rules.push(parsedRule);\r\n        }\r\n        return rules;\r\n    }, []);\r\n}\r\n/**\r\n * Given a rule like confirm:password_confirm produce a FormKitValidationIntent\r\n * @param rule - A string representing a validation rule.\r\n * @returns\r\n */\r\nfunction parseRule(rule) {\r\n    const trimmed = rule.trim();\r\n    if (trimmed) {\r\n        const matches = trimmed.match(ruleExtractor);\r\n        if (matches && typeof matches[1] === 'string') {\r\n            const ruleName = matches[1].trim();\r\n            const args = matches[2] && typeof matches[2] === 'string'\r\n                ? matches[2].split(',').map((s) => s.trim())\r\n                : [];\r\n            return [ruleName, ...args];\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Given a rule name, detect if there are any additional hints like !\r\n * @param ruleName - string representing a rule name\r\n * @returns\r\n */\r\nfunction parseHints(ruleName) {\r\n    const matches = ruleName.match(hintExtractor);\r\n    if (!matches) {\r\n        return [ruleName, { name: ruleName }];\r\n    }\r\n    const map = {\r\n        '*': { force: true },\r\n        '+': { skipEmpty: false },\r\n        '?': { blocking: false },\r\n    };\r\n    const [, hints, rule] = matches;\r\n    const hintGroups = hasDebounce.test(hints)\r\n        ? hints.match(debounceExtractor) || []\r\n        : [, hints];\r\n    return [\r\n        rule,\r\n        [hintGroups[1], hintGroups[2], hintGroups[3]].reduce((hints, group) => {\r\n            if (!group)\r\n                return hints;\r\n            if (hasDebounce.test(group)) {\r\n                hints.debounce = parseInt(group.substr(1, group.length - 1));\r\n            }\r\n            else {\r\n                group\r\n                    .split('')\r\n                    .forEach((hint) => has(map, hint) && Object.assign(hints, map[hint]));\r\n            }\r\n            return hints;\r\n        }, { name: rule }),\r\n    ];\r\n}\r\n/**\r\n * Extracts hint properties from the validation rule function itself and applies\r\n * them if they are not already in the set of validation hints extracted from\r\n * strings.\r\n * @param existingHints - An existing set of hints already parsed\r\n * @param rule - The actual rule function, which can contain hint properties\r\n * @returns\r\n */\r\nfunction fnHints(existingHints, rule) {\r\n    if (!existingHints.name) {\r\n        existingHints.name = rule.ruleName || rule.name;\r\n    }\r\n    return ['skipEmpty', 'force', 'debounce', 'blocking'].reduce((hints, hint) => {\r\n        if (has(rule, hint) && !has(hints, hint)) {\r\n            Object.assign(hints, {\r\n                [hint]: rule[hint],\r\n            });\r\n        }\r\n        return hints;\r\n    }, existingHints);\r\n}\r\n/**\r\n * Extracts all validation messages from the given node and all its descendants.\r\n * This is not reactive and must be re-called each time the messages change.\r\n * @param node - The FormKit node to extract validation rules from — as well as its descendants.\r\n * @public\r\n */\r\nfunction getValidationMessages(node) {\r\n    const messages = new Map();\r\n    const extract = (n) => {\r\n        const nodeMessages = [];\r\n        for (const key in n.store) {\r\n            const message = n.store[key];\r\n            if (message.type === 'validation' &&\r\n                message.blocking &&\r\n                message.visible &&\r\n                typeof message.value === 'string') {\r\n                nodeMessages.push(message);\r\n            }\r\n        }\r\n        if (nodeMessages.length) {\r\n            messages.set(n, nodeMessages);\r\n        }\r\n        return n;\r\n    };\r\n    extract(node).walk(extract);\r\n    return messages;\r\n}\r\n\r\nexport { createMessageName, createValidationPlugin, getValidationMessages };\r\n", "import { FORMKIT_VERSION } from '@formkit/core';\r\n\r\n/**\r\n * This package contains the official themes for FormKit. Read the\r\n * {@link https://formkit.com/getting-started/installation |\r\n * installation documentation} for more information.\r\n *\r\n * @packageDocumentation\r\n */\r\n/**\r\n * A function to generate FormKit class functions from a JavaScript object.\r\n * @param classes - An object of input types with nested objects of sectionKeys and class lists.\r\n * @returns An object of sectionKeys with class functions.\r\n * @public\r\n */\r\nfunction generateClasses(classes) {\r\n    const classesBySectionKey = {};\r\n    Object.keys(classes).forEach((type) => {\r\n        Object.keys(classes[type]).forEach((sectionKey) => {\r\n            if (!classesBySectionKey[sectionKey]) {\r\n                classesBySectionKey[sectionKey] = {\r\n                    [type]: classes[type][sectionKey],\r\n                };\r\n            }\r\n            else {\r\n                classesBySectionKey[sectionKey][type] = classes[type][sectionKey];\r\n            }\r\n        });\r\n    });\r\n    Object.keys(classesBySectionKey).forEach((sectionKey) => {\r\n        const classesObject = classesBySectionKey[sectionKey];\r\n        classesBySectionKey[sectionKey] = function (node, sectionKey) {\r\n            return addClassesBySection(node, sectionKey, classesObject);\r\n        };\r\n    });\r\n    return classesBySectionKey;\r\n}\r\n/**\r\n * Updates a class list for a given sectionKey\r\n * @param node - the FormKit node being operated on\r\n * @param sectionKey - The section key to which the class list will be applied\r\n * @param classByType - Object containing mappings of class lists to section keys\r\n * @returns\r\n * @public\r\n */\r\nfunction addClassesBySection(node, _sectionKey, classesByType) {\r\n    const type = node.props.type;\r\n    const family = node.props.family;\r\n    let classList = '';\r\n    if (classesByType.global) {\r\n        classList += classesByType.global + ' ';\r\n    }\r\n    if (classesByType[`family:${family}`]) {\r\n        classList += classesByType[`family:${family}`] + ' ';\r\n    }\r\n    if (classesByType[type]) {\r\n        classList += classesByType[type];\r\n    }\r\n    const listParts = classList.split('$reset');\r\n    if (listParts.length > 1) {\r\n        return `$reset ${listParts[listParts.length - 1].trim()}`;\r\n    }\r\n    return listParts[0].trim();\r\n}\r\n/**\r\n * The document's computed CSS styles\r\n */\r\nlet documentStyles = undefined;\r\nlet documentThemeLinkTag = null;\r\n/**\r\n * Stores the state of theme loading\r\n */\r\nlet themeDidLoad;\r\nlet themeHasLoaded = false;\r\nlet themeWasRequested = false;\r\nconst themeLoaded = new Promise((res) => {\r\n    themeDidLoad = () => {\r\n        themeHasLoaded = true;\r\n        res();\r\n    };\r\n});\r\n/**\r\n * Check if we are client-side\r\n */\r\nconst isClient = typeof window !== 'undefined' && typeof fetch !== 'undefined';\r\ndocumentStyles = isClient\r\n    ? getComputedStyle(document.documentElement)\r\n    : undefined;\r\n/**\r\n * The FormKit icon Registry - a global record of loaded icons.\r\n * @public\r\n */\r\nconst iconRegistry = {};\r\n/**\r\n * A collection of existing icon requests to avoid duplicate fetching\r\n */\r\nconst iconRequests = {};\r\n/**\r\n * Creates the theme plugin based on a given theme name.\r\n * @param theme - The name or id of the theme to apply.\r\n * @param icons - Icons you want to add to the global icon registry.\r\n * @param iconLoaderUrl - A function that returns a remote url for retrieving an\r\n * SVG icon by name.\r\n * @param iconLoader - A function that handles loading an icon when it is not\r\n * found in the registry.\r\n * @public\r\n */\r\nfunction createThemePlugin(theme, icons, iconLoaderUrl, iconLoader) {\r\n    if (icons) {\r\n        // add any user-provided icons to the registry\r\n        Object.assign(iconRegistry, icons);\r\n    }\r\n    // if we have a theme declared, request it\r\n    if (isClient &&\r\n        !themeWasRequested &&\r\n        (documentStyles === null || documentStyles === void 0 ? void 0 : documentStyles.getPropertyValue('--formkit-theme'))) {\r\n        // we have the theme loaded locally\r\n        themeDidLoad();\r\n        themeWasRequested = true;\r\n    }\r\n    else if (theme && !themeWasRequested && isClient) {\r\n        // we have the theme name but need to request it remotely\r\n        loadTheme(theme);\r\n    }\r\n    else if (!themeWasRequested && isClient) {\r\n        // we don't have a discoverable theme, so don't wait for it\r\n        themeDidLoad();\r\n    }\r\n    const themePlugin = function themePlugin(node) {\r\n        var _a, _b;\r\n        // register the icon handler, and override with local prop value if it exists\r\n        node.addProps(['iconLoader', 'iconLoaderUrl']);\r\n        node.props.iconHandler = createIconHandler(((_a = node.props) === null || _a === void 0 ? void 0 : _a.iconLoader) ? node.props.iconLoader : iconLoader, ((_b = node.props) === null || _b === void 0 ? void 0 : _b.iconLoaderUrl) ? node.props.iconLoaderUrl : iconLoaderUrl);\r\n        loadIconPropIcons(node, node.props.iconHandler);\r\n        node.on('created', () => {\r\n            var _a;\r\n            // set up the `-icon` click handlers\r\n            if ((_a = node === null || node === void 0 ? void 0 : node.context) === null || _a === void 0 ? void 0 : _a.handlers) {\r\n                node.context.handlers.iconClick = (sectionKey) => {\r\n                    const clickHandlerProp = `on${sectionKey\r\n                        .charAt(0)\r\n                        .toUpperCase()}${sectionKey.slice(1)}IconClick`;\r\n                    const handlerFunction = node.props[clickHandlerProp];\r\n                    if (handlerFunction && typeof handlerFunction === 'function') {\r\n                        return (e) => {\r\n                            return handlerFunction(node, e);\r\n                        };\r\n                    }\r\n                    return undefined;\r\n                };\r\n            }\r\n        });\r\n    };\r\n    themePlugin.iconHandler = createIconHandler(iconLoader, iconLoaderUrl);\r\n    return themePlugin;\r\n}\r\n/**\r\n * Loads a FormKit theme\r\n */\r\nfunction loadTheme(theme) {\r\n    if (!theme || !isClient || typeof getComputedStyle !== 'function') {\r\n        // if we're not client-side then bail\r\n        return;\r\n    }\r\n    // since we're client-side, flag that we've requested the theme\r\n    themeWasRequested = true;\r\n    documentThemeLinkTag = document.getElementById('formkit-theme');\r\n    // retrieve document styles on plugin creation when the window object exists\r\n    if (theme &&\r\n        // if we have a window object\r\n        isClient &&\r\n        // we don't have an existing theme OR the theme being set up is different\r\n        ((!(documentStyles === null || documentStyles === void 0 ? void 0 : documentStyles.getPropertyValue('--formkit-theme')) &&\r\n            !documentThemeLinkTag) ||\r\n            ((documentThemeLinkTag === null || documentThemeLinkTag === void 0 ? void 0 : documentThemeLinkTag.getAttribute('data-theme')) &&\r\n                (documentThemeLinkTag === null || documentThemeLinkTag === void 0 ? void 0 : documentThemeLinkTag.getAttribute('data-theme')) !== theme))) {\r\n        // if for some reason we didn't overwrite the __FKV__ token during publish\r\n        // then use the `latest` tag for CDN fetching. (this applies to local dev as well)\r\n        const formkitVersion = FORMKIT_VERSION.startsWith('__')\r\n            ? 'latest'\r\n            : FORMKIT_VERSION;\r\n        const themeUrl = `https://cdn.jsdelivr.net/npm/@formkit/themes@${formkitVersion}/dist/${theme}/theme.css`;\r\n        const link = document.createElement('link');\r\n        link.type = 'text/css';\r\n        link.rel = 'stylesheet';\r\n        link.id = 'formkit-theme';\r\n        link.setAttribute('data-theme', theme);\r\n        link.onload = () => {\r\n            documentStyles = getComputedStyle(document.documentElement); // grab new variables from theme\r\n            themeDidLoad();\r\n        };\r\n        document.head.appendChild(link);\r\n        link.href = themeUrl;\r\n        // if we had an existing theme being loaded, remove it.\r\n        if (documentThemeLinkTag) {\r\n            documentThemeLinkTag.remove();\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns a function responsible for loading an icon by name.\r\n * @param iconLoader - a function for loading an icon when it's not found in the\r\n * iconRegistry.\r\n * @param iconLoaderUrl - a function that returns a remote URL for retrieving an\r\n * SVG icon by name.\r\n * @public\r\n */\r\nfunction createIconHandler(iconLoader, iconLoaderUrl) {\r\n    return (iconName) => {\r\n        if (typeof iconName === 'boolean') {\r\n            return; // do nothing if we're dealing with a boolean\r\n        }\r\n        // if we're dealing with an inline SVG, just use it as-is\r\n        if (iconName.startsWith('<svg')) {\r\n            return iconName;\r\n        }\r\n        if (typeof iconName !== 'string')\r\n            return; // bail if we got something that wasn't a boolean or string\r\n        // is this a default icon that should only load from a stylesheet?\r\n        const isDefault = iconName.startsWith('default:');\r\n        iconName = isDefault ? iconName.split(':')[1] : iconName;\r\n        // check if we've already loaded the icon before\r\n        const iconWasAlreadyLoaded = iconName in iconRegistry;\r\n        let loadedIcon = undefined;\r\n        if (iconWasAlreadyLoaded) {\r\n            return iconRegistry[iconName];\r\n        }\r\n        else if (!iconRequests[iconName]) {\r\n            loadedIcon = getIconFromStylesheet(iconName);\r\n            loadedIcon =\r\n                isClient && typeof loadedIcon === 'undefined'\r\n                    ? Promise.resolve(loadedIcon)\r\n                    : loadedIcon;\r\n            if (loadedIcon instanceof Promise) {\r\n                iconRequests[iconName] = loadedIcon\r\n                    .then((iconValue) => {\r\n                    if (!iconValue && typeof iconName === 'string' && !isDefault) {\r\n                        return (loadedIcon =\r\n                            typeof iconLoader === 'function'\r\n                                ? iconLoader(iconName)\r\n                                : getRemoteIcon(iconName, iconLoaderUrl));\r\n                    }\r\n                    return iconValue;\r\n                })\r\n                    .then((finalIcon) => {\r\n                    if (typeof iconName === 'string') {\r\n                        iconRegistry[isDefault ? `default:${iconName}` : iconName] =\r\n                            finalIcon;\r\n                    }\r\n                    return finalIcon;\r\n                });\r\n            }\r\n            else if (typeof loadedIcon === 'string') {\r\n                iconRegistry[isDefault ? `default:${iconName}` : iconName] = loadedIcon;\r\n                return loadedIcon;\r\n            }\r\n        }\r\n        return iconRequests[iconName];\r\n    };\r\n}\r\nfunction getIconFromStylesheet(iconName) {\r\n    if (!isClient)\r\n        return;\r\n    if (themeHasLoaded) {\r\n        return loadStylesheetIcon(iconName);\r\n    }\r\n    else {\r\n        return themeLoaded.then(() => {\r\n            return loadStylesheetIcon(iconName);\r\n        });\r\n    }\r\n}\r\nfunction loadStylesheetIcon(iconName) {\r\n    const cssVarIcon = documentStyles === null || documentStyles === void 0 ? void 0 : documentStyles.getPropertyValue(`--fk-icon-${iconName}`);\r\n    if (cssVarIcon) {\r\n        // if we have a matching icon in the CSS properties, then decode it\r\n        const icon = atob(cssVarIcon);\r\n        if (icon.startsWith('<svg')) {\r\n            iconRegistry[iconName] = icon;\r\n            return icon;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n/**\r\n * Attempts to fetch a remote icon from the FormKit CDN\r\n * @param iconName - The string name of the icon\r\n * @public\r\n */\r\nfunction getRemoteIcon(iconName, iconLoaderUrl) {\r\n    const formkitVersion = FORMKIT_VERSION.startsWith('__')\r\n        ? 'latest'\r\n        : FORMKIT_VERSION;\r\n    const fetchUrl = typeof iconLoaderUrl === 'function'\r\n        ? iconLoaderUrl(iconName)\r\n        : `https://cdn.jsdelivr.net/npm/@formkit/icons@${formkitVersion}/dist/icons/${iconName}.svg`;\r\n    if (!isClient)\r\n        return undefined;\r\n    return fetch(`${fetchUrl}`)\r\n        .then(async (r) => {\r\n        const icon = await r.text();\r\n        if (icon.startsWith('<svg')) {\r\n            return icon;\r\n        }\r\n        return undefined;\r\n    })\r\n        .catch((e) => {\r\n        console.error(e);\r\n        return undefined;\r\n    });\r\n}\r\n/**\r\n * Loads icons for the matching `-icon` props on a given node\r\n */\r\nfunction loadIconPropIcons(node, iconHandler) {\r\n    const iconRegex = /^[a-zA-Z-]+(?:-icon|Icon)$/;\r\n    const iconProps = Object.keys(node.props).filter((prop) => {\r\n        return iconRegex.test(prop);\r\n    });\r\n    iconProps.forEach((sectionKey) => {\r\n        return loadPropIcon(node, iconHandler, sectionKey);\r\n    });\r\n}\r\n/**\r\n * Loads an icon from an icon-prop declaration eg. suffix-icon=\"settings\"\r\n */\r\nfunction loadPropIcon(node, iconHandler, sectionKey) {\r\n    const iconName = node.props[sectionKey];\r\n    const loadedIcon = iconHandler(iconName);\r\n    const rawIconProp = `_raw${sectionKey\r\n        .charAt(0)\r\n        .toUpperCase()}${sectionKey.slice(1)}`;\r\n    const clickHandlerProp = `on${sectionKey\r\n        .charAt(0)\r\n        .toUpperCase()}${sectionKey.slice(1)}Click`;\r\n    node.addProps([rawIconProp, clickHandlerProp]);\r\n    // listen for changes to the icon prop\r\n    node.on(`prop:${sectionKey}`, reloadIcon);\r\n    if (loadedIcon instanceof Promise) {\r\n        return loadedIcon.then((svg) => {\r\n            node.props[rawIconProp] = svg;\r\n        });\r\n    }\r\n    else {\r\n        node.props[rawIconProp] = loadedIcon;\r\n    }\r\n    return;\r\n}\r\n/**\r\n * reloads an icon when the prop value changes\r\n */\r\nfunction reloadIcon(event) {\r\n    var _a;\r\n    const node = event.origin;\r\n    const iconName = event.payload;\r\n    const iconHandler = (_a = node === null || node === void 0 ? void 0 : node.props) === null || _a === void 0 ? void 0 : _a.iconHandler;\r\n    const sectionKey = event.name.split(':')[1];\r\n    const rawIconProp = `_raw${sectionKey\r\n        .charAt(0)\r\n        .toUpperCase()}${sectionKey.slice(1)}`;\r\n    if (iconHandler && typeof iconHandler === 'function') {\r\n        const loadedIcon = iconHandler(iconName);\r\n        if (loadedIcon instanceof Promise) {\r\n            return loadedIcon.then((svg) => {\r\n                node.props[rawIconProp] = svg;\r\n            });\r\n        }\r\n        else {\r\n            node.props[rawIconProp] = loadedIcon;\r\n        }\r\n    }\r\n}\r\n\r\nexport { createIconHandler, createThemePlugin, generateClasses, iconRegistry };\r\n", "import { errorHandler, warningHandler } from '@formkit/core';\r\n\r\nlet registered = false;\r\n/**\r\n * Catalog of the error message codes in FormKit.\r\n * @public\r\n */\r\nconst errors = {\r\n    /**\r\n     * FormKit errors:\r\n     */\r\n    100: ({ data: node }) => `Only groups, lists, and forms can have children (${node.name}).`,\r\n    101: ({ data: node }) => `You cannot directly modify the store (${node.name}). See: https://formkit.com/advanced/core#message-store`,\r\n    102: ({ data: [node, property], }) => `You cannot directly assign node.${property} (${node.name})`,\r\n    103: ({ data: [operator] }) => `Schema expressions cannot start with an operator (${operator})`,\r\n    104: ({ data: [operator, expression] }) => `Schema expressions cannot end with an operator (${operator} in \"${expression}\")`,\r\n    105: ({ data: expression }) => `Invalid schema expression: ${expression}`,\r\n    106: ({ data: name }) => `Cannot submit because (${name}) is not in a form.`,\r\n    107: ({ data: [node, value] }) => `Cannot set ${node.name} to non object value: ${value}`,\r\n    108: ({ data: [node, value] }) => `Cannot set ${node.name} to non array value: ${value}`,\r\n    /**\r\n     * Input specific errors:\r\n     */\r\n    300: ({ data: [node] }) => `Cannot set behavior prop to overscroll (on ${node.name} input) when options prop is a function.`,\r\n    /**\r\n     * FormKit vue errors:\r\n     */\r\n    600: ({ data: node }) => `Unknown input type${typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''} (\"${node.name}\")`,\r\n    601: ({ data: node }) => `Input definition${typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''} is missing a schema or component property (${node.name}).`,\r\n};\r\n/**\r\n * Catalog of the warning message codes in FormKit.\r\n * @public\r\n */\r\nconst warnings = {\r\n    /**\r\n     * Core warnings:\r\n     */\r\n    150: ({ data: fn }) => `Schema function \"${fn}()\" is not a valid function.`,\r\n    151: ({ data: id }) => `No form element with id: ${id}`,\r\n    152: ({ data: id }) => `No input element with id: ${id}`,\r\n    /**\r\n     * Input specific warnings:\r\n     */\r\n    350: ({ data: node }) => `Invalid options prop for radio input (${node.name}). See https://formkit.com/inputs/radio`,\r\n    /**\r\n     * Vue warnings:\r\n     */\r\n    650: 'Schema \"$get()\" must use the id of an input to access.',\r\n    651: ({ data: id }) => `Cannot setErrors() on \"${id}\" because no such id exists.`,\r\n    652: ({ data: id }) => `Cannot clearErrors() on \"${id}\" because no such id exists.`,\r\n    /**\r\n     * Deprecation warnings:\r\n     */\r\n    800: ({ data: name }) => `${name} is deprecated.`,\r\n};\r\n/**\r\n * Decodes an error that is being emitted and console logs it.\r\n * @param error - The error currently being handled\r\n * @param next - Call additional handlers\r\n * @returns\r\n */\r\nconst decodeErrors = (error, next) => {\r\n    if (error.code in errors) {\r\n        const err = errors[error.code];\r\n        error.message = typeof err === 'function' ? err(error) : err;\r\n    }\r\n    return next(error);\r\n};\r\nif (!registered)\r\n    errorHandler(decodeErrors);\r\n/**\r\n * Decodes an error that is being emitted and console logs it.\r\n * @param error - The error currently being handled\r\n * @param next - Call additional handlers\r\n * @returns\r\n */\r\nconst decodeWarnings = (warning, next) => {\r\n    if (warning.code in warnings) {\r\n        const warn = warnings[warning.code];\r\n        warning.message = typeof warn === 'function' ? warn(warning) : warn;\r\n    }\r\n    return next(warning);\r\n};\r\nif (!registered)\r\n    warningHandler(decodeWarnings);\r\nregistered = true;\r\n\r\nexport { errors, warnings };\r\n", "import { warn, getNode, watchRegistry, isNode, sugar, isDOM, isComponent as isComponent$1, isConditional, compile, error, createConfig, clearErrors, setErrors, submitForm, reset, createNode, createMessage, createClasses, generateClassList } from '@formkit/core';\r\nexport { clearErrors, errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';\r\nimport { defineComponent, getCurrentInstance, watch, watchEffect, reactive, ref, isRef, createTextVNode, resolveComponent, h, isReactive, toRaw, inject, computed, provide, toRef, onBeforeUnmount, markRaw, nextTick, triggerRef } from 'vue';\r\nimport { has, isPojo, cloneAny, extend, camel, kebab, nodeProps, only, except, undefine, slugify, isObject, token, empty, eq, shallowClone } from '@formkit/utils';\r\nimport { createSection, useSchema, createLibraryPlugin, inputs } from '@formkit/inputs';\r\nimport * as defaultRules from '@formkit/rules';\r\nimport { createValidationPlugin } from '@formkit/validation';\r\nimport { createI18nPlugin, en } from '@formkit/i18n';\r\nimport { createThemePlugin, createIconHandler } from '@formkit/themes';\r\nimport { createObserver } from '@formkit/observer';\r\nimport '@formkit/dev';\r\n\r\n/**\r\n * A registry of memoized schemas (in JSON) to their respective render function\r\n * and provider registry.\r\n */\r\nconst memo = {};\r\n/**\r\n * This symbol represents the current component instance during render. It is\r\n * critical for linking the current instance to the data required for render.\r\n */\r\nlet instanceKey;\r\n/**\r\n * A registry of scoped data produced during runtime that is keyed by the\r\n * instance symbol. For example data from: for-loop instances and slot data.\r\n */\r\nconst instanceScopes = new Map();\r\n/**\r\n * Indicates the a section of the schema is raw.\r\n */\r\nconst raw = '__raw__';\r\n/**\r\n * Is a class prop.\r\n */\r\nconst isClassProp = /[a-zA-Z0-9\\-][cC]lass$/;\r\n/**\r\n * Returns a reference as a placeholder to a specific location on an object.\r\n * @param data - A reactive data object\r\n * @param token - A dot-syntax string representing the object path\r\n * @returns\r\n */\r\nfunction getRef(token, data) {\r\n    const value = ref(null);\r\n    if (token === 'get') {\r\n        const nodeRefs = {};\r\n        value.value = get$1.bind(null, nodeRefs);\r\n        return value;\r\n    }\r\n    const path = token.split('.');\r\n    watchEffect(() => {\r\n        value.value = getValue(isRef(data) ? data.value : data, path);\r\n    });\r\n    return value;\r\n}\r\n/**\r\n * Returns a value inside a set of data objects.\r\n * @param sets - An array of objects to search through\r\n * @param path - A array of string paths easily produced by split()\r\n * @returns\r\n */\r\nfunction getValue(set, path) {\r\n    if (Array.isArray(set)) {\r\n        for (const subset of set) {\r\n            const value = subset !== false && getValue(subset, path);\r\n            if (value !== undefined)\r\n                return value;\r\n        }\r\n        return undefined;\r\n    }\r\n    let foundValue = undefined;\r\n    let obj = set;\r\n    for (const i in path) {\r\n        const key = path[i];\r\n        if (typeof obj !== 'object' || obj === null) {\r\n            foundValue = undefined;\r\n            break;\r\n        }\r\n        const currentValue = obj[key];\r\n        if (Number(i) === path.length - 1 && currentValue !== undefined) {\r\n            // When the value is a function, we need to bind the `this` value\r\n            // before providing this back to the compiler.\r\n            foundValue =\r\n                typeof currentValue === 'function'\r\n                    ? currentValue.bind(obj)\r\n                    : currentValue;\r\n            break;\r\n        }\r\n        obj = currentValue;\r\n    }\r\n    return foundValue;\r\n}\r\n/**\r\n * Get the node from the global registry\r\n * @param id - A dot-syntax string where the node is located.\r\n */\r\nfunction get$1(nodeRefs, id) {\r\n    if (typeof id !== 'string')\r\n        return warn(650);\r\n    if (!(id in nodeRefs))\r\n        nodeRefs[id] = ref(undefined);\r\n    if (nodeRefs[id].value === undefined) {\r\n        nodeRefs[id].value = null;\r\n        const root = getNode(id);\r\n        if (root)\r\n            nodeRefs[id].value = root.context;\r\n        watchRegistry(id, ({ payload: node }) => {\r\n            nodeRefs[id].value = isNode(node) ? node.context : node;\r\n        });\r\n    }\r\n    return nodeRefs[id].value;\r\n}\r\n/**\r\n *\r\n * @param library - A library of concrete components to use\r\n * @param schema -\r\n * @returns\r\n */\r\nfunction parseSchema(library, schema) {\r\n    /**\r\n     * Given an if/then/else schema node, pre-compile the node and return the\r\n     * artifacts for the render function.\r\n     * @param data - The schema context object\r\n     * @param library - The available components\r\n     * @param node - The node to parse\r\n     */\r\n    function parseCondition(library, node) {\r\n        const condition = provider(compile(node.if), { if: true });\r\n        const children = createElements(library, node.then);\r\n        const alternate = node.else ? createElements(library, node.else) : null;\r\n        return [condition, children, alternate];\r\n    }\r\n    /**\r\n     * Parses a conditional if/then/else attribute statement.\r\n     * @param data - The data object\r\n     * @param attr - The attribute\r\n     * @param _default - The default value\r\n     * @returns\r\n     */\r\n    function parseConditionAttr(attr, _default) {\r\n        var _a, _b;\r\n        const condition = provider(compile(attr.if));\r\n        let b = () => _default;\r\n        let a = () => _default;\r\n        if (typeof attr.then === 'object') {\r\n            a = parseAttrs(attr.then, undefined);\r\n        }\r\n        else if (typeof attr.then === 'string' && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith('$'))) {\r\n            a = provider(compile(attr.then));\r\n        }\r\n        else {\r\n            a = () => attr.then;\r\n        }\r\n        if (has(attr, 'else')) {\r\n            if (typeof attr.else === 'object') {\r\n                b = parseAttrs(attr.else);\r\n            }\r\n            else if (typeof attr.else === 'string' && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith('$'))) {\r\n                b = provider(compile(attr.else));\r\n            }\r\n            else {\r\n                b = () => attr.else;\r\n            }\r\n        }\r\n        return () => (condition() ? a() : b());\r\n    }\r\n    /**\r\n     * Parse attributes for dynamic content.\r\n     * @param attrs - Object of attributes\r\n     * @returns\r\n     */\r\n    function parseAttrs(unparsedAttrs, bindExp, _default = {}) {\r\n        const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));\r\n        const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});\r\n        const setters = [\r\n            (attrs) => {\r\n                const bound = boundAttrs();\r\n                for (const attr in bound) {\r\n                    if (!explicitAttrs.has(attr)) {\r\n                        attrs[attr] = bound[attr];\r\n                    }\r\n                }\r\n            },\r\n        ];\r\n        if (unparsedAttrs) {\r\n            if (isConditional(unparsedAttrs)) {\r\n                // This is a root conditional object that must produce an object of\r\n                // attributes.\r\n                const condition = parseConditionAttr(unparsedAttrs, _default);\r\n                return condition;\r\n            }\r\n            // Some attributes are explicitly bound, we need to parse those ones\r\n            // using the compiler and create a dynamic \"setter\".\r\n            for (let attr in unparsedAttrs) {\r\n                const value = unparsedAttrs[attr];\r\n                let getValue;\r\n                const isStr = typeof value === 'string';\r\n                if (attr.startsWith(raw)) {\r\n                    // attributes prefixed with __raw__ should not be parsed\r\n                    attr = attr.substring(7);\r\n                    getValue = () => value;\r\n                }\r\n                else if (isStr &&\r\n                    value.startsWith('$') &&\r\n                    value.length > 1 &&\r\n                    !(value.startsWith('$reset') && isClassProp.test(attr))) {\r\n                    // Most attribute values starting with $ should be compiled\r\n                    // -class attributes starting with `$reset` should not be compiled\r\n                    getValue = provider(compile(value));\r\n                }\r\n                else if (typeof value === 'object' && isConditional(value)) {\r\n                    // Conditional attrs require further processing\r\n                    getValue = parseConditionAttr(value, undefined);\r\n                }\r\n                else if (typeof value === 'object' && isPojo(value)) {\r\n                    // Sub-parse pojos\r\n                    getValue = parseAttrs(value);\r\n                }\r\n                else {\r\n                    // In all other cases, the value is static\r\n                    getValue = () => value;\r\n                }\r\n                setters.push((attrs) => {\r\n                    attrs[attr] = getValue();\r\n                });\r\n            }\r\n        }\r\n        return () => {\r\n            const attrs = Array.isArray(unparsedAttrs) ? [] : {};\r\n            setters.forEach((setter) => setter(attrs));\r\n            return attrs;\r\n        };\r\n    }\r\n    /**\r\n     * Given a single schema node, parse it and extract the value.\r\n     * @param data - A state object provided to each node\r\n     * @param node - The schema node being parsed\r\n     * @returns\r\n     */\r\n    function parseNode(library, _node) {\r\n        let element = null;\r\n        let attrs = () => null;\r\n        let condition = false;\r\n        let children = null;\r\n        let alternate = null;\r\n        let iterator = null;\r\n        let resolve = false;\r\n        const node = sugar(_node);\r\n        if (isDOM(node)) {\r\n            // This is an actual HTML DOM element\r\n            element = node.$el;\r\n            attrs =\r\n                node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null;\r\n        }\r\n        else if (isComponent$1(node)) {\r\n            // This is a Vue Component\r\n            if (typeof node.$cmp === 'string') {\r\n                if (has(library, node.$cmp)) {\r\n                    element = library[node.$cmp];\r\n                }\r\n                else {\r\n                    element = node.$cmp;\r\n                    resolve = true;\r\n                }\r\n            }\r\n            else {\r\n                // in this case it must be an actual component\r\n                element = node.$cmp;\r\n            }\r\n            attrs = parseAttrs(node.props, node.bind);\r\n        }\r\n        else if (isConditional(node)) {\r\n            [condition, children, alternate] = parseCondition(library, node);\r\n        }\r\n        // This is the same as a \"v-if\" statement — not an if/else statement\r\n        if (!isConditional(node) && 'if' in node) {\r\n            condition = provider(compile(node.if));\r\n        }\r\n        else if (!isConditional(node) && element === null) {\r\n            // In this odd case our element is actually a partial and\r\n            // we only want to render the children.\r\n            condition = () => true;\r\n        }\r\n        // Compile children down to a function\r\n        if ('children' in node && node.children) {\r\n            if (typeof node.children === 'string') {\r\n                // We are dealing with a raw string value\r\n                if (node.children.startsWith('$slots.')) {\r\n                    // this is a lone text node, turn it into a slot\r\n                    element = element === 'text' ? 'slot' : element;\r\n                    children = provider(compile(node.children));\r\n                }\r\n                else if (node.children.startsWith('$') && node.children.length > 1) {\r\n                    const value = provider(compile(node.children));\r\n                    children = () => String(value());\r\n                }\r\n                else {\r\n                    children = () => String(node.children);\r\n                }\r\n            }\r\n            else if (Array.isArray(node.children)) {\r\n                // We are dealing with node sub-children\r\n                children = createElements(library, node.children);\r\n            }\r\n            else {\r\n                // This is a conditional if/else clause\r\n                const [childCondition, c, a] = parseCondition(library, node.children);\r\n                children = (iterationData) => childCondition && childCondition()\r\n                    ? c && c(iterationData)\r\n                    : a && a(iterationData);\r\n            }\r\n        }\r\n        if (isComponent$1(node)) {\r\n            if (children) {\r\n                // Children of components need to be provided as an object of slots\r\n                // so we provide an object with the default slot provided as children.\r\n                // We also create a new scope for this default slot, and then on each\r\n                // render pass the scoped slot props to the scope.\r\n                const produceChildren = children;\r\n                children = (iterationData) => {\r\n                    return {\r\n                        default(slotData, key) {\r\n                            var _a, _b, _c, _d;\r\n                            // We need to switch the current instance key back to the one that\r\n                            // originally called this component's render function.\r\n                            const currentKey = instanceKey;\r\n                            if (key)\r\n                                instanceKey = key;\r\n                            if (slotData)\r\n                                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData);\r\n                            if (iterationData)\r\n                                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);\r\n                            const c = produceChildren(iterationData);\r\n                            // Ensure our instance key never changed during runtime\r\n                            if (slotData)\r\n                                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();\r\n                            if (iterationData)\r\n                                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();\r\n                            instanceKey = currentKey;\r\n                            return c;\r\n                        },\r\n                    };\r\n                };\r\n                children.slot = true;\r\n            }\r\n            else {\r\n                // If we dont have any children, we still need to provide an object\r\n                // instead of an empty array (which raises a warning in vue)\r\n                children = () => ({});\r\n            }\r\n        }\r\n        // Compile the for loop down\r\n        if ('for' in node && node.for) {\r\n            const values = node.for.length === 3 ? node.for[2] : node.for[1];\r\n            const getValues = typeof values === 'string' && values.startsWith('$')\r\n                ? provider(compile(values))\r\n                : () => values;\r\n            iterator = [\r\n                getValues,\r\n                node.for[0],\r\n                node.for.length === 3 ? String(node.for[1]) : null,\r\n            ];\r\n        }\r\n        return [condition, element, attrs, children, alternate, iterator, resolve];\r\n    }\r\n    /**\r\n     * Given a particular function that produces children, ensure that the second\r\n     * argument of all these slots is the original instance key being used to\r\n     * render the slots.\r\n     * @param children - The children() function that will produce slots\r\n     */\r\n    function createSlots(children, iterationData) {\r\n        const slots = children(iterationData);\r\n        const currentKey = instanceKey;\r\n        return Object.keys(slots).reduce((allSlots, slotName) => {\r\n            const slotFn = slots && slots[slotName];\r\n            allSlots[slotName] = (data) => {\r\n                return (slotFn && slotFn(data, currentKey)) || null;\r\n            };\r\n            return allSlots;\r\n        }, {});\r\n    }\r\n    /**\r\n     * Creates an element\r\n     * @param data - The context data available to the node\r\n     * @param node - The schema node to render\r\n     * @returns\r\n     */\r\n    function createElement(library, node) {\r\n        // Parses the schema node into pertinent parts\r\n        const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library, node);\r\n        // This is a sub-render function (called within a render function). It must\r\n        // only use pre-compiled features, and be organized in the most efficient\r\n        // manner possible.\r\n        let createNodes = ((iterationData) => {\r\n            if (condition && element === null && children) {\r\n                // Handle conditional if/then statements\r\n                return condition()\r\n                    ? children(iterationData)\r\n                    : alternate && alternate(iterationData);\r\n            }\r\n            if (element && (!condition || condition())) {\r\n                // handle text nodes\r\n                if (element === 'text' && children) {\r\n                    return createTextVNode(String(children()));\r\n                }\r\n                // Handle lone slots\r\n                if (element === 'slot' && children)\r\n                    return children(iterationData);\r\n                // Handle resolving components\r\n                const el = resolve ? resolveComponent(element) : element;\r\n                // If we are rendering slots as children, ensure their instanceKey is properly added\r\n                const slots = (children === null || children === void 0 ? void 0 : children.slot)\r\n                    ? createSlots(children, iterationData)\r\n                    : null;\r\n                // Handle dom elements and components\r\n                return h(el, attrs(), (slots || (children ? children(iterationData) : [])));\r\n            }\r\n            return typeof alternate === 'function'\r\n                ? alternate(iterationData)\r\n                : alternate;\r\n        });\r\n        if (iterator) {\r\n            const repeatedNode = createNodes;\r\n            const [getValues, valueName, keyName] = iterator;\r\n            createNodes = (() => {\r\n                const _v = getValues();\r\n                const values = !isNaN(_v)\r\n                    ? Array(Number(_v))\r\n                        .fill(0)\r\n                        .map((_, i) => i)\r\n                    : _v;\r\n                const fragment = [];\r\n                if (typeof values !== 'object')\r\n                    return null;\r\n                const instanceScope = instanceScopes.get(instanceKey) || [];\r\n                const isArray = Array.isArray(values);\r\n                for (const key in values) {\r\n                    if (isArray && key in Array.prototype)\r\n                        continue; // Fix #299\r\n                    const iterationData = Object.defineProperty({\r\n                        ...instanceScope.reduce((previousIterationData, scopedData) => {\r\n                            if (previousIterationData.__idata) {\r\n                                return { ...previousIterationData, ...scopedData };\r\n                            }\r\n                            return scopedData;\r\n                        }, {}),\r\n                        [valueName]: values[key],\r\n                        ...(keyName !== null\r\n                            ? { [keyName]: isArray ? Number(key) : key }\r\n                            : {}),\r\n                    }, '__idata', { enumerable: false, value: true });\r\n                    instanceScope.unshift(iterationData);\r\n                    fragment.push(repeatedNode.bind(null, iterationData)());\r\n                    instanceScope.shift();\r\n                }\r\n                return fragment;\r\n            });\r\n        }\r\n        return createNodes;\r\n    }\r\n    /**\r\n     * Given a schema, parse it and return the resulting renderable nodes.\r\n     * @param data - The schema context object\r\n     * @param library - The available components\r\n     * @param node - The node to parse\r\n     * @returns\r\n     */\r\n    function createElements(library, schema) {\r\n        if (Array.isArray(schema)) {\r\n            const els = schema.map(createElement.bind(null, library));\r\n            return (iterationData) => els.map((element) => element(iterationData));\r\n        }\r\n        // Single node to render\r\n        const element = createElement(library, schema);\r\n        return (iterationData) => element(iterationData);\r\n    }\r\n    /**\r\n     * Data providers produced as a result of the compiler.\r\n     */\r\n    const providers = [];\r\n    /**\r\n     * Append the requisite compiler provider and return the compiled function.\r\n     * @param compiled - A compiled function\r\n     * @returns\r\n     */\r\n    function provider(compiled, hints = {}) {\r\n        const compiledFns = {};\r\n        providers.push((callback, key) => {\r\n            compiledFns[key] = compiled.provide((tokens) => callback(tokens, hints));\r\n        });\r\n        return () => compiledFns[instanceKey]();\r\n    }\r\n    /**\r\n     * Creates a new instance of a given schema — this either comes from a\r\n     * memoized copy of the parsed schema or a freshly parsed version. An symbol\r\n     * instance key, and dataProvider functions are passed in.\r\n     * @param providerCallback - A function that is called for each required provider\r\n     * @param key - a symbol representing the current instance\r\n     */\r\n    return function createInstance(providerCallback, key) {\r\n        const memoKey = JSON.stringify(schema);\r\n        const [render, compiledProviders] = has(memo, memoKey)\r\n            ? memo[memoKey]\r\n            : [createElements(library, schema), providers];\r\n        memo[memoKey] = [render, compiledProviders];\r\n        compiledProviders.forEach((compiledProvider) => {\r\n            compiledProvider(providerCallback, key);\r\n        });\r\n        return () => {\r\n            instanceKey = key;\r\n            return render();\r\n        };\r\n    };\r\n}\r\n/**\r\n * Checks the current runtime scope for data.\r\n * @param token - The token to lookup in the current scope\r\n * @param defaultValue - The default ref value to use if no scope is found.\r\n */\r\nfunction useScope(token, defaultValue) {\r\n    const scopedData = instanceScopes.get(instanceKey) || [];\r\n    let scopedValue = undefined;\r\n    if (scopedData.length) {\r\n        scopedValue = getValue(scopedData, token.split('.'));\r\n    }\r\n    return scopedValue === undefined ? defaultValue : scopedValue;\r\n}\r\n/**\r\n * Get the current scoped data and flatten it.\r\n */\r\nfunction slotData(data, key) {\r\n    return new Proxy(data, {\r\n        get(...args) {\r\n            let data = undefined;\r\n            const property = args[1];\r\n            if (typeof property === 'string') {\r\n                const prevKey = instanceKey;\r\n                instanceKey = key;\r\n                data = useScope(property, undefined);\r\n                instanceKey = prevKey;\r\n            }\r\n            return data !== undefined ? data : Reflect.get(...args);\r\n        },\r\n    });\r\n}\r\n/**\r\n * Provides data to a parsed schema.\r\n * @param provider - The SchemaProvider (output of calling parseSchema)\r\n * @param data - Data to fetch values from\r\n * @returns\r\n */\r\nfunction createRenderFn(instanceCreator, data, instanceKey) {\r\n    return instanceCreator((requirements, hints = {}) => {\r\n        return requirements.reduce((tokens, token) => {\r\n            if (token.startsWith('slots.')) {\r\n                const slot = token.substring(6);\r\n                const hasSlot = () => data.slots &&\r\n                    has(data.slots, slot) &&\r\n                    typeof data.slots[slot] === 'function';\r\n                if (hints.if) {\r\n                    // If statement — dont render the slot, check if it exists\r\n                    tokens[token] = hasSlot;\r\n                }\r\n                else if (data.slots) {\r\n                    // Render the slot with current scope data\r\n                    const scopedData = slotData(data, instanceKey);\r\n                    tokens[token] = () => hasSlot() ? data.slots[slot](scopedData) : null;\r\n                }\r\n            }\r\n            else {\r\n                const value = getRef(token, data);\r\n                tokens[token] = () => useScope(token, value.value);\r\n            }\r\n            return tokens;\r\n        }, {});\r\n    }, instanceKey);\r\n}\r\nlet i = 0;\r\n/**\r\n * The FormKitSchema vue component:\r\n *\r\n * @public\r\n */\r\nconst FormKitSchema = defineComponent({\r\n    name: 'FormKitSchema',\r\n    props: {\r\n        schema: {\r\n            type: [Array, Object],\r\n            required: true,\r\n        },\r\n        data: {\r\n            type: Object,\r\n            default: () => ({}),\r\n        },\r\n        library: {\r\n            type: Object,\r\n            default: () => ({}),\r\n        },\r\n    },\r\n    setup(props, context) {\r\n        const instance = getCurrentInstance();\r\n        let instanceKey = Symbol(String(i++));\r\n        instanceScopes.set(instanceKey, []);\r\n        let provider = parseSchema(props.library, props.schema);\r\n        let render;\r\n        let data;\r\n        // Re-parse the schema if it changes:\r\n        watch(() => props.schema, (newSchema, oldSchema) => {\r\n            var _a;\r\n            instanceKey = Symbol(String(i++));\r\n            provider = parseSchema(props.library, props.schema);\r\n            render = createRenderFn(provider, data, instanceKey);\r\n            if (newSchema === oldSchema) {\r\n                ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();\r\n            }\r\n        }, { deep: true });\r\n        // Watch the data object explicitly\r\n        watchEffect(() => {\r\n            data = Object.assign(reactive(props.data), {\r\n                slots: context.slots,\r\n            });\r\n            render = createRenderFn(provider, data, instanceKey);\r\n        });\r\n        return () => render();\r\n    },\r\n});\r\n\r\n/**\r\n * All the explicit FormKit props.\r\n */\r\nconst nativeProps = {\r\n    config: {\r\n        type: Object,\r\n        default: {},\r\n    },\r\n    classes: {\r\n        type: Object,\r\n        required: false,\r\n    },\r\n    delay: {\r\n        type: Number,\r\n        required: false,\r\n    },\r\n    errors: {\r\n        type: Array,\r\n        default: [],\r\n    },\r\n    inputErrors: {\r\n        type: Object,\r\n        default: () => ({}),\r\n    },\r\n    index: {\r\n        type: Number,\r\n        required: false,\r\n    },\r\n    id: {\r\n        type: String,\r\n        required: false,\r\n    },\r\n    modelValue: {\r\n        required: false,\r\n    },\r\n    name: {\r\n        type: String,\r\n        required: false,\r\n    },\r\n    parent: {\r\n        type: Object,\r\n        required: false,\r\n    },\r\n    plugins: {\r\n        type: Array,\r\n        default: [],\r\n    },\r\n    sectionsSchema: {\r\n        type: Object,\r\n        default: {},\r\n    },\r\n    type: {\r\n        type: [String, Object],\r\n        default: 'text',\r\n    },\r\n    validation: {\r\n        type: [String, Array],\r\n        required: false,\r\n    },\r\n    validationMessages: {\r\n        type: Object,\r\n        required: false,\r\n    },\r\n    validationRules: {\r\n        type: Object,\r\n        required: false,\r\n    },\r\n    validationLabel: {\r\n        type: [String, Function],\r\n        required: false,\r\n    },\r\n};\r\n/**\r\n * The FormKit props object.\r\n * @internal\r\n */\r\nconst props = nativeProps;\r\n\r\n/**\r\n * The symbol that represents the formkit parent injection value.\r\n *\r\n * @public\r\n */\r\nconst parentSymbol = Symbol('FormKitParent');\r\n/**\r\n * The root FormKit component.\r\n *\r\n * @public\r\n */\r\nconst FormKit = defineComponent({\r\n    props,\r\n    emits: {\r\n        /* eslint-disable @typescript-eslint/no-unused-vars */\r\n        input: (_value, _node) => true,\r\n        inputRaw: (_value, _node) => true,\r\n        'update:modelValue': (_value) => true,\r\n        node: (node) => !!node,\r\n        submit: (_data, _node) => true,\r\n        submitRaw: (_event, _node) => true,\r\n        submitInvalid: (_node) => true,\r\n        /* eslint-enable @typescript-eslint/no-unused-vars */\r\n    },\r\n    inheritAttrs: false,\r\n    setup(props, context) {\r\n        const node = useInput(props, context);\r\n        if (!node.props.definition)\r\n            error(600, node);\r\n        if (node.props.definition.component) {\r\n            return () => {\r\n                var _a;\r\n                return h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {\r\n                    context: node.context,\r\n                }, { ...context.slots });\r\n            };\r\n        }\r\n        const schema = ref([]);\r\n        const generateSchema = () => {\r\n            var _a, _b;\r\n            const schemaDefinition = (_b = (_a = node.props) === null || _a === void 0 ? void 0 : _a.definition) === null || _b === void 0 ? void 0 : _b.schema;\r\n            if (!schemaDefinition)\r\n                error(601, node);\r\n            schema.value =\r\n                typeof schemaDefinition === 'function'\r\n                    ? schemaDefinition({ ...props.sectionsSchema })\r\n                    : schemaDefinition;\r\n        };\r\n        generateSchema();\r\n        // If someone emits the schema event, we re-generate the schema\r\n        node.on('schema', generateSchema);\r\n        context.emit('node', node);\r\n        const library = node.props.definition.library;\r\n        // Expose the FormKitNode to template refs.\r\n        context.expose({ node });\r\n        return () => h(FormKitSchema, { schema: schema.value, data: node.context, library }, { ...context.slots });\r\n    },\r\n});\r\n\r\n/**\r\n * The Create a new instance of the FormKit plugin for Vue.\r\n *\r\n * @param app - A Vue application\r\n * @param config - FormKit Vue plugin configuration options\r\n *\r\n * @internal\r\n */\r\nfunction createPlugin(app, options) {\r\n    app\r\n        .component(options.alias || 'FormKit', FormKit)\r\n        .component(options.schemaAlias || 'FormKitSchema', FormKitSchema);\r\n    return {\r\n        get: getNode,\r\n        setLocale: (locale) => {\r\n            var _a;\r\n            if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {\r\n                options.config.rootConfig.locale = locale;\r\n            }\r\n        },\r\n        clearErrors,\r\n        setErrors,\r\n        submit: submitForm,\r\n        reset,\r\n    };\r\n}\r\n/**\r\n * The symbol key for accessing the FormKit node options.\r\n *\r\n * @public\r\n */\r\nconst optionsSymbol = Symbol.for('FormKitOptions');\r\n/**\r\n * The symbol key for accessing FormKit root configuration.\r\n *\r\n * @public\r\n */\r\nconst configSymbol = Symbol.for('FormKitConfig');\r\n/**\r\n * Create the FormKit plugin.\r\n *\r\n * @public\r\n */\r\nconst plugin = {\r\n    install(app, _options) {\r\n        /**\r\n         * Extend the default configuration options.\r\n         */\r\n        const options = Object.assign({\r\n            alias: 'FormKit',\r\n            schemaAlias: 'FormKitSchema',\r\n        }, typeof _options === 'function' ? _options() : _options);\r\n        /**\r\n         * The root configuration options.\r\n         */\r\n        const rootConfig = createConfig(options.config || {});\r\n        /**\r\n         * We dont want to explicitly provide any \"config\" options, only a root\r\n         * config option — so here we override the existing config options.\r\n         */\r\n        options.config = { rootConfig };\r\n        /**\r\n         * Register the global $formkit plugin property.\r\n         */\r\n        app.config.globalProperties.$formkit = createPlugin(app, options);\r\n        /**\r\n         * Provide the config to the application for injection.\r\n         */\r\n        app.provide(optionsSymbol, options);\r\n        /**\r\n         * Provide the root config to the application.\r\n         */\r\n        app.provide(configSymbol, rootConfig);\r\n    },\r\n};\r\n\r\n/**\r\n * Indicates that the path that was requested is no longer valid in the object.\r\n */\r\nconst invalidGet = Symbol();\r\n/**\r\n * A special watcher for Vue that reports the location of a deep mutation.\r\n *\r\n * @param obj - An object to observe at depth.\r\n * @param callback - A callback to call when a change is detected.\r\n *\r\n * @public\r\n */\r\nfunction watchVerbose(obj, callback) {\r\n    const watchers = {};\r\n    const applyWatch = (paths) => {\r\n        // Watch each property\r\n        for (const path of paths) {\r\n            // Stops pre-existing watchers at a given location to prevent dupes:\r\n            if (path.__str in watchers)\r\n                watchers[path.__str]();\r\n            watchers[path.__str] = watch(touch.bind(null, obj, path), dispatcher.bind(null, path), { deep: false });\r\n        }\r\n    };\r\n    /**\r\n     * Clear any watchers deeper than this path.\r\n     * @param path - The path to start from\r\n     */\r\n    const clearWatch = (path) => {\r\n        if (!path.length)\r\n            return;\r\n        for (const key in watchers) {\r\n            if (`${key}`.startsWith(`${path.__str}.`)) {\r\n                watchers[key]();\r\n                delete watchers[key];\r\n            }\r\n        }\r\n    };\r\n    const dispatcher = createDispatcher(obj, callback, applyWatch, clearWatch);\r\n    applyWatch(getPaths(obj));\r\n}\r\n/**\r\n * This function synchronously dispatches to the watch callbacks. It uses the\r\n * knowledge that the getPath function is a depth-first-search thus lower\r\n * specificity (lower tree nodes) will always have their watchers called first.\r\n * If a lower specificity watcher is triggered we want to ignore the higher\r\n * specificity watcher.\r\n * @param obj - The object to dispatch\r\n * @param callback - The callback function to emit\r\n * @param applyWatch - A way to apply watchers to update objects\r\n * @returns\r\n */\r\nfunction createDispatcher(obj, callback, applyWatch, clearChildWatches) {\r\n    // let dispatchedPaths: Record<string, ObjectPath> = {}\r\n    // let clear: Promise<void> | null = null\r\n    return (path) => {\r\n        const value = get(obj, path);\r\n        if (value === invalidGet)\r\n            return;\r\n        if (path.__deep)\r\n            clearChildWatches(path);\r\n        if (typeof value === 'object')\r\n            applyWatch(getPaths(value, [path], ...path));\r\n        callback(path, value, obj);\r\n    };\r\n}\r\n/**\r\n * \"Touches\" a given property for reactivity tracking purposes, if the value at\r\n * the given path is an object, we flatten it to just its keys since we will\r\n * already be tracking sub properties independently.\r\n * @param obj - A ref to traverse for a given path\r\n * @param path - An array of strings representing the path to locate\r\n * @returns\r\n */\r\nfunction touch(obj, path) {\r\n    const value = get(obj, path);\r\n    return value && typeof value === 'object' ? Object.keys(value) : value;\r\n}\r\n/**\r\n * \"Touches\" a given property for reactivity tracking purposes.\r\n * @param obj - A ref to traverse for a given path\r\n * @param path - An array of strings representing the path to locate\r\n * @returns\r\n */\r\nfunction get(obj, path) {\r\n    if (isRef(obj)) {\r\n        if (path.length === 0)\r\n            return obj.value;\r\n        obj = obj.value;\r\n    }\r\n    return path.reduce((value, segment) => {\r\n        if (value === invalidGet)\r\n            return value;\r\n        if (value === null || typeof value !== 'object') {\r\n            return invalidGet;\r\n        }\r\n        return value[segment];\r\n    }, obj);\r\n}\r\n/**\r\n * Recursively retrieves all enumerable property paths from the origination\r\n * object. For example:\r\n * ```js\r\n * const obj = {\r\n *   a: {\r\n *     b: 123\r\n *   },\r\n *   c: 567\r\n * }\r\n * const paths = getPaths(obj)\r\n * // [\r\n * //   ['a'],\r\n * //   ['a', 'b'],\r\n * //   ['c']\r\n * // ]\r\n * ```\r\n * @param obj - An object to retrieve paths for.\r\n * @param parents - An array of parent paths.\r\n * @returns\r\n * @internal\r\n */\r\nfunction getPaths(obj, paths = [], ...parents) {\r\n    if (obj === null)\r\n        return paths;\r\n    if (!parents.length) {\r\n        const path = Object.defineProperty([], '__str', {\r\n            value: '',\r\n        });\r\n        obj = isRef(obj) ? obj.value : obj;\r\n        if (obj && typeof obj === 'object') {\r\n            Object.defineProperty(path, '__deep', { value: true });\r\n            paths.push(path);\r\n        }\r\n        else {\r\n            return [path];\r\n        }\r\n    }\r\n    if (obj === null || typeof obj !== 'object')\r\n        return paths;\r\n    for (const key in obj) {\r\n        const path = parents.concat(key);\r\n        Object.defineProperty(path, '__str', { value: path.join('.') });\r\n        const value = obj[key];\r\n        if (isPojo(value) || Array.isArray(value)) {\r\n            paths.push(Object.defineProperty(path, '__deep', { value: true }));\r\n            paths = paths.concat(getPaths(value, [], ...path));\r\n        }\r\n        else {\r\n            paths.push(path);\r\n        }\r\n    }\r\n    return paths;\r\n}\r\n\r\n/**\r\n * Gets the raw underlying target object from a Vue Ref or Reactive object.\r\n * @param obj - Get the underlying target object, or no-op.\r\n * @returns\r\n */\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction useRaw(obj) {\r\n    if (obj === null || typeof obj !== 'object')\r\n        return obj;\r\n    if (isReactive(obj)) {\r\n        obj = toRaw(obj);\r\n    }\r\n    else if (isRef(obj)) {\r\n        obj = (isReactive(obj.value) ? useRaw(obj.value) : obj.value);\r\n    }\r\n    return obj;\r\n}\r\n\r\n/**\r\n * Props that are extracted from the attrs object.\r\n * TODO: Currently local, this should probably exported to a inputs or another\r\n * package.\r\n */\r\nconst pseudoProps = [\r\n    'help',\r\n    'label',\r\n    'ignore',\r\n    'disabled',\r\n    'preserve',\r\n    /^preserve(-e|E)rrors/,\r\n    /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/,\r\n    /^[a-zA-Z-]+(?:-class|Class)$/,\r\n    'prefixIcon',\r\n    'suffixIcon',\r\n    /^[a-zA-Z-]+(?:-icon|Icon)$/,\r\n];\r\n/**\r\n * Given some props, map those props to individualized props internally.\r\n * @param node - A formkit node\r\n * @param props - Some props that may include a classes object\r\n */\r\nfunction classesToNodeProps(node, props) {\r\n    if (props.classes) {\r\n        Object.keys(props.classes).forEach((key) => {\r\n            if (typeof key === 'string') {\r\n                node.props[`_${key}Class`] = props.classes[key];\r\n                // We need to ensure Vue is aware that we want to actually observe the\r\n                // child values too, so we touch them here.\r\n                if (isObject(props.classes[key]) && key === 'inner')\r\n                    Object.values(props.classes[key]);\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Extracts known FormKit listeners.\r\n * @param props - Extract known FormKit listeners.\r\n * @returns\r\n */\r\nfunction onlyListeners(props) {\r\n    if (!props)\r\n        return {};\r\n    const knownListeners = ['Submit', 'SubmitRaw', 'SubmitInvalid'].reduce((listeners, listener) => {\r\n        const name = `on${listener}`;\r\n        if (name in props) {\r\n            if (typeof props[name] === 'function') {\r\n                listeners[name] = props[name];\r\n            }\r\n        }\r\n        return listeners;\r\n    }, {});\r\n    return knownListeners;\r\n}\r\n/**\r\n * A composable for creating a new FormKit node.\r\n *\r\n * @param type - The type of node (input, group, list)\r\n * @param attrs - The FormKit \"props\" — which is really the attrs list.\r\n *\r\n * @returns {@link @formkit/core#FormKitNode | FormKitNode}\r\n *\r\n * @public\r\n */\r\nfunction useInput(props, context, options = {}) {\r\n    var _a;\r\n    /**\r\n     * The configuration options, these are provided by either the plugin or by\r\n     * explicit props.\r\n     */\r\n    const config = Object.assign({}, inject(optionsSymbol) || {}, options);\r\n    /**\r\n     * The current instance.\r\n     */\r\n    const instance = getCurrentInstance();\r\n    /**\r\n     * Extracts the listeners.\r\n     */\r\n    const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);\r\n    /**\r\n     * Determines if the prop is v-modeled. Credit to:\r\n     * {@link https://github.com/LinusBorg | Thorsten Lünborg}\r\n     * for coming up with this solution.\r\n     */\r\n    const isVModeled = 'modelValue' in ((_a = instance === null || instance === void 0 ? void 0 : instance.vnode.props) !== null && _a !== void 0 ? _a : {});\r\n    /**\r\n     * Determines if the object being passed as a v-model is reactive.\r\n     */\r\n    // const isReactiveVModel = isVModeled && isReactive(props.modelValue)\r\n    /**\r\n     * Define the initial component\r\n     */\r\n    const value = props.modelValue !== undefined\r\n        ? props.modelValue\r\n        : cloneAny(context.attrs.value);\r\n    /**\r\n     * Creates the node's initial props from the context, props, and definition\r\n     * @returns\r\n     */\r\n    function createInitialProps() {\r\n        const initialProps = {\r\n            ...nodeProps(props),\r\n            ...listeners,\r\n        };\r\n        const attrs = except(nodeProps(context.attrs), pseudoProps);\r\n        if (!attrs.key)\r\n            attrs.key = token();\r\n        initialProps.attrs = attrs;\r\n        const propValues = only(nodeProps(context.attrs), pseudoProps);\r\n        for (const propName in propValues) {\r\n            initialProps[camel(propName)] = propValues[propName];\r\n        }\r\n        const classesProps = { props: {} };\r\n        classesToNodeProps(classesProps, props);\r\n        Object.assign(initialProps, classesProps.props);\r\n        if (typeof initialProps.type !== 'string') {\r\n            initialProps.definition = initialProps.type;\r\n            delete initialProps.type;\r\n        }\r\n        return initialProps;\r\n    }\r\n    /**\r\n     * Create the FormKitNode.\r\n     */\r\n    const initialProps = createInitialProps();\r\n    /**\r\n     * The parent node.\r\n     */\r\n    const parent = initialProps.ignore\r\n        ? null\r\n        : props.parent || inject(parentSymbol, null);\r\n    const node = createNode(extend(config || {}, {\r\n        name: props.name || undefined,\r\n        value,\r\n        parent,\r\n        plugins: (config.plugins || []).concat(props.plugins),\r\n        config: props.config,\r\n        props: initialProps,\r\n        index: props.index,\r\n    }, false, true));\r\n    /**\r\n     * If no definition has been assigned at this point — we're out!\r\n     */\r\n    if (!node.props.definition)\r\n        error(600, node);\r\n    /**\r\n     * All props that are bound \"late\" (after node creation) — are added to a set\r\n     * which is used to watch the context.attrs object.\r\n     */\r\n    const lateBoundProps = ref(new Set(node.props.definition.props || []));\r\n    /**\r\n     * Any additional props added at a \"later\" time should also be part of the\r\n     * late bound props.\r\n     */\r\n    node.on('added-props', ({ payload: lateProps }) => {\r\n        if (Array.isArray(lateProps))\r\n            lateProps.forEach((newProp) => lateBoundProps.value.add(newProp));\r\n    });\r\n    /**\r\n     * These prop names must be assigned.\r\n     */\r\n    const pseudoPropNames = computed(() => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\r\n        if (typeof prop === 'string') {\r\n            names.push(camel(prop));\r\n            names.push(kebab(prop));\r\n        }\r\n        else {\r\n            names.push(prop);\r\n        }\r\n        return names;\r\n    }, []));\r\n    /* Splits Classes object into discrete props for each key */\r\n    watchEffect(() => classesToNodeProps(node, props));\r\n    /**\r\n     * The props object already has properties even if they start as \"undefined\"\r\n     * so we can loop over them and individual watchEffect to prevent responding\r\n     * inappropriately.\r\n     */\r\n    const passThrough = nodeProps(props);\r\n    for (const prop in passThrough) {\r\n        watch(() => props[prop], () => {\r\n            if (props[prop] !== undefined) {\r\n                node.props[prop] = props[prop];\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Watch \"pseudoProp\" attributes explicitly.\r\n     */\r\n    const attributeWatchers = new Set();\r\n    const possibleProps = nodeProps(context.attrs);\r\n    watchEffect(() => {\r\n        watchAttributes(only(possibleProps, pseudoPropNames.value));\r\n    });\r\n    /**\r\n     * Defines attributes that should be used as props.\r\n     * @param attrProps - Attributes that should be used as props instead\r\n     */\r\n    function watchAttributes(attrProps) {\r\n        attributeWatchers.forEach((stop) => {\r\n            stop();\r\n            attributeWatchers.delete(stop);\r\n        });\r\n        for (const prop in attrProps) {\r\n            const camelName = camel(prop);\r\n            attributeWatchers.add(watch(() => context.attrs[prop], () => {\r\n                node.props[camelName] = context.attrs[prop];\r\n            }));\r\n        }\r\n    }\r\n    /**\r\n     * Watch and dynamically set attribute values, those values that are not\r\n     * props and are not pseudoProps\r\n     */\r\n    watchEffect(() => {\r\n        const attrs = except(nodeProps(context.attrs), pseudoPropNames.value);\r\n        // An explicit exception to ensure naked \"multiple\" attributes appear on the\r\n        // outer wrapper as data-multiple=\"true\"\r\n        if ('multiple' in attrs)\r\n            attrs.multiple = undefine(attrs.multiple);\r\n        node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);\r\n    });\r\n    /**\r\n     * Add any/all \"prop\" errors to the store.\r\n     */\r\n    watchEffect(() => {\r\n        const messages = props.errors.map((error) => createMessage({\r\n            key: slugify(error),\r\n            type: 'error',\r\n            value: error,\r\n            meta: { source: 'prop' },\r\n        }));\r\n        node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === 'prop');\r\n    });\r\n    /**\r\n     * Add input errors.\r\n     */\r\n    if (node.type !== 'input') {\r\n        const sourceKey = `${node.name}-prop`;\r\n        watchEffect(() => {\r\n            const keys = Object.keys(props.inputErrors);\r\n            if (!keys.length)\r\n                node.clearErrors(true, sourceKey);\r\n            const messages = keys.reduce((messages, key) => {\r\n                let value = props.inputErrors[key];\r\n                if (typeof value === 'string')\r\n                    value = [value];\r\n                if (Array.isArray(value)) {\r\n                    messages[key] = value.map((error) => createMessage({\r\n                        key: error,\r\n                        type: 'error',\r\n                        value: error,\r\n                        meta: { source: sourceKey },\r\n                    }));\r\n                }\r\n                return messages;\r\n            }, {});\r\n            node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === sourceKey);\r\n        });\r\n    }\r\n    /**\r\n     * Watch the config prop for any changes.\r\n     */\r\n    watchEffect(() => Object.assign(node.config, props.config));\r\n    /**\r\n     * Produce another parent object.\r\n     */\r\n    if (node.type !== 'input') {\r\n        provide(parentSymbol, node);\r\n    }\r\n    let inputTimeout;\r\n    // eslint-disable-next-line @typescript-eslint/ban-types\r\n    const mutex = new WeakSet();\r\n    /**\r\n     * Explicitly watch the input value, and emit changes (lazy)\r\n     */\r\n    node.on('modelUpdated', () => {\r\n        var _a, _b;\r\n        // Emit the values after commit\r\n        context.emit('inputRaw', (_a = node.context) === null || _a === void 0 ? void 0 : _a.value, node);\r\n        clearTimeout(inputTimeout);\r\n        inputTimeout = setTimeout(context.emit, 20, 'input', (_b = node.context) === null || _b === void 0 ? void 0 : _b.value, node);\r\n        if (isVModeled && node.context) {\r\n            const newValue = useRaw(node.context.value);\r\n            if (isObject(newValue) && useRaw(props.modelValue) !== newValue) {\r\n                // If this is an object that has been mutated inside FormKit core then\r\n                // we know when it is emitted it will \"return\" in the watchVerbose so\r\n                // we pro-actively add it to the mutex.\r\n                mutex.add(newValue);\r\n            }\r\n            context.emit('update:modelValue', newValue);\r\n        }\r\n    });\r\n    /**\r\n     * Enabled support for v-model, using this for groups/lists is not recommended\r\n     */\r\n    if (isVModeled) {\r\n        watchVerbose(toRef(props, 'modelValue'), (path, value) => {\r\n            var _a;\r\n            const rawValue = useRaw(value);\r\n            if (isObject(rawValue) && mutex.has(rawValue)) {\r\n                return mutex.delete(rawValue);\r\n            }\r\n            if (!path.length)\r\n                node.input(value, false);\r\n            else\r\n                (_a = node.at(path)) === null || _a === void 0 ? void 0 : _a.input(value, false);\r\n        });\r\n        /**\r\n         * On initialization, if the node’s value was updated (like in a plugin\r\n         * hook) then we should emit a `modelUpdated` event.\r\n         */\r\n        if (node.value !== value) {\r\n            node.emit('modelUpdated');\r\n        }\r\n    }\r\n    /**\r\n     * When this input shuts down, we need to \"delete\" the node too.\r\n     */\r\n    // onUnmounted(() => node.destroy())\r\n    onBeforeUnmount(() => node.destroy());\r\n    return node;\r\n}\r\n\r\nlet totalCreated = 1;\r\n/**\r\n * Determine if the given object is a vue component.\r\n *\r\n * @param obj - Object or function\r\n * @returns\r\n * @public\r\n */\r\nfunction isComponent(obj) {\r\n    return ((typeof obj === 'function' && obj.length === 2) ||\r\n        (typeof obj === 'object' &&\r\n            !Array.isArray(obj) &&\r\n            !('$el' in obj) &&\r\n            !('$cmp' in obj) &&\r\n            !('if' in obj)));\r\n}\r\n/**\r\n * Creates a new input from schema or a Vue component with the \"standard\"\r\n * FormKit features in place such as labels, help text, validation messages, and\r\n * class support.\r\n *\r\n * @param schemaOrComponent - The actual schema of the input or the component.\r\n * @param definitionOptions - Any options in the FormKitTypeDefinition you want\r\n * to define.\r\n *\r\n * @returns {@link @formkit/core#FormKitTypeDefinition | FormKitTypeDefinition}\r\n *\r\n * @public\r\n */\r\nfunction createInput(schemaOrComponent, definitionOptions = {}) {\r\n    const definition = {\r\n        type: 'input',\r\n        ...definitionOptions,\r\n    };\r\n    let schema;\r\n    if (isComponent(schemaOrComponent)) {\r\n        const cmpName = `SchemaComponent${totalCreated++}`;\r\n        schema = createSection('input', () => ({\r\n            $cmp: cmpName,\r\n            props: {\r\n                context: '$node.context',\r\n            },\r\n        }));\r\n        definition.library = { [cmpName]: markRaw(schemaOrComponent) };\r\n    }\r\n    else if (typeof schemaOrComponent === 'function') {\r\n        schema = schemaOrComponent;\r\n    }\r\n    else {\r\n        schema = createSection('input', () => cloneAny(schemaOrComponent));\r\n    }\r\n    // Use the default wrapping schema\r\n    definition.schema = useSchema(schema || 'Schema undefined');\r\n    return definition;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nconst messages = createSection('messages', () => ({\r\n    $el: 'ul',\r\n    if: '$fns.length($messages)',\r\n}), true);\r\n/**\r\n * @internal\r\n */\r\nconst message = createSection('message', () => ({\r\n    $el: 'li',\r\n    for: ['message', '$messages'],\r\n    attrs: {\r\n        key: '$message.key',\r\n        id: `$id + '-' + $message.key`,\r\n        'data-message-type': '$message.type',\r\n    },\r\n}));\r\n/**\r\n * The actual schema to render for the messages.\r\n */\r\nconst definition = messages(message('$message.value'));\r\n/**\r\n * Renders the messages for a parent node, or any node explicitly passed to it.\r\n * @public\r\n */\r\nconst FormKitMessages = defineComponent({\r\n    props: {\r\n        node: {\r\n            type: Object,\r\n            required: false,\r\n        },\r\n        sectionsSchema: {\r\n            type: Object,\r\n            default: {},\r\n        },\r\n        defaultPosition: {\r\n            type: [String, Boolean],\r\n            default: false,\r\n        },\r\n    },\r\n    setup(props, context) {\r\n        const node = computed(() => {\r\n            return props.node || inject(parentSymbol, undefined);\r\n        });\r\n        watch(node, () => {\r\n            var _a;\r\n            if (((_a = node.value) === null || _a === void 0 ? void 0 : _a.context) && !undefine(props.defaultPosition)) {\r\n                node.value.context.defaultMessagePlacement = false;\r\n            }\r\n        }, { immediate: true });\r\n        const schema = definition(props.sectionsSchema || {});\r\n        const data = computed(() => {\r\n            var _a, _b, _c, _d, _e, _f;\r\n            return {\r\n                messages: ((_b = (_a = node.value) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.messages) || {},\r\n                fns: ((_d = (_c = node.value) === null || _c === void 0 ? void 0 : _c.context) === null || _d === void 0 ? void 0 : _d.fns) || {},\r\n                classes: ((_f = (_e = node.value) === null || _e === void 0 ? void 0 : _e.context) === null || _f === void 0 ? void 0 : _f.classes) || {},\r\n            };\r\n        });\r\n        return () => {\r\n            var _a;\r\n            return ((_a = node.value) === null || _a === void 0 ? void 0 : _a.context)\r\n                ? h(FormKitSchema, { schema, data: data.value }, { ...context.slots })\r\n                : null;\r\n        };\r\n    },\r\n});\r\n\r\n/**\r\n * A plugin that creates Vue-specific context object on each given node.\r\n *\r\n * @param node - FormKitNode to create the context on.\r\n *\r\n * @public\r\n */\r\nconst vueBindings = function vueBindings(node) {\r\n    /**\r\n     * Start a validity counter on all blocking messages.\r\n     */\r\n    node.ledger.count('blocking', (m) => m.blocking);\r\n    const isValid = ref(!node.ledger.value('blocking'));\r\n    /**\r\n     * Start an error message counter.\r\n     */\r\n    node.ledger.count('errors', (m) => m.type === 'error');\r\n    const hasErrors = ref(!!node.ledger.value('errors'));\r\n    /**\r\n     * Keep track of the first time a Vue tick cycle has passed.\r\n     */\r\n    let hasTicked = false;\r\n    nextTick(() => {\r\n        hasTicked = true;\r\n    });\r\n    /**\r\n     * All messages with the visibility state set to true.\r\n     */\r\n    const availableMessages = reactive(node.store.reduce((store, message) => {\r\n        if (message.visible) {\r\n            store[message.key] = message;\r\n        }\r\n        return store;\r\n    }, {}));\r\n    /**\r\n     * A flag that determines when validation messages should be displayed.\r\n     */\r\n    const validationVisibility = ref(node.props.validationVisibility || 'blur');\r\n    node.on('prop:validationVisibility', ({ payload }) => {\r\n        validationVisibility.value = payload;\r\n    });\r\n    /**\r\n     * Keep track of if this input has ever shown validation errors.\r\n     */\r\n    const hasShownErrors = ref(validationVisibility.value === 'live');\r\n    /**\r\n     * The current visibility state of validation messages.\r\n     */\r\n    const validationVisible = computed(() => {\r\n        if (context.state.submitted)\r\n            return true;\r\n        if (!hasShownErrors.value && !context.state.settled) {\r\n            return false;\r\n        }\r\n        switch (validationVisibility.value) {\r\n            case 'live':\r\n                return true;\r\n            case 'blur':\r\n                return context.state.blurred;\r\n            case 'dirty':\r\n                return context.state.dirty;\r\n            default:\r\n                return false;\r\n        }\r\n    });\r\n    /**\r\n     * Determines if the input should be considered \"complete\".\r\n     */\r\n    const isComplete = computed(() => {\r\n        return hasValidation.value\r\n            ? isValid.value && !hasErrors.value\r\n            : context.state.dirty && !empty(context.value);\r\n    });\r\n    /**\r\n     * If the input has validation rules or not.\r\n     */\r\n    const hasValidation = ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);\r\n    node.on('prop:parsedRules', ({ payload: rules }) => {\r\n        hasValidation.value = Array.isArray(rules) && rules.length > 0;\r\n    });\r\n    /**\r\n     * All messages that are currently on display to an end user. This changes\r\n     * based on the current message type visibility, like errorVisibility.\r\n     */\r\n    const messages = computed(() => {\r\n        const visibleMessages = {};\r\n        for (const key in availableMessages) {\r\n            const message = availableMessages[key];\r\n            if (message.type !== 'validation' || validationVisible.value) {\r\n                visibleMessages[key] = message;\r\n            }\r\n        }\r\n        return visibleMessages;\r\n    });\r\n    /**\r\n     * UI Messages.\r\n     */\r\n    const ui = reactive(node.store.reduce((messages, message) => {\r\n        if (message.type === 'ui' && message.visible)\r\n            messages[message.key] = message;\r\n        return messages;\r\n    }, {}));\r\n    /**\r\n     * This is the reactive data object that is provided to all schemas and\r\n     * forms. It is a subset of data in the core node object.\r\n     */\r\n    const cachedClasses = reactive({});\r\n    const classes = new Proxy(cachedClasses, {\r\n        get(...args) {\r\n            const [target, property] = args;\r\n            let className = Reflect.get(...args);\r\n            if (!className && typeof property === 'string') {\r\n                if (!has(target, property) && !property.startsWith('__v')) {\r\n                    const observedNode = createObserver(node);\r\n                    observedNode.watch((node) => {\r\n                        const rootClasses = typeof node.config.rootClasses === 'function'\r\n                            ? node.config.rootClasses(property, node)\r\n                            : {};\r\n                        const globalConfigClasses = node.config.classes\r\n                            ? createClasses(property, node, node.config.classes[property])\r\n                            : {};\r\n                        const classesPropClasses = createClasses(property, node, node.props[`_${property}Class`]);\r\n                        const sectionPropClasses = createClasses(property, node, node.props[`${property}Class`]);\r\n                        className = generateClassList(node, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);\r\n                        target[property] = className !== null && className !== void 0 ? className : '';\r\n                    });\r\n                }\r\n            }\r\n            return className;\r\n        },\r\n    });\r\n    const describedBy = computed(() => {\r\n        const describers = [];\r\n        if (context.help) {\r\n            describers.push(`help-${node.props.id}`);\r\n        }\r\n        for (const key in messages.value) {\r\n            describers.push(`${node.props.id}-${key}`);\r\n        }\r\n        return describers.length ? describers.join(' ') : undefined;\r\n    });\r\n    const value = ref(node.value);\r\n    const _value = ref(node.value);\r\n    const context = reactive({\r\n        _value,\r\n        attrs: node.props.attrs,\r\n        disabled: node.props.disabled,\r\n        describedBy,\r\n        fns: {\r\n            length: (obj) => Object.keys(obj).length,\r\n            number: (value) => Number(value),\r\n            string: (value) => String(value),\r\n            json: (value) => JSON.stringify(value),\r\n            eq,\r\n        },\r\n        handlers: {\r\n            blur: (e) => {\r\n                node.store.set(createMessage({ key: 'blurred', visible: false, value: true }));\r\n                if (typeof node.props.attrs.onBlur === 'function') {\r\n                    node.props.attrs.onBlur(e);\r\n                }\r\n            },\r\n            touch: () => {\r\n                var _a;\r\n                const doCompare = context.dirtyBehavior === 'compare';\r\n                if (((_a = node.store.dirty) === null || _a === void 0 ? void 0 : _a.value) && !doCompare)\r\n                    return;\r\n                const isDirty = !eq(node.props._init, node._value);\r\n                if (!isDirty && !doCompare)\r\n                    return;\r\n                node.store.set(createMessage({ key: 'dirty', visible: false, value: isDirty }));\r\n            },\r\n            DOMInput: (e) => {\r\n                node.input(e.target.value);\r\n                node.emit('dom-input-event', e);\r\n            },\r\n        },\r\n        help: node.props.help,\r\n        id: node.props.id,\r\n        label: node.props.label,\r\n        messages,\r\n        node: markRaw(node),\r\n        options: node.props.options,\r\n        defaultMessagePlacement: true,\r\n        state: {\r\n            blurred: false,\r\n            complete: isComplete,\r\n            dirty: false,\r\n            submitted: false,\r\n            settled: node.isSettled,\r\n            valid: isValid,\r\n            errors: hasErrors,\r\n            rules: hasValidation,\r\n            validationVisible,\r\n        },\r\n        type: node.props.type,\r\n        family: node.props.family,\r\n        ui,\r\n        value,\r\n        classes,\r\n    });\r\n    /**\r\n     * Ensure the context object is properly configured after booting up.\r\n     */\r\n    node.on('created', () => {\r\n        if (!eq(context.value, node.value)) {\r\n            _value.value = node.value;\r\n            value.value = node.value;\r\n            triggerRef(value);\r\n            triggerRef(_value);\r\n        }\r\n        (async () => {\r\n            await node.settled;\r\n            node.props._init = cloneAny(node.value);\r\n        })();\r\n    });\r\n    /**\r\n     * Sets the settled state.\r\n     */\r\n    node.on('settled', ({ payload: isSettled }) => {\r\n        context.state.settled = isSettled;\r\n    });\r\n    /**\r\n     * Observes node.props properties explicitly and updates them in the context\r\n     * object.\r\n     * @param observe - Props to observe and register as context data.\r\n     */\r\n    function observeProps(observe) {\r\n        observe.forEach((prop) => {\r\n            prop = camel(prop);\r\n            if (!has(context, prop) && has(node.props, prop)) {\r\n                context[prop] = node.props[prop];\r\n            }\r\n            node.on(`prop:${prop}`, ({ payload }) => {\r\n                context[prop] = payload;\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * We use a node observer to individually observe node props.\r\n     */\r\n    const rootProps = () => {\r\n        const props = [\r\n            'help',\r\n            'label',\r\n            'disabled',\r\n            'options',\r\n            'type',\r\n            'attrs',\r\n            'preserve',\r\n            'preserveErrors',\r\n            'id',\r\n            'dirtyBehavior',\r\n        ];\r\n        const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/;\r\n        const matchingProps = Object.keys(node.props).filter((prop) => {\r\n            return iconPattern.test(prop);\r\n        });\r\n        return props.concat(matchingProps);\r\n    };\r\n    observeProps(rootProps());\r\n    /**\r\n     * Once the input is defined, deal with it.\r\n     * @param definition - Type definition.\r\n     */\r\n    function definedAs(definition) {\r\n        if (definition.props)\r\n            observeProps(definition.props);\r\n    }\r\n    node.props.definition && definedAs(node.props.definition);\r\n    /**\r\n     * When new props are added to the core node as \"props\" (ie not attrs) then\r\n     * we automatically need to start tracking them here.\r\n     */\r\n    node.on('added-props', ({ payload }) => observeProps(payload));\r\n    /**\r\n     * Watch for input events from core.\r\n     */\r\n    node.on('input', ({ payload }) => {\r\n        if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\r\n            _value.value = shallowClone(payload);\r\n        }\r\n        else {\r\n            _value.value = payload;\r\n            triggerRef(_value);\r\n        }\r\n    });\r\n    /**\r\n     * Watch for input commits from core.\r\n     */\r\n    node.on('commit', ({ payload }) => {\r\n        if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\r\n            value.value = _value.value = shallowClone(payload);\r\n        }\r\n        else {\r\n            value.value = _value.value = payload;\r\n            triggerRef(value);\r\n        }\r\n        node.emit('modelUpdated');\r\n        // The input is dirty after a value has been input by a user\r\n        if ((!context.state.dirty || context.dirtyBehavior === 'compare') &&\r\n            node.isCreated &&\r\n            hasTicked) {\r\n            context.handlers.touch();\r\n        }\r\n        if (isComplete &&\r\n            node.type === 'input' &&\r\n            hasErrors.value &&\r\n            !undefine(node.props.preserveErrors)) {\r\n            node.store.filter((message) => { var _a; return !(message.type === 'error' && ((_a = message.meta) === null || _a === void 0 ? void 0 : _a.autoClear) === true); });\r\n        }\r\n    });\r\n    /**\r\n     * Update the local state in response to messages.\r\n     * @param message - A formkit message\r\n     */\r\n    const updateState = async (message) => {\r\n        if (message.type === 'ui' &&\r\n            message.visible &&\r\n            !message.meta.showAsMessage) {\r\n            ui[message.key] = message;\r\n        }\r\n        else if (message.visible) {\r\n            availableMessages[message.key] = message;\r\n        }\r\n        else if (message.type === 'state') {\r\n            // await node.settled\r\n            context.state[message.key] = !!message.value;\r\n        }\r\n    };\r\n    /**\r\n     * Listen to message events and modify the local message data values.\r\n     */\r\n    node.on('message-added', (e) => updateState(e.payload));\r\n    node.on('message-updated', (e) => updateState(e.payload));\r\n    node.on('message-removed', ({ payload: message }) => {\r\n        delete ui[message.key];\r\n        delete availableMessages[message.key];\r\n        delete context.state[message.key];\r\n    });\r\n    node.on('settled:blocking', () => {\r\n        isValid.value = true;\r\n    });\r\n    node.on('unsettled:blocking', () => {\r\n        isValid.value = false;\r\n    });\r\n    node.on('settled:errors', () => {\r\n        hasErrors.value = false;\r\n    });\r\n    node.on('unsettled:errors', () => {\r\n        hasErrors.value = true;\r\n    });\r\n    /**\r\n     * Watch the validation visible prop and set the hasShownErrors state.\r\n     */\r\n    watch(validationVisible, (value) => {\r\n        if (value) {\r\n            hasShownErrors.value = true;\r\n        }\r\n    });\r\n    node.context = context;\r\n    // The context is complete\r\n    node.emit('context', node, false);\r\n};\r\n\r\n/**\r\n * Default configuration options. Includes all validation rules,\r\n * en i18n messages.\r\n *\r\n * @public\r\n */\r\nconst defaultConfig = (options = {}) => {\r\n    const { rules = {}, locales = {}, inputs: inputs$1 = {}, messages = {}, locale = undefined, theme = undefined, iconLoaderUrl = undefined, iconLoader = undefined, icons = {}, ...nodeOptions } = options;\r\n    /**\r\n     * The default configuration includes the validation plugin,\r\n     * with all core-available validation rules.\r\n     */\r\n    const validation = createValidationPlugin({\r\n        ...defaultRules,\r\n        ...(rules || {}),\r\n    });\r\n    /**\r\n     * Includes the i18n plugin with only the english language\r\n     * messages.\r\n     */\r\n    const i18n = createI18nPlugin(extend({ en, ...(locales || {}) }, messages));\r\n    /**\r\n     * Create the library of inputs that are generally available. This default\r\n     * config imports all \"native\" inputs by default, but\r\n     */\r\n    const library = createLibraryPlugin(inputs, inputs$1);\r\n    /**\r\n     * Create the theme plugin for the user provided theme\r\n     */\r\n    const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader);\r\n    return extend({\r\n        plugins: [library, themePlugin, vueBindings, i18n, validation],\r\n        ...(!locale ? {} : { config: { locale } }),\r\n    }, nodeOptions || {}, true);\r\n};\r\n\r\n/**\r\n * Renders an icon using the current IconLoader set at the root FormKit config\r\n *\r\n * @public\r\n */\r\nconst FormKitIcon = defineComponent({\r\n    name: 'FormKitIcon',\r\n    props: {\r\n        icon: {\r\n            type: String,\r\n            default: ''\r\n        },\r\n        iconLoader: {\r\n            type: Function,\r\n            default: null\r\n        },\r\n        iconLoaderUrl: {\r\n            type: Function,\r\n            default: null\r\n        }\r\n    },\r\n    setup(props) {\r\n        var _a, _b;\r\n        const icon = ref(undefined);\r\n        const config = inject(optionsSymbol, {});\r\n        const parent = inject(parentSymbol, null);\r\n        let iconHandler = undefined;\r\n        function loadIcon() {\r\n            if (!iconHandler || typeof iconHandler !== 'function')\r\n                return;\r\n            const iconOrPromise = iconHandler(props.icon);\r\n            if (iconOrPromise instanceof Promise) {\r\n                iconOrPromise.then((iconValue) => {\r\n                    icon.value = iconValue;\r\n                });\r\n            }\r\n            else {\r\n                icon.value = iconOrPromise;\r\n            }\r\n        }\r\n        if (props.iconLoader && typeof props.iconLoader === 'function') {\r\n            // if we have a locally supplied loader, then use it\r\n            iconHandler = createIconHandler(props.iconLoader);\r\n        }\r\n        else if (parent && ((_a = parent.props) === null || _a === void 0 ? void 0 : _a.iconLoader)) {\r\n            // otherwise try to inherit from a parent\r\n            iconHandler = createIconHandler(parent.props.iconLoader);\r\n        }\r\n        else if (props.iconLoaderUrl && typeof props.iconLoaderUrl === 'function') {\r\n            iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl);\r\n        }\r\n        else {\r\n            // grab our iconHandler from the global config\r\n            const iconPlugin = (_b = config === null || config === void 0 ? void 0 : config.plugins) === null || _b === void 0 ? void 0 : _b.find(plugin => {\r\n                return typeof plugin.iconHandler === 'function';\r\n            });\r\n            if (iconPlugin) {\r\n                iconHandler = iconPlugin.iconHandler;\r\n            }\r\n        }\r\n        watch(() => props.icon, () => {\r\n            loadIcon();\r\n        }, { immediate: true });\r\n        return () => {\r\n            if (props.icon && icon.value) {\r\n                return h('span', {\r\n                    class: 'formkit-icon',\r\n                    innerHTML: icon.value\r\n                });\r\n            }\r\n            return null;\r\n        };\r\n    }\r\n});\r\n\r\nexport { FormKit, FormKitIcon, FormKitMessages, FormKitSchema, vueBindings as bindings, configSymbol, createInput, defaultConfig, optionsSymbol, parentSymbol, plugin, useInput, watchVerbose };\r\n"],
  "mappings": "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",
  "names": ["accepted", "between", "confirm", "date_between", "email", "ends_with", "is", "length", "min", "max", "matches", "not", "number", "required", "starts_with", "url", "props", "watch", "res", "validation", "_a", "message", "node", "matches", "hints", "themePlugin", "_a", "error", "warn", "token", "i", "library", "getValue", "slotData", "schema", "element", "data", "instanceKey", "props", "initialProps", "messages", "error", "message", "value", "_a", "isComponent", "definition", "vueBindings", "node", "plugin"]
}
